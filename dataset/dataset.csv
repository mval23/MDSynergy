code_only,Prompt,Result
"```python
def twoSum(nums, target):
    map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in map:
            return [map[complement], i]
        map[num] = i
    return []
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def twoSum(nums, target):
    map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in map:
            return [map[complement], i]
        map[num] = i
    return []
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
        carry = sum_val // 10
        current.next = ListNode(sum_val % 10)
        current = current.next

        if l1: l1 = l1.next
        if l2: l2 = l2.next

    return dummy.next
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
        carry = sum_val // 10
        current.next = ListNode(sum_val % 10)
        current = current.next

        if l1: l1 = l1.next
        if l2: l2 = l2.next

    return dummy.next
```

"
"```python
def length_of_longest_substring(s: str) -> int:
    left = 0
    right = 0
    max_length = 0
    characters = set()

    while right < len(s):
        if s[right] not in characters:
            characters.add(s[right])
            max_length = max(max_length, right - left + 1)
            right += 1
        else:
            characters.remove(s[left])
            left += 1

    return max_length
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def length_of_longest_substring(s: str) -> int:
    left = 0
    right = 0
    max_length = 0
    characters = set()

    while right < len(s):
        if s[right] not in characters:
            characters.add(s[right])
            max_length = max(max_length, right - left + 1)
            right += 1
        else:
            characters.remove(s[left])
            left += 1

    return max_length
```

"
"```python
def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        return findMedianSortedArrays(nums2, nums1)
    
    x, y = len(nums1), len(nums2)
    low, high = 0, x

    while low <= high:
        partition_x = (low + high) // 2
        partition_y = (x + y + 1) // 2 - partition_x

        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]
        min_right_x = float('inf') if partition_x == x else nums1[partition_x]

        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]
        min_right_y = float('inf') if partition_y == y else nums2[partition_y]

        if max_left_x <= min_right_y and max_left_y <= min_right_x:
            if (x + y) % 2 == 0:
                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
            else:
                return max(max_left_x, max_left_y)
        elif max_left_x > min_right_y:
            high = partition_x - 1
        else:
            low = partition_x + 1
    
    return 0
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        return findMedianSortedArrays(nums2, nums1)
    
    x, y = len(nums1), len(nums2)
    low, high = 0, x

    while low <= high:
        partition_x = (low + high) // 2
        partition_y = (x + y + 1) // 2 - partition_x

        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]
        min_right_x = float('inf') if partition_x == x else nums1[partition_x]

        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]
        min_right_y = float('inf') if partition_y == y else nums2[partition_y]

        if max_left_x <= min_right_y and max_left_y <= min_right_x:
            if (x + y) % 2 == 0:
                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
            else:
                return max(max_left_x, max_left_y)
        elif max_left_x > min_right_y:
            high = partition_x - 1
        else:
            low = partition_x + 1
    
    return 0
```

"
"```python
def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    if n == 0: return """"

    start, max_length = 0, 1

    for i in range(n):
        l, r = i, i

        while r < n - 1 and s[r] == s[r + 1]:
            r += 1
        i = r

        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:
            l -= 1
            r += 1

        length = r - l + 1
        if length > max_length:
            start, max_length = l, length

    return s[start:start + max_length]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    if n == 0: return """"

    start, max_length = 0, 1

    for i in range(n):
        l, r = i, i

        while r < n - 1 and s[r] == s[r + 1]:
            r += 1
        i = r

        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:
            l -= 1
            r += 1

        length = r - l + 1
        if length > max_length:
            start, max_length = l, length

    return s[start:start + max_length]
```

"
"```python
def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s

    rows = [""""] * numRows
    curRow = 0
    goingDown = False

    for c in s:
        rows[curRow] += c
        if curRow == 0 or curRow == numRows - 1:
            goingDown = not goingDown
        curRow += 1 if goingDown else -1

    return """".join(rows)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s

    rows = [""""] * numRows
    curRow = 0
    goingDown = False

    for c in s:
        rows[curRow] += c
        if curRow == 0 or curRow == numRows - 1:
            goingDown = not goingDown
        curRow += 1 if goingDown else -1

    return """".join(rows)
```

"
"```python
def reverse(x: int) -> int:
    sign = -1 if x < 0 else 1
    x = abs(x)
    res = 0
    while x:
        res = res * 10 + x % 10
        x //= 10
    res *= sign
    return res if -2**31 <= res <= 2**31 - 1 else 0
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def reverse(x: int) -> int:
    sign = -1 if x < 0 else 1
    x = abs(x)
    res = 0
    while x:
        res = res * 10 + x % 10
        x //= 10
    res *= sign
    return res if -2**31 <= res <= 2**31 - 1 else 0
```

"
"```python
def myAtoi(s):
    result, i, sign = 0, 0, 1
    while i < len(s) and s[i] == ' ': i += 1
    if i < len(s) and (s[i] == '-' or s[i] == '+'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
        if result * sign > 2**31 - 1: return 2**31 - 1
        if result * sign < -2**31: return -2**31
    return result * sign
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def myAtoi(s):
    result, i, sign = 0, 0, 1
    while i < len(s) and s[i] == ' ': i += 1
    if i < len(s) and (s[i] == '-' or s[i] == '+'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
        if result * sign > 2**31 - 1: return 2**31 - 1
        if result * sign < -2**31: return -2**31
    return result * sign
```

"
"```python
def is_palindrome(x: int) -> bool:
    if x < 0:
        return False
    original, reversed = x, 0
    while x > 0:
        reversed = reversed * 10 + x % 10
        x //= 10
    return original == reversed
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def is_palindrome(x: int) -> bool:
    if x < 0:
        return False
    original, reversed = x, 0
    while x > 0:
        reversed = reversed * 10 + x % 10
        x //= 10
    return original == reversed
```


"
"```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for j in range(1, n + 1):
        if p[j - 1] == '*' and dp[0][j - 2]:
            dp[0][j] = True

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))

    return dp[m][n]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for j in range(1, n + 1):
        if p[j - 1] == '*' and dp[0][j - 2]:
            dp[0][j] = True

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))

    return dp[m][n]
```

"
"```python
def max_area(height):
    max_area, left, right = 0, 0, len(height) - 1
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def max_area(height):
    max_area, left, right = 0, 0, len(height) - 1
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

"
"```python
def int_to_roman(num):
    romans = [
        (1000, ""M""), (900, ""CM""), (500, ""D""),
        (400, ""CD""), (100, ""C""), (90, ""XC""),
        (50, ""L""), (40, ""XL""), (10, ""X""), 
        (9, ""IX""), (5, ""V""), (4, ""IV""), (1, ""I"")
    ]
    roman = """"
    for value, symbol in romans:
        while num >= value:
            roman += symbol
            num -= value
    return roman
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def int_to_roman(num):
    romans = [
        (1000, ""M""), (900, ""CM""), (500, ""D""),
        (400, ""CD""), (100, ""C""), (90, ""XC""),
        (50, ""L""), (40, ""XL""), (10, ""X""), 
        (9, ""IX""), (5, ""V""), (4, ""IV""), (1, ""I"")
    ]
    roman = """"
    for value, symbol in romans:
        while num >= value:
            roman += symbol
            num -= value
    return roman
```

"
"```python
def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    
    for c in s:
        current_value = roman_values[c]
        if current_value > prev_value:
            total += current_value - 2 * prev_value
        else:
            total += current_value
        prev_value = current_value

    return total
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    
    for c in s:
        current_value = roman_values[c]
        if current_value > prev_value:
            total += current_value - 2 * prev_value
        else:
            total += current_value
        prev_value = current_value

    return total
```


"
"```python
def longest_common_prefix(strs):
    if not strs:
        return """"

    for i, c in enumerate(strs[0]):
        for j in range(1, len(strs)):
            if i == len(strs[j]) or strs[j][i] != c:
                return strs[0][:i]
    return strs[0]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def longest_common_prefix(strs):
    if not strs:
        return """"

    for i, c in enumerate(strs[0]):
        for j in range(1, len(strs)):
            if i == len(strs[j]) or strs[j][i] != c:
                return strs[0][:i]
    return strs[0]
```

"
"```python
def threeSum(nums):
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        if i == 0 or nums[i] != nums[i - 1]:
            j, k = i + 1, len(nums) - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    result.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def threeSum(nums):
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        if i == 0 or nums[i] != nums[i - 1]:
            j, k = i + 1, len(nums) - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    result.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1

    return result
```

"
"```python
def threeSumClosest(nums, target):
    nums.sort()
    closest = sum(nums[:3])
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            cur_sum = nums[i] + nums[left] + nums[right]
            if cur_sum == target:
                return cur_sum
            if abs(target - cur_sum) < abs(target - closest):
                closest = cur_sum
            if cur_sum < target:
                left += 1
            else:
                right -= 1
    return closest
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def threeSumClosest(nums, target):
    nums.sort()
    closest = sum(nums[:3])
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            cur_sum = nums[i] + nums[left] + nums[right]
            if cur_sum == target:
                return cur_sum
            if abs(target - cur_sum) < abs(target - closest):
                closest = cur_sum
            if cur_sum < target:
                left += 1
            else:
                right -= 1
    return closest
```

"
"```python
def letter_combinations(digits: str):
    if not digits: return []
    phone = [""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]
    result = [""""]

    for digit in digits:
        temp = []
        for s in result:
            for c in phone[int(digit) - 2]:
                temp.append(s + c)
        result = temp

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def letter_combinations(digits: str):
    if not digits: return []
    phone = [""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]
    result = [""""]

    for digit in digits:
        temp = []
        for s in result:
            for c in phone[int(digit) - 2]:
                temp.append(s + c)
        result = temp

    return result
```

"
"```python
def fourSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = len(nums) - 1
            while left < right:
                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]
                if cur_sum == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]: left += 1
                    while left < right and nums[right] == nums[right + 1]: right -= 1
                elif cur_sum < target:
                    left += 1
                else:
                    right -= 1
    return result
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def fourSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = len(nums) - 1
            while left < right:
                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]
                if cur_sum == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]: left += 1
                    while left < right and nums[right] == nums[right + 1]: right -= 1
                elif cur_sum < target:
                    left += 1
                else:
                    right -= 1
    return result
```


"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    first = head
    second = head
    
    for i in range(n):
        first = first.next
    
    if not first:
        head = head.next
        return head
    
    while first.next:
        first = first.next
        second = second.next
    
    second.next = second.next.next
    
    return head
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    first = head
    second = head
    
    for i in range(n):
        first = first.next
    
    if not first:
        head = head.next
        return head
    
    while first.next:
        first = first.next
        second = second.next
    
    second.next = second.next.next
    
    return head
```

"
"```python
def is_valid(s: str) -> bool:
    stack = []

    for c in s:
        if c in '([{':
            stack.append(c)
        else:
            if not stack:
                return False
            if c == ')' and stack[-1] != '(':
                return False
            if c == '}' and stack[-1] != '{':
                return False
            if c == ']' and stack[-1] != '[':
                return False
            stack.pop()

    return not stack
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def is_valid(s: str) -> bool:
    stack = []

    for c in s:
        if c in '([{':
            stack.append(c)
        else:
            if not stack:
                return False
            if c == ')' and stack[-1] != '(':
                return False
            if c == '}' and stack[-1] != '{':
                return False
            if c == ']' and stack[-1] != '[':
                return False
            stack.pop()

    return not stack
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
         
def merge_two_lists(list1, list2):
    if list1 is None:
        return list2
    if list2 is None:
        return list1

    if list1.val < list2.val:
        list1.next = merge_two_lists(list1.next, list2)
        return list1
    else:
        list2.next = merge_two_lists(list1, list2.next)
        return list2
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
         
def merge_two_lists(list1, list2):
    if list1 is None:
        return list2
    if list2 is None:
        return list1

    if list1.val < list2.val:
        list1.next = merge_two_lists(list1.next, list2)
        return list1
    else:
        list2.next = merge_two_lists(list1, list2.next)
        return list2
```

"
"```python
def generate_parenthesis(n):
    def generate_parenthesis_helper(open, close, current):
        if open == 0 and close == 0:
            result.append(current)
            return
        if open > 0:
            generate_parenthesis_helper(open - 1, close + 1, current + '(')
        if close > 0:
            generate_parenthesis_helper(open, close - 1, current + ')')

    result = []
    generate_parenthesis_helper(n, 0, '')
    return result
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def generate_parenthesis(n):
    def generate_parenthesis_helper(open, close, current):
        if open == 0 and close == 0:
            result.append(current)
            return
        if open > 0:
            generate_parenthesis_helper(open - 1, close + 1, current + '(')
        if close > 0:
            generate_parenthesis_helper(open, close - 1, current + ')')

    result = []
    generate_parenthesis_helper(n, 0, '')
    return result
```


"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class Solution:
    def mergeKLists(self, lists):
        if not lists: return None
        while len(lists) > 1:
            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))
        return lists[0]
        
    def merge2Lists(self, l1, l2):
        if not l1: return l2
        if not l2: return l1
        if l1.val <= l2.val:
            l1.next = self.merge2Lists(l1.next, l2)
            return l1
        else:
            l2.next = self.merge2Lists(l1, l2.next)
            return l2
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class Solution:
    def mergeKLists(self, lists):
        if not lists: return None
        while len(lists) > 1:
            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))
        return lists[0]
        
    def merge2Lists(self, l1, l2):
        if not l1: return l2
        if not l2: return l1
        if l1.val <= l2.val:
            l1.next = self.merge2Lists(l1.next, l2)
            return l1
        else:
            l2.next = self.merge2Lists(l1, l2.next)
            return l2
```


"
"```python
def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head

    second = head.next
    head.next = swapPairs(second.next)
    second.next = head

    return second
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head

    second = head.next
    head.next = swapPairs(second.next)
    second.next = head

    return second
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if not head or k == 1:
        return head
        
    cur = head
    length = 0
    while cur:
        length += 1
        cur = cur.next
        
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    cur = head
    
    while length >= k:
        for _ in range(1, k):
            temp = cur.next
            cur.next = temp.next
            temp.next = prev.next
            prev.next = temp
            
        prev = cur
        cur = cur.next
        length -= k
        
    return dummy.next
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if not head or k == 1:
        return head
        
    cur = head
    length = 0
    while cur:
        length += 1
        cur = cur.next
        
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    cur = head
    
    while length >= k:
        for _ in range(1, k):
            temp = cur.next
            cur.next = temp.next
            temp.next = prev.next
            prev.next = temp
            
        prev = cur
        cur = cur.next
        length -= k
        
    return dummy.next
```


"
"```python
def removeDuplicates(nums):
    if not nums: return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def removeDuplicates(nums):
    if not nums: return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```


"
"```python
def removeElement(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def removeElement(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i
```

"
"```python
def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    try:
        index = haystack.index(needle)
        return index
    except ValueError:
        return -1
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    try:
        index = haystack.index(needle)
        return index
    except ValueError:
        return -1
```

"
"```python
def divide(dividend: int, divisor: int) -> int:
    if dividend == -(2**31) and divisor == -1:
        return 2**31 - 1

    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1

    dvd = abs(dividend)
    dvs = abs(divisor)
    ans = 0

    while dvd >= dvs:
        temp = dvs
        multiple = 1
        while dvd >= (temp << 1):
            temp <<= 1
            multiple <<= 1
        dvd -= temp
        ans += multiple

    return ans * sign
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def divide(dividend: int, divisor: int) -> int:
    if dividend == -(2**31) and divisor == -1:
        return 2**31 - 1

    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1

    dvd = abs(dividend)
    dvs = abs(divisor)
    ans = 0

    while dvd >= dvs:
        temp = dvs
        multiple = 1
        while dvd >= (temp << 1):
            temp <<= 1
            multiple <<= 1
        dvd -= temp
        ans += multiple

    return ans * sign
```

"
"```python
from collections import Counter

def findSubstring(s, words):
    if not s or not words:
        return []

    word_count = Counter(words)
    word_length = len(words[0])
    total_words = len(words)
    total_length = word_length * total_words
    result = []

    for i in range(len(s) - total_length + 1):
        temp_word_count = Counter()
        for j in range(total_words):
            current_word = s[i + j * word_length:i + (j + 1) * word_length]
            if current_word not in word_count:
                break
            temp_word_count[current_word] += 1
            if temp_word_count[current_word] > word_count[current_word]:
                break
            if j + 1 == total_words:
                result.append(i)

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from collections import Counter

def findSubstring(s, words):
    if not s or not words:
        return []

    word_count = Counter(words)
    word_length = len(words[0])
    total_words = len(words)
    total_length = word_length * total_words
    result = []

    for i in range(len(s) - total_length + 1):
        temp_word_count = Counter()
        for j in range(total_words):
            current_word = s[i + j * word_length:i + (j + 1) * word_length]
            if current_word not in word_count:
                break
            temp_word_count[current_word] += 1
            if temp_word_count[current_word] > word_count[current_word]:
                break
            if j + 1 == total_words:
                result.append(i)

    return result
```

"
"```python
def nextPermutation(nums):
    n, k = len(nums), -1
    for i in range(n - 1, 0, -1):
        if nums[i - 1] < nums[i]:
            k = i - 1
            break
    if k == -1:
        nums.reverse()
    else:
        l = 0
        for i in range(n - 1, k, -1):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k + 1:] = reversed(nums[k + 1:])
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def nextPermutation(nums):
    n, k = len(nums), -1
    for i in range(n - 1, 0, -1):
        if nums[i - 1] < nums[i]:
            k = i - 1
            break
    if k == -1:
        nums.reverse()
    else:
        l = 0
        for i in range(n - 1, k, -1):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k + 1:] = reversed(nums[k + 1:])
```

"
"```python
def longest_valid_parentheses(s: str) -> int:
    n = len(s)
    result = 0
    st = []

    for i in range(n):
        if s[i] == '(':
            st.append(i)
        else:
            if st and s[st[-1]] == '(':
                st.pop()
            else:
                st.append(i)

    if not st:
        result = n
    else:
        right, left = n, 0
        while st:
            left = st.pop()
            result = max(result, right - left - 1)
            right = left
        result = max(result, right)

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def longest_valid_parentheses(s: str) -> int:
    n = len(s)
    result = 0
    st = []

    for i in range(n):
        if s[i] == '(':
            st.append(i)
        else:
            if st and s[st[-1]] == '(':
                st.pop()
            else:
                st.append(i)

    if not st:
        result = n
    else:
        right, left = n, 0
        while st:
            left = st.pop()
            result = max(result, right - left - 1)
            right = left
        result = max(result, right)

    return result
```

"
"```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

"
"```python
def searchRange(nums, target):
    start, end = -1, -1
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            if nums[mid] == target:
                start = mid

    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] > target:right = mid - 1
        else:
            left = mid + 1
            if nums[mid] == target:
                end = mid
    
    return [start, end]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def searchRange(nums, target):
    start, end = -1, -1
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            if nums[mid] == target:
                start = mid

    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] > target:right = mid - 1
        else:
            left = mid + 1
            if nums[mid] == target:
                end = mid
    
    return [start, end]
```

"
"```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left
```

"
"```python
def isValidSudoku(board):
    seen = set()

    for i in range(9):
        for j in range(9):
            current_val = board[i][j]
            
            if current_val != '.':
                row = f""{current_val} in row {i}""
                col = f""{current_val} in col {j}""
                box = f""{current_val} in box {i // 3}-{j // 3}""
                
                if row in seen or col in seen or box in seen:
                    return False

                seen.add(row)
                seen.add(col)
                seen.add(box)

    return True
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def isValidSudoku(board):
    seen = set()

    for i in range(9):
        for j in range(9):
            current_val = board[i][j]
            
            if current_val != '.':
                row = f""{current_val} in row {i}""
                col = f""{current_val} in col {j}""
                box = f""{current_val} in box {i // 3}-{j // 3}""
                
                if row in seen or col in seen or box in seen:
                    return False

                seen.add(row)
                seen.add(col)
                seen.add(box)

    return True
```


"
"```python
def isValid(board, row, col, c):
    for i in range(9):
        if board[i][col] == c:
            return False
        if board[row][i] == c:
            return False
        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:
            return False
    return True

def solveSudokuHelper(board):
    for i in range(9):
        for j in range(9):
            if board[i][j] == '.':
                for c in '123456789':
                    if isValid(board, i, j, c):
                        board[i][j] = c

                        if solveSudokuHelper(board):
                            return True

                        board[i][j] = '.'
                return False

    return True

def solveSudoku(board):
    solveSudokuHelper(board)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def isValid(board, row, col, c):
    for i in range(9):
        if board[i][col] == c:
            return False
        if board[row][i] == c:
            return False
        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:
            return False
    return True

def solveSudokuHelper(board):
    for i in range(9):
        for j in range(9):
            if board[i][j] == '.':
                for c in '123456789':
                    if isValid(board, i, j, c):
                        board[i][j] = c

                        if solveSudokuHelper(board):
                            return True

                        board[i][j] = '.'
                return False

    return True

def solveSudoku(board):
    solveSudokuHelper(board)
```

"
"```python
def count_and_say(n):
    if n == 1:
        return ""1""
    previous = count_and_say(n - 1)
    result = []
    count = 1
    for i in range(1, len(previous)):
        if previous[i] == previous[i - 1]:
            count += 1
        else:
            result.append(str(count))
            result.append(previous[i - 1])
            count = 1
    result.append(str(count))
    result.append(previous[-1])
    return """".join(result)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def count_and_say(n):
    if n == 1:
        return ""1""
    previous = count_and_say(n - 1)
    result = []
    count = 1
    for i in range(1, len(previous)):
        if previous[i] == previous[i - 1]:
            count += 1
        else:
            result.append(str(count))
            result.append(previous[i - 1])
            count = 1
    result.append(str(count))
    result.append(previous[-1])
    return """".join(result)
```

"
"```python
def combinationSum(candidates, target):
    def findCombinations(startIndex, remaining):
        if remaining == 0:
            return [[]]
        if startIndex == len(candidates) or remaining < 0:
            return []

        result = []
        result.extend(findCombinations(startIndex + 1, remaining))
        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])
        
        return result

    return findCombinations(0, target)
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def combinationSum(candidates, target):
    def findCombinations(startIndex, remaining):
        if remaining == 0:
            return [[]]
        if startIndex == len(candidates) or remaining < 0:
            return []

        result = []
        result.extend(findCombinations(startIndex + 1, remaining))
        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])
        
        return result

    return findCombinations(0, target)
```


"
"```python
def combinationSum2(candidates, target):
    def combine(candidates, target, start, path, res):
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)

    candidates.sort()
    res = []
    combine(candidates, target, 0, [], res)
    return res
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def combinationSum2(candidates, target):
    def combine(candidates, target, start, path, res):
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)

    candidates.sort()
    res = []
    combine(candidates, target, 0, [], res)
    return res
```


"
"```python
def firstMissingPositive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def firstMissingPositive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1
```

"
"```python
def trap(height):
    n = len(height)
    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0

    while left < right:
        if height[left] <= height[right]:
            max_left = max(max_left, height[left])
            water += max_left - height[left]
            left += 1
        else:
            max_right = max(max_right, height[right])
            water += max_right - height[right]
            right -= 1

    return water
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def trap(height):
    n = len(height)
    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0

    while left < right:
        if height[left] <= height[right]:
            max_left = max(max_left, height[left])
            water += max_left - height[left]
            left += 1
        else:
            max_right = max(max_right, height[right])
            water += max_right - height[right]
            right -= 1

    return water
```

"
"```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    pos = [0] * (m + n)
    
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            p1, p2 = i + j, i + j + 1
            total_pos = mult + pos[p2]
            pos[p1] += total_pos // 10
            pos[p2] = total_pos % 10
            
    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            
    return '0' if len(res) == 0 else res
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    pos = [0] * (m + n)
    
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            p1, p2 = i + j, i + j + 1
            total_pos = mult + pos[p2]
            pos[p1] += total_pos // 10
            pos[p2] = total_pos % 10
            
    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            
    return '0' if len(res) == 0 else res
```

"
"```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    i = j = 0
    match = asterisk = -1
    while i < m:
        if j < n and (s[i] == p[j] or p[j] == '?'):
            i, j = i + 1, j + 1
        elif j < n and p[j] == '*':
            match, asterisk = i, j
            j += 1
        elif asterisk >= 0:
            i, j = match + 1, asterisk + 1
            match += 1
        else:
            return False
    while j < n and p[j] == '*':
        j += 1
    return j == n
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    i = j = 0
    match = asterisk = -1
    while i < m:
        if j < n and (s[i] == p[j] or p[j] == '?'):
            i, j = i + 1, j + 1
        elif j < n and p[j] == '*':
            match, asterisk = i, j
            j += 1
        elif asterisk >= 0:
            i, j = match + 1, asterisk + 1
            match += 1
        else:
            return False
    while j < n and p[j] == '*':
        j += 1
    return j == n
```

"
"```python
def jump(nums):
    jumps = 0
    current_end = 0
    current_farthest = 0

    for i in range(len(nums) - 1):
        current_farthest = max(current_farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = current_farthest

    return jumps
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def jump(nums):
    jumps = 0
    current_end = 0
    current_farthest = 0

    for i in range(len(nums) - 1):
        current_farthest = max(current_farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = current_farthest

    return jumps
```

"
"```python
from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    def helper(index):
        if index == len(nums) - 1:
            results.append(nums[:])
            return

        for i in range(index, len(nums)):
            nums[index], nums[i] = nums[i], nums[index]
            helper(index + 1)
            nums[index], nums[i] = nums[i], nums[index]

    results = []
    helper(0)
    return results
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    def helper(index):
        if index == len(nums) - 1:
            results.append(nums[:])
            return

        for i in range(index, len(nums)):
            nums[index], nums[i] = nums[i], nums[index]
            helper(index + 1)
            nums[index], nums[i] = nums[i], nums[index]

    results = []
    helper(0)
    return results
```

"
"```python
from typing import List

def permuteUnique(nums: List[int]) -> List[List[int]]:
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[start]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    nums.sort()
    result = []
    backtrack(0)
    return result
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from typing import List

def permuteUnique(nums: List[int]) -> List[List[int]]:
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[start]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    nums.sort()
    result = []
    backtrack(0)
    return result
```


"
"```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

"
"```python
from collections import defaultdict

def group_anagrams(strs):
    anagram_map = defaultdict(list)

    for s in strs:
        key = ''.join(sorted(s))
        anagram_map[key].append(s)

    return list(anagram_map.values())
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from collections import defaultdict

def group_anagrams(strs):
    anagram_map = defaultdict(list)

    for s in strs:
        key = ''.join(sorted(s))
        anagram_map[key].append(s)

    return list(anagram_map.values())
```

"
"```python
def myPow(x: float, n: int) -> float:
    if n == 0:
        return 1
    if n < 0:
        x = 1 / x
        n = -n
    result = 1
    currentProduct = x
    i = n
    while i:
        if i % 2 == 1:
            result *= currentProduct
        currentProduct *= currentProduct
        i //= 2
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def myPow(x: float, n: int) -> float:
    if n == 0:
        return 1
    if n < 0:
        x = 1 / x
        n = -n
    result = 1
    currentProduct = x
    i = n
    while i:
        if i % 2 == 1:
            result *= currentProduct
        currentProduct *= currentProduct
        i //= 2
    return result
```

"
"```python
def solveNQueens(n):
    def isSafe(board, row, col):
        for i in range(col):
            if board[row][i] == 'Q': return False
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i - 1, j - 1
        i, j = row, col
        while i < n and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i + 1, j - 1
        return True

    def solve(result, board, n, col):
        if col == n:
            result.append(board.copy())
            return
        for row in range(n):
            if isSafe(board, row, col):
                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]
                solve(result, board, n, col + 1)
                board[row] = board[row][:col] + '.' + board[row][col + 1:]

    result, board = [], ['.' * n for _ in range(n)]
    solve(result, board, n, 0)
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def solveNQueens(n):
    def isSafe(board, row, col):
        for i in range(col):
            if board[row][i] == 'Q': return False
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i - 1, j - 1
        i, j = row, col
        while i < n and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i + 1, j - 1
        return True

    def solve(result, board, n, col):
        if col == n:
            result.append(board.copy())
            return
        for row in range(n):
            if isSafe(board, row, col):
                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]
                solve(result, board, n, col + 1)
                board[row] = board[row][:col] + '.' + board[row][col + 1:]

    result, board = [], ['.' * n for _ in range(n)]
    solve(result, board, n, 0)
    return result
```

"
"```python
def is_safe(cols, row):
    col = len(cols)
    for i, r in enumerate(cols):
        if r == row or abs(i - col) == abs(r - row):
            return False
    return True


def backtrack(n, cols):
    if len(cols) == n:
        return 1

    count = 0
    for i in range(n):
        if is_safe(cols, i):
            cols.append(i)
            count += backtrack(n, cols)
            cols.pop()

    return count


def total_n_queens(n):
    cols = []
    return backtrack(n, cols)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def is_safe(cols, row):
    col = len(cols)
    for i, r in enumerate(cols):
        if r == row or abs(i - col) == abs(r - row):
            return False
    return True


def backtrack(n, cols):
    if len(cols) == n:
        return 1

    count = 0
    for i in range(n):
        if is_safe(cols, i):
            cols.append(i)
            count += backtrack(n, cols)
            cols.pop()

    return count


def total_n_queens(n):
    cols = []
    return backtrack(n, cols)
```

"
"```python
def maxSubArray(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def maxSubArray(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum
```

"
"```python
def spiralOrder(matrix):
    result = []
    if not matrix: return result
    m, n = len(matrix), len(matrix[0])
    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1

    while rowStart <= rowEnd and colStart <= colEnd:
        for i in range(colStart, colEnd + 1): 
            result.append(matrix[rowStart][i])
        rowStart += 1
        
        for i in range(rowStart, rowEnd + 1): 
            result.append(matrix[i][colEnd]) 
        colEnd -= 1
        
        if rowStart <= rowEnd:
            for i in range(colEnd, colStart - 1, -1): 
                result.append(matrix[rowEnd][i]) 
        rowEnd -= 1
        
        if colStart <= colEnd:
            for i in range(rowEnd, rowStart - 1, -1): 
                result.append(matrix[i][colStart]) 
        colStart += 1
        
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def spiralOrder(matrix):
    result = []
    if not matrix: return result
    m, n = len(matrix), len(matrix[0])
    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1

    while rowStart <= rowEnd and colStart <= colEnd:
        for i in range(colStart, colEnd + 1): 
            result.append(matrix[rowStart][i])
        rowStart += 1
        
        for i in range(rowStart, rowEnd + 1): 
            result.append(matrix[i][colEnd]) 
        colEnd -= 1
        
        if rowStart <= rowEnd:
            for i in range(colEnd, colStart - 1, -1): 
                result.append(matrix[rowEnd][i]) 
        rowEnd -= 1
        
        if colStart <= colEnd:
            for i in range(rowEnd, rowStart - 1, -1): 
                result.append(matrix[i][colStart]) 
        colStart += 1
        
    return result
```

"
"```python
def canJump(nums):
    max_reach = 0
    for i, num in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + num)
    return True
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def canJump(nums):
    max_reach = 0
    for i, num in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + num)
    return True
```

"
"```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort()
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort()
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result
```

"
"```python
from typing import List

def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    result = []
    start_pos = 0

    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:
        result.append(intervals[start_pos])
        start_pos += 1

    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[start_pos][0])
        newInterval[1] = max(newInterval[1], intervals[start_pos][1])
        start_pos += 1

    result.append(newInterval)

    while start_pos < len(intervals):
        result.append(intervals[start_pos])
        start_pos += 1

    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from typing import List

def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    result = []
    start_pos = 0

    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:
        result.append(intervals[start_pos])
        start_pos += 1

    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[start_pos][0])
        newInterval[1] = max(newInterval[1], intervals[start_pos][1])
        start_pos += 1

    result.append(newInterval)

    while start_pos < len(intervals):
        result.append(intervals[start_pos])
        start_pos += 1

    return result
```

"
"```python
def length_of_last_word(s: str) -> int:
    length = 0
    tail = len(s) - 1
    while tail >= 0 and s[tail] == ' ':
        tail -= 1
    while tail >= 0 and s[tail] != ' ':
        length += 1
        tail -= 1
    return length
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def length_of_last_word(s: str) -> int:
    length = 0
    tail = len(s) - 1
    while tail >= 0 and s[tail] == ' ':
        tail -= 1
    while tail >= 0 and s[tail] != ' ':
        length += 1
        tail -= 1
    return length
```

"
"```python
def generateMatrix(n: int) -> List[List[int]]:
    matrix = [[0] * n for _ in range(n)]
    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1

    while value <= n * n:
        for i in range(left, right + 1):
            matrix[top][i] = value
            value += 1

        for i in range(top + 1, bottom + 1):
            matrix[i][right] = value
            value += 1

        if top < bottom and left < right:
            for i in range(right - 1, left - 1, -1):
                matrix[bottom][i] = value
                value += 1

            for i in range(bottom - 1, top, -1):
                matrix[i][left] = value
                value += 1

        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1

    return matrix
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def generateMatrix(n: int) -> List[List[int]]:
    matrix = [[0] * n for _ in range(n)]
    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1

    while value <= n * n:
        for i in range(left, right + 1):
            matrix[top][i] = value
            value += 1

        for i in range(top + 1, bottom + 1):
            matrix[i][right] = value
            value += 1

        if top < bottom and left < right:
            for i in range(right - 1, left - 1, -1):
                matrix[bottom][i] = value
                value += 1

            for i in range(bottom - 1, top, -1):
                matrix[i][left] = value
                value += 1

        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1

    return matrix
```

"
"```python
def getPermutation(n, k):
    factorials = [1]
    nums = list(range(1, n + 1))
    result = []

    for i in range(1, n):
        factorials.append(factorials[-1] * i)

    k -= 1

    for i in range(n, 0, -1):
        index = k // factorials[i - 1]
        k %= factorials[i - 1]
        result.append(str(nums.pop(index)))

    return ''.join(result)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def getPermutation(n, k):
    factorials = [1]
    nums = list(range(1, n + 1))
    result = []

    for i in range(1, n):
        factorials.append(factorials[-1] * i)

    k -= 1

    for i in range(n, 0, -1):
        index = k // factorials[i - 1]
        k %= factorials[i - 1]
        result.append(str(nums.pop(index)))

    return ''.join(result)
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rotateRight(head, k):
    if not head or not head.next or k == 0:
        return head

    current = head
    length = 1
    while current.next:
        length += 1
        current = current.next
    current.next = head
    k = length - k % length

    while k:
        k -= 1
        current = current.next
    head = current.next
    current.next = None

    return head
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rotateRight(head, k):
    if not head or not head.next or k == 0:
        return head

    current = head
    length = 1
    while current.next:
        length += 1
        current = current.next
    current.next = head
    k = length - k % length

    while k:
        k -= 1
        current = current.next
    head = current.next
    current.next = None

    return head
```

"
"```python
def uniquePaths(m, n):
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def uniquePaths(m, n):
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]
```

"
"```python
def uniquePathsWithObstacles(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1:
        return 0

    grid[0][0] = 1
    for i in range(1, m):
        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0
    for i in range(1, n):
        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0

    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] == 0:
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]
            else:
                grid[i][j] = 0

    return grid[m - 1][n - 1]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def uniquePathsWithObstacles(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1:
        return 0

    grid[0][0] = 1
    for i in range(1, m):
        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0
    for i in range(1, n):
        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0

    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] == 0:
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]
            else:
                grid[i][j] = 0

    return grid[m - 1][n - 1]
```

"
"```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])

    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]

    for i in range(1, n):
        grid[0][i] += grid[0][i - 1]

    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])

    return grid[m - 1][n - 1]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])

    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]

    for i in range(1, n):
        grid[0][i] += grid[0][i - 1]

    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])

    return grid[m - 1][n - 1]
```

"
"```python
import re

def is_number(s: str) -> bool:
    pattern = re.compile(r'^[-+]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[-+]?[0-9]+)?$')
    return bool(pattern.match(s))
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
import re

def is_number(s: str) -> bool:
    pattern = re.compile(r'^[-+]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[-+]?[0-9]+)?$')
    return bool(pattern.match(s))
```


"
"```python
def plusOne(digits: List[int]) -> List[int]:
    n = len(digits)

    for i in range(n - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0

    digits.insert(0, 1)
    return digits
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def plusOne(digits: List[int]) -> List[int]:
    n = len(digits)

    for i in range(n - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0

    digits.insert(0, 1)
    return digits
```


"
"```python
def addBinary(a: str, b: str) -> str:
    result, carry, i, j = """", 0, len(a) - 1, len(b) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0:
            carry += int(a[i])
            i -= 1
        if j >= 0:
            carry += int(b[j])
            j -= 1
        result = str(carry % 2) + result
        carry //= 2
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def addBinary(a: str, b: str) -> str:
    result, carry, i, j = """", 0, len(a) - 1, len(b) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0:
            carry += int(a[i])
            i -= 1
        if j >= 0:
            carry += int(b[j])
            j -= 1
        result = str(carry % 2) + result
        carry //= 2
    return result
```

"
"```python
def fullJustify(words, maxWidth):
    result = []
    idx = 0
    while idx < len(words):
        total_chars = len(words[idx])
        last = idx + 1
        while last < len(words):
            if total_chars + 1 + len(words[last]) > maxWidth:
                break
            total_chars += 1 + len(words[last])
            last += 1
        gaps = last - idx - 1
        line = []
        if last == len(words) or gaps == 0:
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "")
            while sum(len(w) for w in line) < maxWidth:
                line.append("" "")
        else:
            even_spaces = (maxWidth - total_chars) // gaps
            extra_spaces = (maxWidth - total_chars) % gaps
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "" * (even_spaces + (1 if i - idx < extra_spaces else 0)))
        idx = last
        result.append("""".join(line))
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def fullJustify(words, maxWidth):
    result = []
    idx = 0
    while idx < len(words):
        total_chars = len(words[idx])
        last = idx + 1
        while last < len(words):
            if total_chars + 1 + len(words[last]) > maxWidth:
                break
            total_chars += 1 + len(words[last])
            last += 1
        gaps = last - idx - 1
        line = []
        if last == len(words) or gaps == 0:
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "")
            while sum(len(w) for w in line) < maxWidth:
                line.append("" "")
        else:
            even_spaces = (maxWidth - total_chars) // gaps
            extra_spaces = (maxWidth - total_chars) % gaps
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "" * (even_spaces + (1 if i - idx < extra_spaces else 0)))
        idx = last
        result.append("""".join(line))
    return result
```

"
"```python
def mySqrt(x):
    if x == 0 or x == 1:
        return x
    start, end, ans = 1, x, 0
    while start <= end:
        mid = (start + end) // 2
        if mid * mid == x:
            return mid
        if mid * mid < x:
            start = mid + 1
            ans = mid
        else:
            end = mid - 1
    return ans
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def mySqrt(x):
    if x == 0 or x == 1:
        return x
    start, end, ans = 1, x, 0
    while start <= end:
        mid = (start + end) // 2
        if mid * mid == x:
            return mid
        if mid * mid < x:
            start = mid + 1
            ans = mid
        else:
            end = mid - 1
    return ans
```

"
"```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
```


"
"```python
def simplifyPath(path: str) -> str:
    stack = []
    parts = path.split(""/"")

    for part in parts:
        if not part or part == ""."":
            continue
        if part == "".."":
            if stack:
                stack.pop()
        else:
            stack.append(part)

    return ""/"" + ""/"".join(stack)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def simplifyPath(path: str) -> str:
    stack = []
    parts = path.split(""/"")

    for part in parts:
        if not part or part == ""."":
            continue
        if part == "".."":
            if stack:
                stack.pop()
        else:
            stack.append(part)

    return ""/"" + ""/"".join(stack)
```

"
"```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    
    return dp[m][n]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    
    return dp[m][n]
```

"
"```python
def setZeroes(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    firstRow, firstCol = False, False

    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 0:
                if i == 0: firstRow = True
                if j == 0: firstCol = True
                matrix[i][0] = 0
                matrix[0][j] = 0

    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    if firstRow:
        for j in range(cols):
            matrix[0][j] = 0

    if firstCol:
        for i in range(rows):
            matrix[i][0] = 0
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def setZeroes(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    firstRow, firstCol = False, False

    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 0:
                if i == 0: firstRow = True
                if j == 0: firstCol = True
                matrix[i][0] = 0
                matrix[0][j] = 0

    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    if firstRow:
        for j in range(cols):
            matrix[0][j] = 0

    if firstCol:
        for i in range(rows):
            matrix[i][0] = 0
```

"
"```python
def searchMatrix(matrix, target):
    m, n = len(matrix), len(matrix[0])
    l, r = 0, m * n - 1

    while l <= r:
        mid = l + (r - l) // 2
        mid_val = matrix[mid // n][mid % n]

        if mid_val == target:
            return True
        elif mid_val < target:
            l = mid + 1
        else:
            r = mid - 1

    return False
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def searchMatrix(matrix, target):
    m, n = len(matrix), len(matrix[0])
    l, r = 0, m * n - 1

    while l <= r:
        mid = l + (r - l) // 2
        mid_val = matrix[mid // n][mid % n]

        if mid_val == target:
            return True
        elif mid_val < target:
            l = mid + 1
        else:
            r = mid - 1

    return False
```

"
"```python
def sortColors(nums: List[int]) -> None:
    red, white, blue = 0, 0, len(nums) - 1
    while white <= blue:
        if nums[white] == 0:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] == 1:
            white += 1
        else:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def sortColors(nums: List[int]) -> None:
    red, white, blue = 0, 0, len(nums) - 1
    while white <= blue:
        if nums[white] == 0:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] == 1:
            white += 1
        else:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1
```

"
"```python
from collections import Counter

def min_window(s, t):
    need = Counter(t)
    window = {}
    
    left = 0
    right = 0
    valid = 0
    start = 0
    length = float('inf')

    while right < len(s):
        c = s[right]
        right += 1
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] <= need[c]:
                valid += 1

        while valid == len(t):
            if right - left < length:
                start = left
                length = right - left

            d = s[left]
            left += 1
            if d in need:
                if window[d] <= need[d]:
                    valid -= 1
                window[d] -= 1

    return """" if length == float('inf') else s[start : start + length]
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from collections import Counter

def min_window(s, t):
    need = Counter(t)
    window = {}
    
    left = 0
    right = 0
    valid = 0
    start = 0
    length = float('inf')

    while right < len(s):
        c = s[right]
        right += 1
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] <= need[c]:
                valid += 1

        while valid == len(t):
            if right - left < length:
                start = left
                length = right - left

            d = s[left]
            left += 1
            if d in need:
                if window[d] <= need[d]:
                    valid -= 1
                window[d] -= 1

    return """" if length == float('inf') else s[start : start + length]
```


"
"```python
from typing import List

def combine(n: int, k: int) -> List[List[int]]:
    def backtrack(start, current_combination):
        if len(current_combination) == k:
            result.append(current_combination[:])

        for i in range(start, n + 1):
            current_combination.append(i)
            backtrack(i + 1, current_combination)
            current_combination.pop()

    result = []
    backtrack(1, [])
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from typing import List

def combine(n: int, k: int) -> List[List[int]]:
    def backtrack(start, current_combination):
        if len(current_combination) == k:
            result.append(current_combination[:])

        for i in range(start, n + 1):
            current_combination.append(i)
            backtrack(i + 1, current_combination)
            current_combination.pop()

    result = []
    backtrack(1, [])
    return result
```

"
"```python
def subsets(nums):
    n = len(nums)
    num_subsets = 1 << n
    result = []

    for i in range(num_subsets):
        subset = []
        for j in range(n):
            if i & (1 << j):
                subset.append(nums[j])
        result.append(subset)
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def subsets(nums):
    n = len(nums)
    num_subsets = 1 << n
    result = []

    for i in range(num_subsets):
        subset = []
        for j in range(n):
            if i & (1 << j):
                subset.append(nums[j])
        result.append(subset)
    return result
```

"
"```python
def exist(board, word):
    m, n = len(board), len(board[0])

    def dfs(i, j, k):
        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True

        tmp, board[i][j] = board[i][j], '/'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = tmp
        return res

    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def exist(board, word):
    m, n = len(board), len(board[0])

    def dfs(i, j, k):
        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True

        tmp, board[i][j] = board[i][j], '/'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = tmp
        return res

    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```


"
"```python
def remove_duplicates(nums):
    i = 0
    for num in nums:
        if i < 2 or num > nums[i - 2]:
            nums[i] = num
            i += 1
    return i
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def remove_duplicates(nums):
    i = 0
    for num in nums:
        if i < 2 or num > nums[i - 2]:
            nums[i] = num
            i += 1
    return i
```

"
"```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return True

        if nums[mid] == nums[left]:
            left += 1
        elif nums[mid] > nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return False
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return True

        if nums[mid] == nums[left]:
            left += 1
        elif nums[mid] > nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return False
```

"
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def deleteDuplicates(head):
    dummy = ListNode(0)
    dummy.next = head
    prev, curr = dummy, head
    while curr:
        while curr.next and curr.val == curr.next.val:
            curr = curr.next
        if prev.next == curr:
            prev = prev.next
        else:
            prev.next = curr.next
        curr = curr.next
    return dummy.next
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def deleteDuplicates(head):
    dummy = ListNode(0)
    dummy.next = head
    prev, curr = dummy, head
    while curr:
        while curr.next and curr.val == curr.next.val:
            curr = curr.next
        if prev.next == curr:
            prev = prev.next
        else:
            prev.next = curr.next
        curr = curr.next
    return dummy.next
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_duplicates(head):
    current = head
    while current and current.next:
        if current.next.val == current.val:
            current.next = current.next.next
        else:
            current = current.next
    return head
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_duplicates(head):
    current = head
    while current and current.next:
        if current.next.val == current.val:
            current.next = current.next.next
        else:
            current = current.next
    return head
```

"
"```python
def largestRectangleArea(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def largestRectangleArea(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area
```

"
"```python
def maximalRectangle(matrix):
    if not matrix:
        return 0

    m = len(matrix)
    n = len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0

    for i in range(m):
        s = []
        for j in range(n + 1):
            if j < n:
                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0
            while s and height[j] < height[s[-1]]:
                h = height[s.pop()]
                w = j if not s else j - s[-1] - 1
                max_area = max(max_area, h * w)
            s.append(j)

    return max_area
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def maximalRectangle(matrix):
    if not matrix:
        return 0

    m = len(matrix)
    n = len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0

    for i in range(m):
        s = []
        for j in range(n + 1):
            if j < n:
                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0
            while s and height[j] < height[s[-1]]:
                h = height[s.pop()]
                w = j if not s else j - s[-1] - 1
                max_area = max(max_area, h * w)
            s.append(j)

    return max_area
```


"
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def partition(head, x):
    less_head = ListNode(0)
    more_head = ListNode(0)
    less_ptr, more_ptr = less_head, more_head
    
    while head:
        if head.val < x:
            less_ptr.next = head
            less_ptr = head
        else:
            more_ptr.next = head
            more_ptr = head
        head = head.next
    
    less_ptr.next = more_head.next
    more_ptr.next = None
    
    return less_head.next
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def partition(head, x):
    less_head = ListNode(0)
    more_head = ListNode(0)
    less_ptr, more_ptr = less_head, more_head
    
    while head:
        if head.val < x:
            less_ptr.next = head
            less_ptr = head
        else:
            more_ptr.next = head
            more_ptr = head
        head = head.next
    
    less_ptr.next = more_head.next
    more_ptr.next = None
    
    return less_head.next
```

"
"```python
def isScramble(s1: str, s2: str) -> bool:
    if s1 == s2:
        return True
    if len(s1) != len(s2) or sorted(s1) != sorted(s2):
        return False

    for i in range(1, len(s1)):
        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \
           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):
            return True
    return False
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def isScramble(s1: str, s2: str) -> bool:
    if s1 == s2:
        return True
    if len(s1) != len(s2) or sorted(s1) != sorted(s2):
        return False

    for i in range(1, len(s1)):
        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \
           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):
            return True
    return False
```

"
"```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1
```

"
"```python
def grayCode(n):
    result = []
    for i in range(1 << n):
        result.append(i ^ (i >> 1))
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def grayCode(n):
    result = []
    for i in range(1 << n):
        result.append(i ^ (i >> 1))
    return result
```

"
"```python
from itertools import combinations

def subsetsWithDup(nums):
    result = set()
    nums.sort()
    for i in range(len(nums) + 1):
        for combo in combinations(nums, i):
            result.add(combo)
    return list(result)
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
from itertools import combinations

def subsetsWithDup(nums):
    result = set()
    nums.sort()
    for i in range(len(nums) + 1):
        for combo in combinations(nums, i):
            result.add(combo)
    return list(result)
```

"
"```python
def numDecodings(s: str) -> int:
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1 if s[0] != '0' else 0

    for i in range(2, n + 1):
        one_digit = int(s[i - 1:i])
        two_digits = int(s[i - 2:i])

        if one_digit >= 1:
            dp[i] += dp[i - 1]
        if two_digits >= 10 and two_digits <= 26:
            dp[i] += dp[i - 2]
    return dp[n]
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def numDecodings(s: str) -> int:
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1 if s[0] != '0' else 0

    for i in range(2, n + 1):
        one_digit = int(s[i - 1:i])
        two_digits = int(s[i - 2:i])

        if one_digit >= 1:
            dp[i] += dp[i - 1]
        if two_digits >= 10 and two_digits <= 26:
            dp[i] += dp[i - 2]
    return dp[n]
```


"
"```python
def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
    if not head or left == right:
        return head
    dummy = ListNode(0)
    dummy.next = head
    pre = dummy
    for _ in range(left - 1):
        pre = pre.next
    cur = pre.next
    for _ in range(left, right):
        t = cur.next
        cur.next = t.next
        t.next = pre.next
        pre.next = t
    return dummy.next
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
    if not head or left == right:
        return head
    dummy = ListNode(0)
    dummy.next = head
    pre = dummy
    for _ in range(left - 1):
        pre = pre.next
    cur = pre.next
    for _ in range(left, right):
        t = cur.next
        cur.next = t.next
        t.next = pre.next
        pre.next = t
    return dummy.next
```

"
"```python
def restore_ip_addresses(s):
    def dfs(s, start, ip, result, part):
        if part == 4 and start == len(s):
            result.append(ip[:-1])
            return
        if part == 4 or start >= len(s):
            return

        num = 0
        for i in range(start, len(s)):
            num = num * 10 + int(s[i])
            if num > 255:
                break
            dfs(s, i + 1, ip + s[i] + ""."", result, part + 1)
            if num == 0:
                break

    result = []
    dfs(s, 0, """", result, 0)
    return result
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def restore_ip_addresses(s):
    def dfs(s, start, ip, result, part):
        if part == 4 and start == len(s):
            result.append(ip[:-1])
            return
        if part == 4 or start >= len(s):
            return

        num = 0
        for i in range(start, len(s)):
            num = num * 10 + int(s[i])
            if num > 255:
                break
            dfs(s, i + 1, ip + s[i] + ""."", result, part + 1)
            if num == 0:
                break

    result = []
    dfs(s, 0, """", result, 0)
    return result
```


"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversalHelper(root, result):
    if not root:
        return
    inorderTraversalHelper(root.left, result)
    result.append(root.val)
    inorderTraversalHelper(root.right, result)

def inorderTraversal(root):
    result = []
    inorderTraversalHelper(root, result)
    return result
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversalHelper(root, result):
    if not root:
        return
    inorderTraversalHelper(root.left, result)
    result.append(root.val)
    inorderTraversalHelper(root.right, result)

def inorderTraversal(root):
    result = []
    inorderTraversalHelper(root, result)
    return result
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def generate_trees(start, end):
    trees = []
    if start > end:
        trees.append(None)
        return trees

    for i in range(start, end + 1):
        left_subtrees = generate_trees(start, i - 1)
        right_subtrees = generate_trees(i + 1, end)

        for left in left_subtrees:
            for right in right_subtrees:
                new_node = TreeNode(i)
                new_node.left = left
                new_node.right = right
                trees.append(new_node)

    return trees

def generate_trees(n):
    if n == 0:
        return []
    return generate_trees(1, n)
```


","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def generate_trees(start, end):
    trees = []
    if start > end:
        trees.append(None)
        return trees

    for i in range(start, end + 1):
        left_subtrees = generate_trees(start, i - 1)
        right_subtrees = generate_trees(i + 1, end)

        for left in left_subtrees:
            for right in right_subtrees:
                new_node = TreeNode(i)
                new_node.left = left
                new_node.right = right
                trees.append(new_node)

    return trees

def generate_trees(n):
    if n == 0:
        return []
    return generate_trees(1, n)
```


"
"```python
def numTrees(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def numTrees(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]
```

"
"```python
def isInterleave(s1, s2, s3):
    m, n = len(s1), len(s2)
    if m + n != len(s3):
        return False

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for i in range(1, m + 1):
        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \
                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def isInterleave(s1, s2, s3):
    m, n = len(s1), len(s2)
    if m + n != len(s3):
        return False

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for i in range(1, m + 1):
        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \
                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBSTHelper(node, min_val, max_val):
    if node is None:
        return True
    if not min_val < node.val < max_val:
        return False
    return (isValidBSTHelper(node.left, min_val, node.val) and
            isValidBSTHelper(node.right, node.val, max_val))

def isValidBST(root):
    return isValidBSTHelper(root, float('-inf'), float('inf'))
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBSTHelper(node, min_val, max_val):
    if node is None:
        return True
    if not min_val < node.val < max_val:
        return False
    return (isValidBSTHelper(node.left, min_val, node.val) and
            isValidBSTHelper(node.right, node.val, max_val))

def isValidBST(root):
    return isValidBSTHelper(root, float('-inf'), float('inf'))
```

"
"```python
def inorder(node, nodes):
    if not node: return
    inorder(node.left, nodes)
    if nodes[1] and nodes[1].val > node.val:
        if not nodes[0]: nodes[0] = nodes[1]
        nodes[2] = node
    nodes[1] = node
    inorder(node.right, nodes)

def recoverTree(root):
    nodes = [None, None, None]
    inorder(root, nodes)
    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val
```

","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:","Optimize the following Python code for both memory usage and performance. Please use specific techniques or code changes to make it more efficient. Provide just the code as an answer, I don't need any explanation. Here's the code snippet:```python
def inorder(node, nodes):
    if not node: return
    inorder(node.left, nodes)
    if nodes[1] and nodes[1].val > node.val:
        if not nodes[0]: nodes[0] = nodes[1]
        nodes[2] = node
    nodes[1] = node
    inorder(node.right, nodes)

def recoverTree(root):
    nodes = [None, None, None]
    inorder(root, nodes)
    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_same_tree(p, q):
    if p is None and q is None:
        return True
    if p is None or q is None:
        return False
    if p.val != q.val:
        return False
    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)
```


",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_same_tree(p, q):
    if p is None and q is None:
        return True
    if p is None or q is None:
        return False
    if p.val != q.val:
        return False
    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)
```


"
"```python
def isSymmetric(root):
    return checkSymmetry(root, root)

def checkSymmetry(node1, node2):
    if not node1 and not node2:
        return True
    if not node1 or not node2:
        return False
    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)
```

",,"```python
def isSymmetric(root):
    return checkSymmetry(root, root)

def checkSymmetry(node1, node2):
    if not node1 and not node2:
        return True
    if not node1 or not node2:
        return False
    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right)

            level.append(node.val)

        result.append(level)

    return result
```


",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right)

            level.append(node.val)

        result.append(level)

    return result
```


"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzagLevelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]
    zigzag = False

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if zigzag:
                level.insert(0, node.val)
            else:
                level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)
        zigzag = not zigzag

    return result
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzagLevelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]
    zigzag = False

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if zigzag:
                level.insert(0, node.val)
            else:
                level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)
        zigzag = not zigzag

    return result
```

"
"```python
def maxDepth(root):
    if root is None:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

",,"```python
def maxDepth(root):
    if root is None:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(preorder, inorder):
    def construct_tree(in_left, in_right):
        nonlocal pre_idx
        if in_left > in_right:
            return None

        root_val = preorder[pre_idx]
        root = TreeNode(root_val)
        idx = in_map[root_val]

        pre_idx += 1
        root.left = construct_tree(in_left, idx - 1)
        root.right = construct_tree(idx + 1, in_right)

        return root

    in_map = {val: idx for idx, val in enumerate(inorder)}
    pre_idx = 0
    return construct_tree(0, len(inorder) - 1)
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(preorder, inorder):
    def construct_tree(in_left, in_right):
        nonlocal pre_idx
        if in_left > in_right:
            return None

        root_val = preorder[pre_idx]
        root = TreeNode(root_val)
        idx = in_map[root_val]

        pre_idx += 1
        root.left = construct_tree(in_left, idx - 1)
        root.right = construct_tree(idx + 1, in_right)

        return root

    in_map = {val: idx for idx, val in enumerate(inorder)}
    pre_idx = 0
    return construct_tree(0, len(inorder) - 1)
```

"
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, inorder, postorder):
        def _build(in_left, in_right, post_root):
            if in_left > in_right:
                return None
            
            root = TreeNode(postorder[post_root])

            inorder_root_index = index_map[root.val]
            left_tree_size = inorder_root_index - in_left

            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)
            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)

            return root

        index_map = {val: i for i, val in enumerate(inorder)}
        return _build(0, len(inorder) - 1, len(postorder) - 1)
```

",,"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, inorder, postorder):
        def _build(in_left, in_right, post_root):
            if in_left > in_right:
                return None
            
            root = TreeNode(postorder[post_root])

            inorder_root_index = index_map[root.val]
            left_tree_size = inorder_root_index - in_left

            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)
            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)

            return root

        index_map = {val: i for i, val in enumerate(inorder)}
        return _build(0, len(inorder) - 1, len(postorder) - 1)
```

"
"```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrderBottom(root):
    result = []
    if not root:
        return result

    queue = deque([root])

    while queue:
        level = []
        size = len(queue)

        for i in range(size):
            current = queue.popleft()
            level.append(current.val)

            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

        result.insert(0, level)

    return result
```

",,"```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrderBottom(root):
    result = []
    if not root:
        return result

    queue = deque([root])

    while queue:
        level = []
        size = len(queue)

        for i in range(size):
            current = queue.popleft()
            level.append(current.val)

            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

        result.insert(0, level)

    return result
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sorted_array_to_bst(nums):
    def helper(start, end):
        if start > end:
            return None

        mid = start + (end - start) // 2
        node = TreeNode(nums[mid])
        node.left = helper(start, mid - 1)
        node.right = helper(mid + 1, end)

        return node

    return helper(0, len(nums) - 1)
```


",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sorted_array_to_bst(nums):
    def helper(start, end):
        if start > end:
            return None

        mid = start + (end - start) // 2
        node = TreeNode(nums[mid])
        node.left = helper(start, mid - 1)
        node.right = helper(mid + 1, end)

        return node

    return helper(0, len(nums) - 1)
```


"
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sortedListToBST(head):
    if not head:
        return None
    if not head.next:
        return TreeNode(head.val)
    slow = head
    fast = head
    prev = None

    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next

    prev.next = None

    root = TreeNode(slow.val)
    root.left = sortedListToBST(head)
    root.right = sortedListToBST(slow.next)
    return root
```

",,"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sortedListToBST(head):
    if not head:
        return None
    if not head.next:
        return TreeNode(head.val)
    slow = head
    fast = head
    prev = None

    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next

    prev.next = None

    root = TreeNode(slow.val)
    root.left = sortedListToBST(head)
    root.right = sortedListToBST(slow.next)
    return root
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def getHeight(node):
    if not node:
        return 0
    left_height = getHeight(node.left)
    right_height = getHeight(node.right)
    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
        return -1
    return 1 + max(left_height, right_height)

def isBalanced(root):
    return getHeight(root) != -1
```


",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def getHeight(node):
    if not node:
        return 0
    left_height = getHeight(node.left)
    right_height = getHeight(node.right)
    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
        return -1
    return 1 + max(left_height, right_height)

def isBalanced(root):
    return getHeight(root) != -1
```


"
"```python
def minDepth(root):
    if not root:
        return 0
    left = minDepth(root.left)
    right = minDepth(root.right)
    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1
```

",,"```python
def minDepth(root):
    if not root:
        return 0
    left = minDepth(root.left)
    right = minDepth(root.right)
    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def hasPathSum(root, targetSum):
    if root is None:
        return False
    if root.left is None and root.right is None:
        return targetSum - root.val == 0
    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def hasPathSum(root, targetSum):
    if root is None:
        return False
    if root.left is None and root.right is None:
        return targetSum - root.val == 0
    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def pathSum(root, targetSum):
    def helper(root, targetSum, current, ans):
        if not root:
            return
        current.append(root.val)
        if not root.left and not root.right and targetSum == root.val:
            ans.append(current[:])
        helper(root.left, targetSum - root.val, current, ans)
        helper(root.right, targetSum - root.val, current, ans)
        current.pop()

    ans = []
    helper(root, targetSum, [], ans)
    return ans
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def pathSum(root, targetSum):
    def helper(root, targetSum, current, ans):
        if not root:
            return
        current.append(root.val)
        if not root.left and not root.right and targetSum == root.val:
            ans.append(current[:])
        helper(root.left, targetSum - root.val, current, ans)
        helper(root.right, targetSum - root.val, current, ans)
        current.pop()

    ans = []
    helper(root, targetSum, [], ans)
    return ans
```

"
"```python
def flatten(root):
    if not root:
        return
    flatten(root.left)
    flatten(root.right)
    if root.left:
        temp = root.right
        root.right = root.left
        root.left = None
        while root.right:
            root = root.right
        root.right = temp
```

",,"```python
def flatten(root):
    if not root:
        return
    flatten(root.left)
    flatten(root.right)
    if root.left:
        temp = root.right
        root.right = root.left
        root.left = None
        while root.right:
            root = root.right
        root.right = temp
```

"
"```python
def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = 1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[m][n]
```

",,"```python
def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = 1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[m][n]
```

"
"```python
def connect(self, root: 'Node') -> 'Node':
    if not root or not root.left:
        return root
    root.left.next = root.right
    if root.next:
        root.right.next = root.next.left
    self.connect(root.left)
    self.connect(root.right)
    return root
```


",,"```python
def connect(self, root: 'Node') -> 'Node':
    if not root or not root.left:
        return root
    root.left.next = root.right
    if root.next:
        root.right.next = root.next.left
    self.connect(root.left)
    self.connect(root.right)
    return root
```


"
"```python
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def connect(root: 'Node') -> 'Node':
    if not root:
        return None

    q = [root]

    while q:
        level_size = len(q)
        prev = None

        for i in range(level_size):
            current_node = q.pop(0)

            if prev:
                prev.next = current_node
            prev = current_node

            if current_node.left:
                q.append(current_node.left)
            if current_node.right:
                q.append(current_node.right)

    return root
```


",,"```python
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def connect(root: 'Node') -> 'Node':
    if not root:
        return None

    q = [root]

    while q:
        level_size = len(q)
        prev = None

        for i in range(level_size):
            current_node = q.pop(0)

            if prev:
                prev.next = current_node
            prev = current_node

            if current_node.left:
                q.append(current_node.left)
            if current_node.right:
                q.append(current_node.right)

    return root
```


"
"```python
def generate(numRows):
    pascalsTriangle = []
    for i in range(numRows):
        row = [1]
        if i > 0:
            for j in range(1, i):
                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])
            row.append(1)
        pascalsTriangle.append(row)
    return pascalsTriangle
```

",,"```python
def generate(numRows):
    pascalsTriangle = []
    for i in range(numRows):
        row = [1]
        if i > 0:
            for j in range(1, i):
                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])
            row.append(1)
        pascalsTriangle.append(row)
    return pascalsTriangle
```

"
"```python
def get_row(rowIndex):
    row = [1] * (rowIndex + 1)
    for i in range(1, rowIndex + 1):
        for j in range(i - 1, 0, -1):
            row[j] += row[j - 1]
    return row
```

",,"```python
def get_row(rowIndex):
    row = [1] * (rowIndex + 1)
    for i in range(1, rowIndex + 1):
        for j in range(i - 1, 0, -1):
            row[j] += row[j - 1]
    return row
```

"
"```python
def minimumTotal(triangle):
    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])
    return triangle[0][0]
```

",,"```python
def minimumTotal(triangle):
    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])
    return triangle[0][0]
```

"
"```python
def maxProfit(prices):
    minPrice = float('inf')
    maxProfit = 0
    for price in prices:
        minPrice = min(minPrice, price)
        maxProfit = max(maxProfit, price - minPrice)
    return maxProfit
```

",,"```python
def maxProfit(prices):
    minPrice = float('inf')
    maxProfit = 0
    for price in prices:
        minPrice = min(minPrice, price)
        maxProfit = max(maxProfit, price - minPrice)
    return maxProfit
```

"
"```python
def max_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]
    return max_profit
```

",,"```python
def max_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]
    return max_profit
```

"
"```python
def maxProfit(prices):
    buy1, buy2 = float(""inf""), float(""inf"")
    profit1, profit2 = 0, 0

    for price in prices:
        buy1 = min(buy1, price)
        profit1 = max(profit1, price - buy1)
        buy2 = min(buy2, price - profit1)
        profit2 = max(profit2, price - buy2)

    return profit2
```

",,"```python
def maxProfit(prices):
    buy1, buy2 = float(""inf""), float(""inf"")
    profit1, profit2 = 0, 0

    for price in prices:
        buy1 = min(buy1, price)
        profit1 = max(profit1, price - buy1)
        buy2 = min(buy2, price - profit1)
        profit2 = max(profit2, price - buy2)

    return profit2
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxPathSum(root: TreeNode) -> int:
    def helper(root):
        nonlocal maxSum
        if not root:
            return 0

        left = max(0, helper(root.left))
        right = max(0, helper(root.right))

        maxSum = max(maxSum, left + right + root.val)

        return max(left, right) + root.val

    maxSum = float('-inf')
    helper(root)
    return maxSum
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxPathSum(root: TreeNode) -> int:
    def helper(root):
        nonlocal maxSum
        if not root:
            return 0

        left = max(0, helper(root.left))
        right = max(0, helper(root.right))

        maxSum = max(maxSum, left + right + root.val)

        return max(left, right) + root.val

    maxSum = float('-inf')
    helper(root)
    return maxSum
```

"
"```python
def isPalindrome(s: str) -> bool:
    cleaned = """".join(c.lower() for c in s if c.isalnum())
    left, right = 0, len(cleaned) - 1
    while left < right:
        if cleaned[left] != cleaned[right]:
            return False
        left += 1
        right -= 1
    return True
```

",,"```python
def isPalindrome(s: str) -> bool:
    cleaned = """".join(c.lower() for c in s if c.isalnum())
    left, right = 0, len(cleaned) - 1
    while left < right:
        if cleaned[left] != cleaned[right]:
            return False
        left += 1
        right -= 1
    return True
```

"
"```python
from collections import defaultdict, deque

def findLadders(beginWord, endWord, wordList):
    wordList = set(wordList)
    if endWord not in wordList:
        return []

    adjacent = defaultdict(list)
    distance = defaultdict(int)
    queue = deque([beginWord])
    distance[beginWord] = 0
    
    def neighbors(word):
        for i in range(len(word)):
            for j in range(ord('a'), ord('z') + 1):
                yield word[:i] + chr(j) + word[i + 1:]
                
    while queue:
        current = queue.popleft()
        if current == endWord:
            break
        for neighbor in neighbors(current):
            if neighbor not in wordList:
                continue
            if neighbor not in distance:
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)
            if distance[neighbor] == distance[current] + 1:
                adjacent[current].append(neighbor)

    result = []
    path = [beginWord]

    def backtrack(word):
        if word == endWord:
            result.append(path[:])
        else:
            for next_word in adjacent[word]:
                path.append(next_word)
                backtrack(next_word)
                path.pop()
                
    backtrack(beginWord)
    return result
```


",,"```python
from collections import defaultdict, deque

def findLadders(beginWord, endWord, wordList):
    wordList = set(wordList)
    if endWord not in wordList:
        return []

    adjacent = defaultdict(list)
    distance = defaultdict(int)
    queue = deque([beginWord])
    distance[beginWord] = 0
    
    def neighbors(word):
        for i in range(len(word)):
            for j in range(ord('a'), ord('z') + 1):
                yield word[:i] + chr(j) + word[i + 1:]
                
    while queue:
        current = queue.popleft()
        if current == endWord:
            break
        for neighbor in neighbors(current):
            if neighbor not in wordList:
                continue
            if neighbor not in distance:
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)
            if distance[neighbor] == distance[current] + 1:
                adjacent[current].append(neighbor)

    result = []
    path = [beginWord]

    def backtrack(word):
        if word == endWord:
            result.append(path[:])
        else:
            for next_word in adjacent[word]:
                path.append(next_word)
                backtrack(next_word)
                path.pop()
                
    backtrack(beginWord)
    return result
```


"
"```python
from collections import deque

def ladderLength(beginWord, endWord, wordList):
    word_set = set(wordList)
    if endWord not in word_set:
        return 0

    q = deque([beginWord])
    steps = 1

    while q:
        size = len(q)
        current_level = set()
        
        for _ in range(size):
            current_word = q.popleft()
            if current_word == endWord:
                return steps

            word_chars = list(current_word)
            for i in range(len(word_chars)):
                original_char = word_chars[i]
                for j in range(26):
                    word_chars[i] = chr(ord('a') + j)
                    new_word = ''.join(word_chars)
                    if new_word in word_set:
                        q.append(new_word)
                        current_level.add(new_word)
                        
                word_chars[i] = original_char
        
        word_set -= current_level
        steps += 1
        
    return 0
```

",,"```python
from collections import deque

def ladderLength(beginWord, endWord, wordList):
    word_set = set(wordList)
    if endWord not in word_set:
        return 0

    q = deque([beginWord])
    steps = 1

    while q:
        size = len(q)
        current_level = set()
        
        for _ in range(size):
            current_word = q.popleft()
            if current_word == endWord:
                return steps

            word_chars = list(current_word)
            for i in range(len(word_chars)):
                original_char = word_chars[i]
                for j in range(26):
                    word_chars[i] = chr(ord('a') + j)
                    new_word = ''.join(word_chars)
                    if new_word in word_set:
                        q.append(new_word)
                        current_level.add(new_word)
                        
                word_chars[i] = original_char
        
        word_set -= current_level
        steps += 1
        
    return 0
```

"
"```python
def longest_consecutive(nums):
    elements = set(nums)
    longest_seq = 0

    for num in nums:
        if num - 1 not in elements:
            current_num = num
            current_seq = 1
            
            while current_num + 1 in elements:
                current_num += 1
                current_seq += 1

            longest_seq = max(longest_seq, current_seq)
    
    return longest_seq
```

",,"```python
def longest_consecutive(nums):
    elements = set(nums)
    longest_seq = 0

    for num in nums:
        if num - 1 not in elements:
            current_num = num
            current_seq = 1
            
            while current_num + 1 in elements:
                current_num += 1
                current_seq += 1

            longest_seq = max(longest_seq, current_seq)
    
    return longest_seq
```

"
"```python
def sumNumbers(root, cur=0):
    if root is None: return 0
    cur = cur * 10 + root.val
    if root.left is None and root.right is None: return cur
    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)
```


",,"```python
def sumNumbers(root, cur=0):
    if root is None: return 0
    cur = cur * 10 + root.val
    if root.left is None and root.right is None: return cur
    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)
```


"
"```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        m, n = len(board), len(board[0])

        def dfs(x, y):
            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':
                return
            board[x][y] = '#'
            dfs(x - 1, y)
            dfs(x + 1, y)
            dfs(x, y - 1)
            dfs(x, y + 1)

        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        for i in range(n):
            dfs(0, i)
            dfs(m - 1, i)

        for i in range(m):
            for j in range(n):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                elif board[i][j] == 'O':
                    board[i][j] = 'X'
```

",,"```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        m, n = len(board), len(board[0])

        def dfs(x, y):
            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':
                return
            board[x][y] = '#'
            dfs(x - 1, y)
            dfs(x + 1, y)
            dfs(x, y - 1)
            dfs(x, y + 1)

        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        for i in range(n):
            dfs(0, i)
            dfs(m - 1, i)

        for i in range(m):
            for j in range(n):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                elif board[i][j] == 'O':
                    board[i][j] = 'X'
```

"
"```python
def isPalindrome(s, start, end):
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True

def dfs(s, start, results, current):
    if start == len(s):
        results.append(current[:])
        return
    
    for end in range(start, len(s)):
        if isPalindrome(s, start, end):
            current.append(s[start:end+1])
            dfs(s, end + 1, results, current)
            current.pop()

def partition(s):
    results = []
    dfs(s, 0, results, [])
    return results
```

",,"```python
def isPalindrome(s, start, end):
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True

def dfs(s, start, results, current):
    if start == len(s):
        results.append(current[:])
        return
    
    for end in range(start, len(s)):
        if isPalindrome(s, start, end):
            current.append(s[start:end+1])
            dfs(s, end + 1, results, current)
            current.pop()

def partition(s):
    results = []
    dfs(s, 0, results, [])
    return results
```

"
"```python
def minCut(s):
    n = len(s)
    dp = [i - 1 for i in range(n + 1)]
    is_palindrome = [[False] * n for _ in range(n)]
    
    for j in range(1, n):
        for i in range(j, -1, -1):
            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):
                is_palindrome[i][j] = True
                dp[j + 1] = min(dp[j + 1], dp[i] + 1)
                
    return dp[n]
```

",,"```python
def minCut(s):
    n = len(s)
    dp = [i - 1 for i in range(n + 1)]
    is_palindrome = [[False] * n for _ in range(n)]
    
    for j in range(1, n):
        for i in range(j, -1, -1):
            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):
                is_palindrome[i][j] = True
                dp[j + 1] = min(dp[j + 1], dp[i] + 1)
                
    return dp[n]
```

"
"```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node, visited=None):
    if node is None:
        return None

    if visited is None:
        visited = {}

    if node in visited:
        return visited[node]

    cloneNode = Node(node.val)
    visited[node] = cloneNode

    for neighbor in node.neighbors:
        cloneNode.neighbors.append(cloneGraph(neighbor, visited))

    return cloneNode
```


",,"```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node, visited=None):
    if node is None:
        return None

    if visited is None:
        visited = {}

    if node in visited:
        return visited[node]

    cloneNode = Node(node.val)
    visited[node] = cloneNode

    for neighbor in node.neighbors:
        cloneNode.neighbors.append(cloneGraph(neighbor, visited))

    return cloneNode
```


"
"```python
def can_complete_circuit(gas, cost):
    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0
    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        gas_tank += gas[i] - cost[i]
        if gas_tank < 0:
            start = i + 1
            gas_tank = 0
    return -1 if total_gas < total_cost else start
```

",,"```python
def can_complete_circuit(gas, cost):
    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0
    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        gas_tank += gas[i] - cost[i]
        if gas_tank < 0:
            start = i + 1
            gas_tank = 0
    return -1 if total_gas < total_cost else start
```

"
"```python
def min_candies(ratings):
    n = len(ratings)
    candies = [1] * n

    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1

    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)

    return sum(candies)
```

",,"```python
def min_candies(ratings):
    n = len(ratings)
    candies = [1] * n

    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1

    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)

    return sum(candies)
```

"
"```python
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

",,"```python
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

"
"```python
def singleNumber(nums):
    ones, twos = 0, 0
    for n in nums:
        ones = (ones ^ n) & ~twos
        twos = (twos ^ n) & ~ones
    return ones
```

",,"```python
def singleNumber(nums):
    ones, twos = 0, 0
    for n in nums:
        ones = (ones ^ n) & ~twos
        twos = (twos ^ n) & ~ones
    return ones
```

"
"```python
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random
        
def copyRandomList(head):
    if not head:
        return None

    curr = head
    while curr:
        temp = Node(curr.val)
        temp.next = curr.next
        curr.next = temp
        curr = curr.next.next

    curr = head
    while curr:
        if curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next

    orig = head
    copy = head.next
    copy_head = copy

    while orig and copy:
        orig.next = copy.next
        orig = orig.next
        if orig:
            copy.next = orig.next
            copy = copy.next

    return copy_head
```

",,"```python
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random
        
def copyRandomList(head):
    if not head:
        return None

    curr = head
    while curr:
        temp = Node(curr.val)
        temp.next = curr.next
        curr.next = temp
        curr = curr.next.next

    curr = head
    while curr:
        if curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next

    orig = head
    copy = head.next
    copy_head = copy

    while orig and copy:
        orig.next = copy.next
        orig = orig.next
        if orig:
            copy.next = orig.next
            copy = copy.next

    return copy_head
```

"
"```python
def word_break(s, word_dict):
    word_set = set(word_dict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]
```


",,"```python
def word_break(s, word_dict):
    word_set = set(word_dict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]
```


"
"```python
def word_break(s, word_dict):
    def helper(s, dict, memo):
        if s in memo:
            return memo[s]

        res = []
        if s in dict:
            res.append(s)

        for i in range(1, len(s)):
            prefix = s[:i]
            if prefix not in dict:
                continue
            suffix = s[i:]
            temp = helper(suffix, dict, memo)
            for t in temp:
                res.append(prefix + "" "" + t)

        memo[s] = res
        return res

    word_set = set(word_dict)
    memo = {}
    return helper(s, word_set, memo)
```

",,"```python
def word_break(s, word_dict):
    def helper(s, dict, memo):
        if s in memo:
            return memo[s]

        res = []
        if s in dict:
            res.append(s)

        for i in range(1, len(s)):
            prefix = s[:i]
            if prefix not in dict:
                continue
            suffix = s[i:]
            temp = helper(suffix, dict, memo)
            for t in temp:
                res.append(prefix + "" "" + t)

        memo[s] = res
        return res

    word_set = set(word_dict)
    memo = {}
    return helper(s, word_set, memo)
```

"
"```python
def hasCycle(head):
    slow = fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

",,"```python
def hasCycle(head):
    slow = fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detectCycle(head):
    slow, fast = head, head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            start = head
            while start != slow:
                start = start.next
                slow = slow.next
            return start
    
    return None
```

",,"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detectCycle(head):
    slow, fast = head, head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            start = head
            while start != slow:
                start = start.next
                slow = slow.next
            return start
    
    return None
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reorderList(head):
    if not head or not head.next or not head.next.next:
        return

    # Find the middle node
    slow = head
    fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next

    # Reverse the second half
    prev = None
    curr = slow.next
    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    slow.next = None

    # Merge two halves
    first = head
    second = prev
    while second:
        next = first.next
        first.next = second
        first = second
        second = next
```

",,"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reorderList(head):
    if not head or not head.next or not head.next.next:
        return

    # Find the middle node
    slow = head
    fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next

    # Reverse the second half
    prev = None
    curr = slow.next
    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    slow.next = None

    # Merge two halves
    first = head
    second = prev
    while second:
        next = first.next
        first.next = second
        first = second
        second = next
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root is None:
        return []
        
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root is None:
        return []
        
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def postorderTraversal(root):
    if not root:
        return []

    result = []
    s = [root]
    while s:
        current = s.pop()
        result.insert(0, current.val)
        if current.left:
            s.append(current.left)
        if current.right:
            s.append(current.right)

    return result
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def postorderTraversal(root):
    if not root:
        return []

    result = []
    s = [root]
    while s:
        current = s.pop()
        result.insert(0, current.val)
        if current.left:
            s.append(current.left)
        if current.right:
            s.append(current.right)

    return result
```

"
"```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        value = self.cache.pop(key)
        self.cache[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```


",,"```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        value = self.cache.pop(key)
        self.cache[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```


"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insertionSortList(head):
    dummy = ListNode(0)
    cur = dummy

    while head:
        while cur.next and cur.next.val < head.val:
            cur = cur.next
        
        temp = head.next
        head.next = cur.next
        cur.next = head
        head = temp
        cur = dummy

    return dummy.next
```

",,"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insertionSortList(head):
    dummy = ListNode(0)
    cur = dummy

    while head:
        while cur.next and cur.next.val < head.val:
            cur = cur.next
        
        temp = head.next
        head.next = cur.next
        cur.next = head
        head = temp
        cur = dummy

    return dummy.next
```

"
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def sortList(head):
    if not head or not head.next:
        return head

    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    mid = slow.next
    slow.next = None

    return merge(sortList(head), sortList(mid))

def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left.val < right.val:
        left.next = merge(left.next, right)
        return left
    else:
        right.next = merge(left, right.next)
        return right
```


",,"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def sortList(head):
    if not head or not head.next:
        return head

    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    mid = slow.next
    slow.next = None

    return merge(sortList(head), sortList(mid))

def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left.val < right.val:
        left.next = merge(left.next, right)
        return left
    else:
        right.next = merge(left, right.next)
        return right
```


"
"```python
from math import gcd
from collections import defaultdict

def maxPoints(points):
    n = len(points)
    if n <= 2:
        return n

    max_count = 0

    for i in range(n):
        slope_map = defaultdict(int)
        duplicates = 0
        local_max = 0

        for j in range(i+1, n):
            deltaX = points[j][0] - points[i][0]
            deltaY = points[j][1] - points[i][1]

            if deltaX == 0 and deltaY == 0:
                duplicates += 1
                continue

            g = gcd(deltaX, deltaY)
            deltaX = deltaX // g
            deltaY = deltaY // g

            key = f""{deltaX}_{deltaY}""
            slope_map[key] += 1
            local_max = max(local_max, slope_map[key])

        max_count = max(max_count, local_max + duplicates + 1)

    return max_count
```


",,"```python
from math import gcd
from collections import defaultdict

def maxPoints(points):
    n = len(points)
    if n <= 2:
        return n

    max_count = 0

    for i in range(n):
        slope_map = defaultdict(int)
        duplicates = 0
        local_max = 0

        for j in range(i+1, n):
            deltaX = points[j][0] - points[i][0]
            deltaY = points[j][1] - points[i][1]

            if deltaX == 0 and deltaY == 0:
                duplicates += 1
                continue

            g = gcd(deltaX, deltaY)
            deltaX = deltaX // g
            deltaY = deltaY // g

            key = f""{deltaX}_{deltaY}""
            slope_map[key] += 1
            local_max = max(local_max, slope_map[key])

        max_count = max(max_count, local_max + duplicates + 1)

    return max_count
```


"
"```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in {""+"", ""-"", ""*"", ""/""}:
            b = stack.pop()
            a = stack.pop()
            if token == ""+"":
                stack.append(a + b)
            elif token == ""-"":
                stack.append(a - b)
            elif token == ""*"":
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]
```

",,"```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in {""+"", ""-"", ""*"", ""/""}:
            b = stack.pop()
            a = stack.pop()
            if token == ""+"":
                stack.append(a + b)
            elif token == ""-"":
                stack.append(a - b)
            elif token == ""*"":
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]
```

"
"```python
def reverseWords(s):
    words = s.split()
    words.reverse()
    return ' '.join(words)
```

",,"```python
def reverseWords(s):
    words = s.split()
    words.reverse()
    return ' '.join(words)
```

"
"```python
def maxProduct(nums):
    max_so_far = min_so_far = result = nums[0]
    
    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_so_far, min_so_far = min_so_far, max_so_far
        
        max_so_far = max(nums[i], max_so_far * nums[i])
        min_so_far = min(nums[i], min_so_far * nums[i])
        result = max(result, max_so_far)
    
    return result
```


",,"```python
def maxProduct(nums):
    max_so_far = min_so_far = result = nums[0]
    
    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_so_far, min_so_far = min_so_far, max_so_far
        
        max_so_far = max(nums[i], max_so_far * nums[i])
        min_so_far = min(nums[i], min_so_far * nums[i])
        result = max(result, max_so_far)
    
    return result
```


"
"```python
def find_min(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

",,"```python
def find_min(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

"
"```python
def findMin(nums):
    low, high = 0, len(nums) - 1
    
    while low < high:
        mid = low + (high - low) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        elif nums[mid] < nums[high]:
            high = mid
        else:
            high -= 1
            
    return nums[low]
```

",,"```python
def findMin(nums):
    low, high = 0, len(nums) - 1
    
    while low < high:
        mid = low + (high - low) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        elif nums[mid] < nums[high]:
            high = mid
        else:
            high -= 1
            
    return nums[low]
```

"
"```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []
        
    def push(self, val: int):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
        
    def pop(self):
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

",,"```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []
        
    def push(self, val: int):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
        
    def pop(self):
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

"
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def upside_down_binary_tree(root):
    if not root or not root.left:
        return root
    new_root = upside_down_binary_tree(root.left)
    root.left.right = root
    root.left.left = root.right
    root.left = None
    root.right = None
    return new_root
```

",,"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def upside_down_binary_tree(root):
    if not root or not root.left:
        return root
    new_root = upside_down_binary_tree(root.left)
    root.left.right = root
    root.left.left = root.right
    root.left = None
    root.right = None
    return new_root
```

"
"```python
def read4(buf4: List[str]) -> int:
    pass

def read(buf: List[str], n: int) -> int:
    total_read = 0
    buf4 = [''] * 4

    while total_read < n:
        read4_count = read4(buf4)
        for i in range(read4_count):
            if total_read < n:
                buf[total_read] = buf4[i]
                total_read += 1
            else:
                break
        if read4_count < 4:
            break

    return total_read
```

",,"```python
def read4(buf4: List[str]) -> int:
    pass

def read(buf: List[str], n: int) -> int:
    total_read = 0
    buf4 = [''] * 4

    while total_read < n:
        read4_count = read4(buf4)
        for i in range(read4_count):
            if total_read < n:
                buf[total_read] = buf4[i]
                total_read += 1
            else:
                break
        if read4_count < 4:
            break

    return total_read
```

"
"```python
class Solution:
    def __init__(self):
        self.buffer_index = 0
        self.buffer_len = 0
        self.buf4 = [None] * 4

    def read(self, buf, n):
        cnt = 0
        while cnt < n:
            if self.buffer_index == self.buffer_len:
                self.buffer_len = self.read4(self.buf4)
                self.buffer_index = 0
            if self.buffer_len == 0:
                break
            while cnt < n and self.buffer_index < self.buffer_len:
                buf[cnt] = self.buf4[self.buffer_index]
                cnt += 1
                self.buffer_index += 1
        return cnt

    def read4(self, buf4):
        return 0
```

",,"```python
class Solution:
    def __init__(self):
        self.buffer_index = 0
        self.buffer_len = 0
        self.buf4 = [None] * 4

    def read(self, buf, n):
        cnt = 0
        while cnt < n:
            if self.buffer_index == self.buffer_len:
                self.buffer_len = self.read4(self.buf4)
                self.buffer_index = 0
            if self.buffer_len == 0:
                break
            while cnt < n and self.buffer_index < self.buffer_len:
                buf[cnt] = self.buf4[self.buffer_index]
                cnt += 1
                self.buffer_index += 1
        return cnt

    def read4(self, buf4):
        return 0
```

"
"```python
def lengthOfLongestSubstringTwoDistinct(s: str) -> int:
    l, r, max_len, cur_len = 0, 0, 0, 0
    char_count = {}

    while r < len(s):
        if s[r] in char_count:
            char_count[s[r]] += 1
        else:
            char_count[s[r]] = 1
        if len(char_count) <= 2:
            cur_len += 1
        else:
            while len(char_count) > 2 and l <= r:
                char_count[s[l]] -= 1
                if char_count[s[l]] == 0:
                    del char_count[s[l]]
                l += 1
                cur_len -= 1
            cur_len += 1
        max_len = max(max_len, cur_len)
        r += 1
    return max_len
```

",,"```python
def lengthOfLongestSubstringTwoDistinct(s: str) -> int:
    l, r, max_len, cur_len = 0, 0, 0, 0
    char_count = {}

    while r < len(s):
        if s[r] in char_count:
            char_count[s[r]] += 1
        else:
            char_count[s[r]] = 1
        if len(char_count) <= 2:
            cur_len += 1
        else:
            while len(char_count) > 2 and l <= r:
                char_count[s[l]] -= 1
                if char_count[s[l]] == 0:
                    del char_count[s[l]]
                l += 1
                cur_len -= 1
            cur_len += 1
        max_len = max(max_len, cur_len)
        r += 1
    return max_len
```

"
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA, headB):
    pA, pB = headA, headB
    while pA is not pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    return pA
```


",,"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA, headB):
    pA, pB = headA, headB
    while pA is not pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    return pA
```


"
"```python
def isOneEditDistance(s: str, t: str) -> bool:
    m, n = len(s), len(t)
    if m > n:
        return isOneEditDistance(t, s)
    if n - m > 1:
        return False
    for i in range(m):
        if s[i] != t[i]:
            return s[i + (m < n):] == t[i + 1:]
    return m + 1 == n
```

",,"```python
def isOneEditDistance(s: str, t: str) -> bool:
    m, n = len(s), len(t)
    if m > n:
        return isOneEditDistance(t, s)
    if n - m > 1:
        return False
    for i in range(m):
        if s[i] != t[i]:
            return s[i + (m < n):] == t[i + 1:]
    return m + 1 == n
```

"
"```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

",,"```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

"
"```python
from typing import List

def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:
    result = []
    prev = lower - 1

    for i, num in enumerate(nums + [upper + 1]):
        if num - prev >= 2:
            result.append(f""{prev + 1}"" + ("""" if num - prev == 2 else ""->"") + f""{num - 1}"")
        prev = num

    return result
```

",,"```python
from typing import List

def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:
    result = []
    prev = lower - 1

    for i, num in enumerate(nums + [upper + 1]):
        if num - prev >= 2:
            result.append(f""{prev + 1}"" + ("""" if num - prev == 2 else ""->"") + f""{num - 1}"")
        prev = num

    return result
```

"
"```python
def maximumGap(nums):
    if len(nums) < 2:
        return 0

    min_val = min(nums)
    max_val = max(nums)
    length = len(nums)
    bucket_size = max(1, (max_val - min_val) // (length - 1))
    bucket_num = (max_val - min_val) // bucket_size + 1
    buckets = [[float(""inf""), float(""-inf"")] for _ in range(bucket_num)]

    for num in nums:
        idx = (num - min_val) // bucket_size
        buckets[idx][0] = min(buckets[idx][0], num)
        buckets[idx][1] = max(buckets[idx][1], num)

    max_gap = 0
    prev_max = min_val
    for bucket in buckets:
        if bucket[0] == float(""inf""):
            continue
        max_gap = max(max_gap, bucket[0] - prev_max)
        prev_max = bucket[1]
    return max_gap
```

",,"```python
def maximumGap(nums):
    if len(nums) < 2:
        return 0

    min_val = min(nums)
    max_val = max(nums)
    length = len(nums)
    bucket_size = max(1, (max_val - min_val) // (length - 1))
    bucket_num = (max_val - min_val) // bucket_size + 1
    buckets = [[float(""inf""), float(""-inf"")] for _ in range(bucket_num)]

    for num in nums:
        idx = (num - min_val) // bucket_size
        buckets[idx][0] = min(buckets[idx][0], num)
        buckets[idx][1] = max(buckets[idx][1], num)

    max_gap = 0
    prev_max = min_val
    for bucket in buckets:
        if bucket[0] == float(""inf""):
            continue
        max_gap = max(max_gap, bucket[0] - prev_max)
        prev_max = bucket[1]
    return max_gap
```

"
"```python
def compare_version(version1, version2):
    v1 = version1.split('.')
    v2 = version2.split('.')
    
    while v1 or v2:
        num1 = int(v1.pop(0)) if v1 else 0
        num2 = int(v2.pop(0)) if v2 else 0
        
        if num1 < num2:
            return -1
        if num1 > num2:
            return 1
    return 0
```

",,"```python
def compare_version(version1, version2):
    v1 = version1.split('.')
    v2 = version2.split('.')
    
    while v1 or v2:
        num1 = int(v1.pop(0)) if v1 else 0
        num2 = int(v2.pop(0)) if v2 else 0
        
        if num1 < num2:
            return -1
        if num1 > num2:
            return 1
    return 0
```

"
"```python
def fraction_to_decimal(numerator, denominator):
    if numerator == 0:
        return ""0""
    res = []
    if (numerator > 0) ^ (denominator > 0):
        res.append(""-"")
    num = abs(numerator)
    den = abs(denominator)
    res.append(str(num // den))
    num %= den
    if num == 0:
        return """".join(res)
    res.append(""."")
    map = {}
    while num:
        if num in map:
            res.insert(map[num], ""("")
            res.append("")"")
            break
        map[num] = len(res)
        num *= 10
        res.append(str(num // den))
        num %= den
    return """".join(res)
```


",,"```python
def fraction_to_decimal(numerator, denominator):
    if numerator == 0:
        return ""0""
    res = []
    if (numerator > 0) ^ (denominator > 0):
        res.append(""-"")
    num = abs(numerator)
    den = abs(denominator)
    res.append(str(num // den))
    num %= den
    if num == 0:
        return """".join(res)
    res.append(""."")
    map = {}
    while num:
        if num in map:
            res.insert(map[num], ""("")
            res.append("")"")
            break
        map[num] = len(res)
        num *= 10
        res.append(str(num // den))
        num %= den
    return """".join(res)
```


"
"```python
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        current_sum = numbers[left] + numbers[right]
        if current_sum == target:
            return [left + 1, right + 1]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

",,"```python
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        current_sum = numbers[left] + numbers[right]
        if current_sum == target:
            return [left + 1, right + 1]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

"
"```python
def convert_to_title(columnNumber: int) -> str:
    result = """"
    while columnNumber:
        columnNumber -= 1
        result = chr(columnNumber % 26 + ord('A')) + result
        columnNumber //= 26
    return result
```


",,"```python
def convert_to_title(columnNumber: int) -> str:
    result = """"
    while columnNumber:
        columnNumber -= 1
        result = chr(columnNumber % 26 + ord('A')) + result
        columnNumber //= 26
    return result
```


"
"```python
def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (num == candidate) - (num != candidate)

    return candidate
```

",,"```python
def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (num == candidate) - (num != candidate)

    return candidate
```

"
"```python
class TwoSum:

    def __init__(self):
        self.nums = {}

    def add(self, number: int) -> None:
        if number in self.nums:
            self.nums[number] += 1
        else:
            self.nums[number] = 1

    def find(self, value: int) -> bool:
        for num in self.nums:
            target = value - num
            if target in self.nums:
                if target != num or self.nums[num] > 1:
                    return True
        return False
```

",,"```python
class TwoSum:

    def __init__(self):
        self.nums = {}

    def add(self, number: int) -> None:
        if number in self.nums:
            self.nums[number] += 1
        else:
            self.nums[number] = 1

    def find(self, value: int) -> bool:
        for num in self.nums:
            target = value - num
            if target in self.nums:
                if target != num or self.nums[num] > 1:
                    return True
        return False
```

"
"```python
def title_to_number(column_title: str) -> int:
    result = 0
    for c in column_title:
        result = result * 26 + (ord(c) - ord('A') + 1)
    return result
```

",,"```python
def title_to_number(column_title: str) -> int:
    result = 0
    for c in column_title:
        result = result * 26 + (ord(c) - ord('A') + 1)
    return result
```

"
"```python
def trailing_zeroes(n: int) -> int:
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count
```


",,"```python
def trailing_zeroes(n: int) -> int:
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count
```


"
"```python
class BSTIterator:

    def __init__(self, root):
        self.stack = []
        self.push_left(root)

    def next(self):
        top = self.stack.pop()
        self.push_left(top.right)
        return top.val

    def hasNext(self):
        return len(self.stack) > 0

    def push_left(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

",,"```python
class BSTIterator:

    def __init__(self, root):
        self.stack = []
        self.push_left(root)

    def next(self):
        top = self.stack.pop()
        self.push_left(top.right)
        return top.val

    def hasNext(self):
        return len(self.stack) > 0

    def push_left(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

"
"```python
def calculateMinimumHP(dungeon):
    m, n = len(dungeon), len(dungeon[0])
    dp = [[0] * n for _ in range(m)]

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if i == m - 1 and j == n - 1:
                dp[i][j] = min(0, dungeon[i][j])
            elif i == m - 1:
                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])
            elif j == n - 1:
                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])
            else:
                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])

    return abs(dp[0][0]) + 1
```

",,"```python
def calculateMinimumHP(dungeon):
    m, n = len(dungeon), len(dungeon[0])
    dp = [[0] * n for _ in range(m)]

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if i == m - 1 and j == n - 1:
                dp[i][j] = min(0, dungeon[i][j])
            elif i == m - 1:
                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])
            elif j == n - 1:
                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])
            else:
                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])

    return abs(dp[0][0]) + 1
```

"
"```python
from functools import cmp_to_key

def largestNumber(nums):
    def comparator(a, b):
        return -1 if a + b > b + a else int(a + b < b + a)

    nums_as_str = list(map(str, nums))
    nums_as_str.sort(key=cmp_to_key(comparator))
    return '0' if nums_as_str[0] == ""0"" else """".join(nums_as_str)
```

",,"```python
from functools import cmp_to_key

def largestNumber(nums):
    def comparator(a, b):
        return -1 if a + b > b + a else int(a + b < b + a)

    nums_as_str = list(map(str, nums))
    nums_as_str.sort(key=cmp_to_key(comparator))
    return '0' if nums_as_str[0] == ""0"" else """".join(nums_as_str)
```

"
"```python
def reverseWords(s: list) -> None:
    def reverse(s, start, end):
        while start < end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1

    reverse(s, 0, len(s)-1)
    start = 0
    for i, char in enumerate(s + [' ']):
        if char == ' ':
            reverse(s, start, i - 1)
            start = i + 1
```

",,"```python
def reverseWords(s: list) -> None:
    def reverse(s, start, end):
        while start < end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1

    reverse(s, 0, len(s)-1)
    start = 0
    for i, char in enumerate(s + [' ']):
        if char == ' ':
            reverse(s, start, i - 1)
            start = i + 1
```

"
"```python
from collections import defaultdict

def findRepeatedDnaSequences(s: str):
    dna_counter = defaultdict(int)
    result = []

    for i in range(len(s) - 9):
        sequence = s[i:i + 10]
        dna_counter[sequence] += 1
        if dna_counter[sequence] == 2:
            result.append(sequence)

    return result
```

",,"```python
from collections import defaultdict

def findRepeatedDnaSequences(s: str):
    dna_counter = defaultdict(int)
    result = []

    for i in range(len(s) - 9):
        sequence = s[i:i + 10]
        dna_counter[sequence] += 1
        if dna_counter[sequence] == 2:
            result.append(sequence)

    return result
```

"
"```python
def maxProfit(k, prices):
    n = len(prices)
    if k > n // 2:
        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))

    dp = [[0] * n for _ in range(k + 1)]
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
    return dp[k][n - 1]
```

",,"```python
def maxProfit(k, prices):
    n = len(prices)
    if k > n // 2:
        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))

    dp = [[0] * n for _ in range(k + 1)]
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
    return dp[k][n - 1]
```

"
"```python
def rotate(nums, k):
    n = len(nums)
    k %= n
    nums[:] = nums[-k:] + nums[:-k]
```

",,"```python
def rotate(nums, k):
    n = len(nums)
    k %= n
    nums[:] = nums[-k:] + nums[:-k]
```

"
"```python
def reverse_bits(n: int) -> int:
    res = 0
    for _ in range(32):
        res <<= 1
        res |= n & 1
        n >>= 1
    return res
```

",,"```python
def reverse_bits(n: int) -> int:
    res = 0
    for _ in range(32):
        res <<= 1
        res |= n & 1
        n >>= 1
    return res
```

"
"```python
def hamming_weight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

",,"```python
def hamming_weight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

"
"```python
def transpose(content):
    data = [line.split("" "") for line in content]
    result = ["" "".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]
    return result
```


",,"```python
def transpose(content):
    data = [line.split("" "") for line in content]
    result = ["" "".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]
    return result
```


"
"```python
def rob(nums):
    prev1, prev2 = 0, 0
    for num in nums:
        prev1, prev2 = max(prev2 + num, prev1), prev1
    return prev1
```

",,"```python
def rob(nums):
    prev1, prev2 = 0, 0
    for num in nums:
        prev1, prev2 = max(prev2 + num, prev1), prev1
    return prev1
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def rightSideView(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level_size = len(queue)

        for i in range(level_size):
            current = queue.pop(0)

            if i == level_size - 1:
                result.append(current.val)
            
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

    return result
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def rightSideView(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level_size = len(queue)

        for i in range(level_size):
            current = queue.pop(0)

            if i == level_size - 1:
                result.append(current.val)
            
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

    return result
```

"
"```python
def dfs(grid, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
        return

    grid[i][j] = '0'
    dfs(grid, i + 1, j)
    dfs(grid, i - 1, j)
    dfs(grid, i, j + 1)
    dfs(grid, i, j - 1)

def numIslands(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                count += 1
                dfs(grid, i, j)
    return count
```

",,"```python
def dfs(grid, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
        return

    grid[i][j] = '0'
    dfs(grid, i + 1, j)
    dfs(grid, i - 1, j)
    dfs(grid, i, j + 1)
    dfs(grid, i, j - 1)

def numIslands(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                count += 1
                dfs(grid, i, j)
    return count
```

"
"```python
def range_bitwise_and(left: int, right: int) -> int:
    shift = 0
    while left != right:
        left >>= 1
        right >>= 1
        shift += 1
    return left << shift
```

",,"```python
def range_bitwise_and(left: int, right: int) -> int:
    shift = 0
    while left != right:
        left >>= 1
        right >>= 1
        shift += 1
    return left << shift
```

"
"```python
def get_next(n):
    sum = 0
    while n > 0:
        digit = n % 10
        sum += digit * digit
        n //= 10
    return sum

def is_happy(n):
    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

",,"```python
def get_next(n):
    sum = 0
    while n > 0:
        digit = n % 10
        sum += digit * digit
        n //= 10
    return sum

def is_happy(n):
    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_elements(head, val):
    sentinel = ListNode(0)
    sentinel.next = head
    prev, curr = sentinel, head

    while curr:
        if curr.val == val:
            prev.next = curr.next
        else:
            prev = curr
        curr = curr.next

    return sentinel.next
```

",,"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_elements(head, val):
    sentinel = ListNode(0)
    sentinel.next = head
    prev, curr = sentinel, head

    while curr:
        if curr.val == val:
            prev.next = curr.next
        else:
            prev = curr
        curr = curr.next

    return sentinel.next
```

"
"```python
def countPrimes(n: int) -> int:
    if n <= 2:
        return 0
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n, i):
                is_prime[j] = False
    return sum(is_prime)
```

",,"```python
def countPrimes(n: int) -> int:
    if n <= 2:
        return 0
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n, i):
                is_prime[j] = False
    return sum(is_prime)
```

"
"```python
def is_isomorphic(s: str, t: str) -> bool:
    map1, map2 = {}, {}
    for char_s, char_t in zip(s, t):
        if char_s not in map1:
            map1[char_s] = char_t
        if char_t not in map2:
            map2[char_t] = char_s
        if map1[char_s] != char_t or map2[char_t] != char_s:
            return False
    return True
```

",,"```python
def is_isomorphic(s: str, t: str) -> bool:
    map1, map2 = {}, {}
    for char_s, char_t in zip(s, t):
        if char_s not in map1:
            map1[char_s] = char_t
        if char_t not in map2:
            map2[char_t] = char_s
        if map1[char_s] != char_t or map2[char_t] != char_s:
            return False
    return True
```

"
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    current = head
    while current is not None:
        next = current.next
        current.next = prev
        prev = current
        current = next
    return prev
```

",,"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    current = head
    while current is not None:
        next = current.next
        current.next = prev
        prev = current
        current = next
    return prev
```

"
"```python
from collections import defaultdict, deque

def canFinish(numCourses, prerequisites):
    adj = defaultdict(list)
    inDegree = [0] * numCourses
    
    for a, b in prerequisites:
        adj[b].append(a)
        inDegree[a] += 1
    
    q = deque([i for i in range(numCourses) if inDegree[i]==0])
    
    while q:
        currCourse = q.popleft()
        numCourses -= 1
        
        for nextCourse in adj[currCourse]:
            inDegree[nextCourse] -= 1
            if inDegree[nextCourse] == 0:
                q.append(nextCourse)
    
    return numCourses == 0
```


",,"```python
from collections import defaultdict, deque

def canFinish(numCourses, prerequisites):
    adj = defaultdict(list)
    inDegree = [0] * numCourses
    
    for a, b in prerequisites:
        adj[b].append(a)
        inDegree[a] += 1
    
    q = deque([i for i in range(numCourses) if inDegree[i]==0])
    
    while q:
        currCourse = q.popleft()
        numCourses -= 1
        
        for nextCourse in adj[currCourse]:
            inDegree[nextCourse] -= 1
            if inDegree[nextCourse] == 0:
                q.append(nextCourse)
    
    return numCourses == 0
```


"
"```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.is_end_of_word = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.is_end_of_word

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True
```

",,"```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.is_end_of_word = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.is_end_of_word

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True
```

"
"```python
def minSubArrayLen(target: int, nums: List[int]) -> int:
    left, cur_sum, min_len = 0, 0, float('inf')
    for right in range(len(nums)):
        cur_sum += nums[right]
        while cur_sum >= target:
            min_len = min(min_len, right - left + 1)
            cur_sum -= nums[left]
            left += 1
    return min_len if min_len != float('inf') else 0
```

",,"```python
def minSubArrayLen(target: int, nums: List[int]) -> int:
    left, cur_sum, min_len = 0, 0, float('inf')
    for right in range(len(nums)):
        cur_sum += nums[right]
        while cur_sum >= target:
            min_len = min(min_len, right - left + 1)
            cur_sum -= nums[left]
            left += 1
    return min_len if min_len != float('inf') else 0
```

"
"```python
from collections import deque

def findOrder(numCourses, prerequisites):
    in_degree = [0] * numCourses
    adj_list = [[] for _ in range(numCourses)]
    
    for p in prerequisites:
        adj_list[p[1]].append(p[0])
        in_degree[p[0]] += 1
    
    q = deque([i for i in range(numCourses) if in_degree[i] == 0])
    order = []
    
    while q:
        curr = q.popleft()
        order.append(curr)
        for next in adj_list[curr]:
            in_degree[next] -= 1
            if in_degree[next] == 0:
                q.append(next)
    
    return order if len(order) == numCourses else []
```


",,"```python
from collections import deque

def findOrder(numCourses, prerequisites):
    in_degree = [0] * numCourses
    adj_list = [[] for _ in range(numCourses)]
    
    for p in prerequisites:
        adj_list[p[1]].append(p[0])
        in_degree[p[0]] += 1
    
    q = deque([i for i in range(numCourses) if in_degree[i] == 0])
    order = []
    
    while q:
        curr = q.popleft()
        order.append(curr)
        for next in adj_list[curr]:
            in_degree[next] -= 1
            if in_degree[next] == 0:
                q.append(next)
    
    return order if len(order) == numCourses else []
```


"
"```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_word = False

class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        current = self.root
        for c in word:
            index = ord(c) - ord('a')
            if current.children[index] is None:
                current.children[index] = TrieNode()
            current = current.children[index]
        current.is_word = True

    def search(self, word: str) -> bool:
        return self._search_helper(self.root, word, 0)

    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:
        if index == len(word):
            return node.is_word

        if word[index] == '.':
            for child_node in node.children:
                if child_node is not None and self._search_helper(child_node, word, index + 1):
                    return True
            return False
        else:
            child_node = node.children[ord(word[index]) - ord('a')]
            if child_node is None:
                return False
            return self._search_helper(child_node, word, index + 1)
```


",,"```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_word = False

class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        current = self.root
        for c in word:
            index = ord(c) - ord('a')
            if current.children[index] is None:
                current.children[index] = TrieNode()
            current = current.children[index]
        current.is_word = True

    def search(self, word: str) -> bool:
        return self._search_helper(self.root, word, 0)

    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:
        if index == len(word):
            return node.is_word

        if word[index] == '.':
            for child_node in node.children:
                if child_node is not None and self._search_helper(child_node, word, index + 1):
                    return True
            return False
        else:
            child_node = node.children[ord(word[index]) - ord('a')]
            if child_node is None:
                return False
            return self._search_helper(child_node, word, index + 1)
```


"
"```python
def findWords(board, words):
    def dfs(board, word, index, i, j, visited):
        if index == len(word):
            return True
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:
            return False
        visited[i][j] = True
        found = dfs(board, word, index + 1, i - 1, j, visited) or \
                dfs(board, word, index + 1, i + 1, j, visited) or \
                dfs(board, word, index + 1, i, j - 1, visited) or \
                dfs(board, word, index + 1, i, j + 1, visited)
        visited[i][j] = False
        return found

    res = []
    for word in words:
        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])
               for i in range(len(board)) for j in range(len(board[0]))):
            res.append(word)
    return res
```


",,"```python
def findWords(board, words):
    def dfs(board, word, index, i, j, visited):
        if index == len(word):
            return True
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:
            return False
        visited[i][j] = True
        found = dfs(board, word, index + 1, i - 1, j, visited) or \
                dfs(board, word, index + 1, i + 1, j, visited) or \
                dfs(board, word, index + 1, i, j - 1, visited) or \
                dfs(board, word, index + 1, i, j + 1, visited)
        visited[i][j] = False
        return found

    res = []
    for word in words:
        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])
               for i in range(len(board)) for j in range(len(board[0]))):
            res.append(word)
    return res
```


"
"```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    prev, curr = 0, 0
    for i in range(len(nums) - 1):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    res = curr
    prev, curr = 0, 0
    for i in range(1, len(nums)):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    return max(res, curr)
```

",,"```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    prev, curr = 0, 0
    for i in range(len(nums) - 1):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    res = curr
    prev, curr = 0, 0
    for i in range(1, len(nums)):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    return max(res, curr)
```

"
"```python
def shortest_palindrome(s: str) -> str:
    n = len(s)
    rev_s = s[::-1]
    
    for i in range(n):
        if s[:n - i] == rev_s[i:]:
            return rev_s[:i] + s
    return """"
```


",,"```python
def shortest_palindrome(s: str) -> str:
    n = len(s)
    rev_s = s[::-1]
    
    for i in range(n):
        if s[:n - i] == rev_s[i:]:
            return rev_s[:i] + s
    return """"
```


"
"```python
def findKthLargest(nums: List[int], k: int) -> int:
    nums.sort(reverse=True)
    return nums[k-1]
```

",,"```python
def findKthLargest(nums: List[int], k: int) -> int:
    nums.sort(reverse=True)
    return nums[k-1]
```

"
"```python
def combinationSum3(k, n):
    def helper(k, n, current, current_comb, result):
        if k == 0 and n == 0:
            result.append(list(current_comb))
        elif k > 0 and n > 0:
            for i in range(current + 1, 10):
                current_comb.append(i)
                helper(k - 1, n - i, i, current_comb, result)
                current_comb.pop()

    result = []
    helper(k, n, 0, [], result)
    return result
```


",,"```python
def combinationSum3(k, n):
    def helper(k, n, current, current_comb, result):
        if k == 0 and n == 0:
            result.append(list(current_comb))
        elif k > 0 and n > 0:
            for i in range(current + 1, 10):
                current_comb.append(i)
                helper(k - 1, n - i, i, current_comb, result)
                current_comb.pop()

    result = []
    helper(k, n, 0, [], result)
    return result
```


"
"```python
def containsDuplicate(nums):
    return len(nums) != len(set(nums))
```


",,"```python
def containsDuplicate(nums):
    return len(nums) != len(set(nums))
```


"
"```python
from sortedcontainers import SortedList

def getSkyline(buildings):
    points = []
    for l, r, h in buildings:
        points.append((l, -h))
        points.append((r, h))
    points.sort()
    heights = SortedList([0])
    prev = 0
    skyline = []
    for x, h in points:
        if h < 0:
            heights.add(-h)
        else:
            heights.remove(h)
        cur = heights[-1]
        if cur != prev:
            skyline.append([x, cur])
            prev = cur
    return skyline
```

",,"```python
from sortedcontainers import SortedList

def getSkyline(buildings):
    points = []
    for l, r, h in buildings:
        points.append((l, -h))
        points.append((r, h))
    points.sort()
    heights = SortedList([0])
    prev = 0
    skyline = []
    for x, h in points:
        if h < 0:
            heights.add(-h)
        else:
            heights.remove(h)
        cur = heights[-1]
        if cur != prev:
            skyline.append([x, cur])
            prev = cur
    return skyline
```

"
"```python
def containsNearbyDuplicate(nums, k):
    value_index_map = {}
    for i, num in enumerate(nums):
        if num in value_index_map and i - value_index_map[num] <= k:
            return True
        value_index_map[num] = i
    return False
```

",,"```python
def containsNearbyDuplicate(nums, k):
    value_index_map = {}
    for i, num in enumerate(nums):
        if num in value_index_map and i - value_index_map[num] <= k:
            return True
        value_index_map[num] = i
    return False
```

"
"```python
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(nums, k, t):
    window = SortedList()
    for i in range(len(nums)):
        if i > k:
            window.remove(nums[i - k - 1])
        pos = window.bisect_left(nums[i] - t)
        if pos != len(window) and window[pos] - nums[i] <= t:
            return True
        window.add(nums[i])
    return False
```

",,"```python
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(nums, k, t):
    window = SortedList()
    for i in range(len(nums)):
        if i > k:
            window.remove(nums[i - k - 1])
        pos = window.bisect_left(nums[i] - t)
        if pos != len(window) and window[pos] - nums[i] <= t:
            return True
        window.add(nums[i])
    return False
```

"
"```python
def maximalSquare(matrix):
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxSize = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i - 1][j - 1] == '1':
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                maxSize = max(maxSize, dp[i][j])

    return maxSize * maxSize
```

",,"```python
def maximalSquare(matrix):
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxSize = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i - 1][j - 1] == '1':
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                maxSize = max(maxSize, dp[i][j])

    return maxSize * maxSize
```

"
"```python
class TreeNode:
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right

def count_nodes(root):
    if not root:
        return 0
    ld = rd = 0
    l = r = root

    while l:
        l = l.left
        ld += 1

    while r:
        r = r.right
        rd += 1

    if ld == rd:
        return (1 << ld) - 1
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

",,"```python
class TreeNode:
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right

def count_nodes(root):
    if not root:
        return 0
    ld = rd = 0
    l = r = root

    while l:
        l = l.left
        ld += 1

    while r:
        r = r.right
        rd += 1

    if ld == rd:
        return (1 << ld) - 1
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

"
"```python
def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    area1 = (ax2 - ax1) * (ay2 - ay1)
    area2 = (bx2 - bx1) * (by2 - by1)

    overlap_width = min(ax2, bx2) - max(ax1, bx1)
    overlap_height = min(ay2, by2) - max(ay1, by1)

    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)

    return area1 + area2 - overlap_area
```


",,"```python
def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    area1 = (ax2 - ax1) * (ay2 - ay1)
    area2 = (bx2 - bx1) * (by2 - by1)

    overlap_width = min(ax2, bx2) - max(ax1, bx1)
    overlap_height = min(ay2, by2) - max(ay1, by1)

    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)

    return area1 + area2 - overlap_area
```


"
"```python
def calculate(s: str) -> int:
    result = 0
    sign = 1
    num = 0
    st = []
    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        else:
            result += sign * num
            num = 0
            if c == '+':
                sign = 1
            elif c == '-':
                sign = -1
            elif c == '(':
                st.append(result)
                st.append(sign)
                result = 0
                sign = 1
            elif c == ')':
                prev_sign = st.pop()
                prev_result = st.pop()
                result = prev_result + prev_sign * result
    result += sign * num
    return result
```

",,"```python
def calculate(s: str) -> int:
    result = 0
    sign = 1
    num = 0
    st = []
    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        else:
            result += sign * num
            num = 0
            if c == '+':
                sign = 1
            elif c == '-':
                sign = -1
            elif c == '(':
                st.append(result)
                st.append(sign)
                result = 0
                sign = 1
            elif c == ')':
                prev_sign = st.pop()
                prev_result = st.pop()
                result = prev_result + prev_sign * result
    result += sign * num
    return result
```

"
"```python
from collections import deque

class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x: int) -> None:
        self.q2.append(x)
        while self.q1:
            self.q2.append(self.q1.popleft())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self) -> int:
        return self.q1.popleft()

    def top(self) -> int:
        return self.q1[0]

    def empty(self) -> bool:
        return not self.q1
```

",,"```python
from collections import deque

class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x: int) -> None:
        self.q2.append(x)
        while self.q1:
            self.q2.append(self.q1.popleft())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self) -> int:
        return self.q1.popleft()

    def top(self) -> int:
        return self.q1[0]

    def empty(self) -> bool:
        return not self.q1
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invert_tree(root):
    if root is None:
        return None
    root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invert_tree(root):
    if root is None:
        return None
    root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root
```

"
"```python
def calculate(s: str) -> int:
    result, num, sign, stack = 0, 0, 1, []

    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        elif c == '+':
            result += sign * num
            num = 0
            sign = 1
        elif c == '-':
            result += sign * num
            num = 0
            sign = -1
        elif c == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif c == ')':
            result += sign * num
            num = 0
            result *= stack.pop()
            result += stack.pop()
    
    if num:
        result += sign * num
        
    return result
```

",,"```python
def calculate(s: str) -> int:
    result, num, sign, stack = 0, 0, 1, []

    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        elif c == '+':
            result += sign * num
            num = 0
            sign = 1
        elif c == '-':
            result += sign * num
            num = 0
            sign = -1
        elif c == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif c == ')':
            result += sign * num
            num = 0
            result *= stack.pop()
            result += stack.pop()
    
    if num:
        result += sign * num
        
    return result
```

"
"```python
from typing import List

def find_ranges(nums: List[int]) -> List[str]:
    result = []
    n = len(nums)
    if n == 0: 
        return result

    start = nums[0]
    for i in range(1, n):
        if nums[i] > nums[i-1] + 1:
            if start == nums[i-1]:
                result.append(str(start))
            else:
                result.append(str(start) + ""->"" + str(nums[i-1]))
            start = nums[i]

    if start == nums[n-1]:
        result.append(str(start))
    else:
        result.append(str(start) + ""->"" + str(nums[n-1]))

    return result
```

",,"```python
from typing import List

def find_ranges(nums: List[int]) -> List[str]:
    result = []
    n = len(nums)
    if n == 0: 
        return result

    start = nums[0]
    for i in range(1, n):
        if nums[i] > nums[i-1] + 1:
            if start == nums[i-1]:
                result.append(str(start))
            else:
                result.append(str(start) + ""->"" + str(nums[i-1]))
            start = nums[i]

    if start == nums[n-1]:
        result.append(str(start))
    else:
        result.append(str(start) + ""->"" + str(nums[n-1]))

    return result
```

"
"```python
def majorityElement(nums):
    n = len(nums)
    count = {}
    result = []

    for num in nums:
        if num not in count:
            count[num] = 1
        else:
            count[num] += 1
        if count[num] > n / 3 and num not in result:
            result.append(num)

    return result
```

",,"```python
def majorityElement(nums):
    n = len(nums)
    count = {}
    result = []

    for num in nums:
        if num not in count:
            count[num] = 1
        else:
            count[num] += 1
        if count[num] > n / 3 and num not in result:
            result.append(num)

    return result
```

"
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kthSmallest(root, k):
    stk = []
    curr = root
    
    while True:
        while curr:
            stk.append(curr)
            curr = curr.left
        
        curr = stk.pop()
        
        k -= 1
        if k == 0:
            return curr.val
        
        curr = curr.right
```

",,"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kthSmallest(root, k):
    stk = []
    curr = root
    
    while True:
        while curr:
            stk.append(curr)
            curr = curr.left
        
        curr = stk.pop()
        
        k -= 1
        if k == 0:
            return curr.val
        
        curr = curr.right
```

"
"```python
def is_power_of_two(n):
    if n <= 0:
        return False
    return (n & (n - 1)) == 0
```

",,
"```python
class MyQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, x: int) -> None:
        self.stack1.append(x)

    def pop(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def peek(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]

    def empty(self) -> bool:
        return not self.stack1 and not self.stack2
```

",,
"```python
def countDigitOne(n):
    count = 0
    i = 1
    while i <= n:
        divider = i * 10
        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)
        i *= 10
    return count
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def isPalindrome(head):
    if not head or not head.next:
        return True

    fast, slow, prev = head, head, None
    while fast and fast.next:
        fast = fast.next.next
        temp = slow.next
        slow.next = prev
        prev = slow
        slow = temp

    if fast:
        slow = slow.next

    while prev and prev.val == slow.val:
        prev = prev.next
        slow = slow.next

    return prev == None
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowest_common_ancestor(root, p, q):
    if root is None or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left is not None and right is not None:
        return root
    else:
        return left if left is not None else right
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    return right if left is None else (left if right is None else root)
```


",,
"```python
def deleteNode(node):
    next_node = node.next
    node.val = next_node.val
    node.next = next_node.next
```

",,
"```python
def productExceptSelf(nums):
    n = len(nums)
    answer = [1] * n
    
    left = 1
    for i in range(n):
        answer[i] *= left
        left *= nums[i]
    
    right = 1
    for i in range(n - 1, -1, -1):
        answer[i] *= right
        right *= nums[i]
    
    return answer
```

",,
"```python
from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()
    result = []

    for i in range(len(nums)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()

        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()

        dq.append(i)

        if i >= k - 1:
            result.append(nums[dq[0]])

    return result
```


",,
"```python
def searchMatrix(matrix, target):
    row, col = len(matrix) - 1, 0
    while row >= 0 and col < len(matrix[0]):
        if matrix[row][col] > target:
            row -= 1
        elif matrix[row][col] < target:
            col += 1
        else:
            return True
    return False
```

",,
"```python
def diffWaysToCompute(input: str):
    result = []
    for i in range(len(input)):
        c = input[i]
        if c == '+' or c == '-' or c == '*':
            left = diffWaysToCompute(input[:i])
            right = diffWaysToCompute(input[i + 1:])
            for l in left:
                for r in right:
                    if c == '+': result.append(l + r)
                    elif c == '-': result.append(l - r)
                    elif c == '*': result.append(l * r)
    if not result:
        result.append(int(input))
    return result
```

",,
"```python
def is_anagram(s, t):
    if len(s) != len(t):
        return False

    counts = {}
    for c in s:
        if c in counts:
            counts[c] += 1
        else:
            counts[c] = 1

    for c in t:
        if c not in counts or counts[c] == 0:
            return False
        counts[c] -= 1

    return True
```

",,
"```python
def shortestDistance(wordsDict, word1, word2):
    idx1, idx2, minDistance = -1, -1, float('inf')
    for i, word in enumerate(wordsDict):
        if word == word1:
            idx1 = i
        if word == word2:
            idx2 = i
        if idx1 != -1 and idx2 != -1:
            minDistance = min(minDistance, abs(idx1 - idx2))
    return minDistance
```

",,
"```python
class WordDistance:

    def __init__(self, wordsDict):
        self.word_indexes = {}
        for i, word in enumerate(wordsDict):
            if word not in self.word_indexes:
                self.word_indexes[word] = []
            self.word_indexes[word].append(i)

    def shortest(self, word1, word2):
        indexes1 = self.word_indexes[word1]
        indexes2 = self.word_indexes[word2]
        i, j, min_dist = 0, 0, float('inf')

        while i < len(indexes1) and j < len(indexes2):
            min_dist = min(min_dist, abs(indexes1[i] - indexes2[j]))
            if indexes1[i] < indexes2[j]:
                i += 1
            else:
                j += 1

        return min_dist
```
",,
"```python
def shortest_distance(words_dict, word1, word2):
    index1, index2, min_distance = -1, -1, float('inf')
    for i, word in enumerate(words_dict):
        if word == word1:
            index1 = i
        if word == word2:
            index2 = i
        if index1 != -1 and(index2 != -1):
            min_distance = min(min_distance, abs(index1 - index2))
    return min_distance
```

",,
"```python
def isStrobogrammatic(num: str) -> bool:
    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    left, right = 0, len(num) - 1
    while left <= right:
        if num[left] not in lookup or lookup[num[left]] != num[right]:
            return False
        left += 1
        right -= 1
    return True
```

",,
"```python
def findStrobogrammatic(n):
    def helper(n, m):
        if n == 0:
            return [""""]
        if n == 1:
            return [""0"", ""1"", ""8""]

        list = helper(n - 2, m)
        res = []

        for s in list:
            if n != m:
                res.append(""0"" + s + ""0"")

            res.append(""1"" + s + ""1"")
            res.append(""6"" + s + ""9"")
            res.append(""8"" + s + ""8"")
            res.append(""9"" + s + ""6"")

        return res

    return helper(n, n)
```

",,
"```python
def strobogrammaticInRange(low, high):
    count = 0
    for len in range(len(low), len(high)+1):
        count += 1 if low <= helper(len, len) <= high else 0
    return count

def helper(m, n):
    if m == 0:
        return """"
    if m == 1:
        return ""0 1 8""
    if n == 0:
        return ""11 69 88 96""
    res = """"
    for a in helper(m-2, n).split():
        if m != n:
            res += a + ""0"" + a + "" ""
        res += a + ""1"" + a + "" ""
        res += a + ""6"" + a + "" ""
        res += a + ""8"" + a + "" ""
        res += a + ""9"" + a + "" ""
    return res
```


",,
"```python
from collections import defaultdict

def groupStrings(strings):
    groups = defaultdict(list)

    for s in strings:
        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)
        groups[key].append(s)

    return list(groups.values())
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def countUnivalSubtrees(self, root: TreeNode) -> int:
        count = 0

        def helper(node):
            nonlocal count
            if node is None:
                return True

            left = helper(node.left)
            right = helper(node.right)

            if left and right:
                if node.left and node.val != node.left.val:
                    return False
                if node.right and node.val != node.right.val:
                    return False
                count += 1
                return True

            return False

        helper(root)
        return count
```

",,
"```python
class Vector2D:
    def __init__(self, vec):
        self.vec = vec
        self.row = 0
        self.col = 0

    def next(self):
        val = self.vec[self.row][self.col]
        self.col += 1
        return val

    def hasNext(self):
        while self.row < len(self.vec):
            if self.col < len(self.vec[self.row]):
                return True
            self.row += 1
            self.col = 0
        return False
```


",,
"```python
def can_attend_meetings(intervals):
    intervals.sort()

    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i - 1][1]:
            return False

    return True
```

",,
"```python
import heapq

def minMeetingRooms(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[0])

    min_heap = [intervals[0][1]]
    for start, end in intervals[1:]:
        if start >= min_heap[0]:
            heapq.heappop(min_heap)
        heapq.heappush(min_heap, end)

    return len(min_heap)
```

",,
"```python
def getFactors(n):
    def helper(n, start, path, result):
        if n == 1:
            if len(path) > 1:
                result.append(path[:])
            return

        for i in range(start, n + 1):
            if n % i == 0:
                path.append(i)
                helper(n // i, i, path, result)
                path.pop()

    result = []
    helper(n, 2, [], result)
    return result
```

",,
"```python
def isValidPreorder(preorder: List[int]) -> bool:
    stack = []
    lower_bound = float('-inf')
    for num in preorder:
        if num < lower_bound:
            return False
        while stack and num > stack[-1]:
            lower_bound = stack.pop()
        stack.append(num)
    return True
```

",,
"```python
def minCost(costs: List[List[int]]) -> int:
    if not costs:
        return 0
    for i in range(1, len(costs)):
        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])
    return min(costs[-1][0], costs[-1][1], costs[-1][2])
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def binary_tree_paths(root: TreeNode):
    if not root:
        return []
    if not root.left and not root.right:
        return [str(root.val)]
    paths = []
    for path in binary_tree_paths(root.left):
        paths.append(str(root.val) + ""->"" + path)
    for path in binary_tree_paths(root.right):
        paths.append(str(root.val) + ""->"" + path)
    return paths
```

",,
"```python
def addDigits(num: int) -> int:
    return 1 + (num - 1) % 9
```

",,
"```python
def threeSumSmaller(nums, target):
    count = 0
    nums.sort()
    for i in range(len(nums)):
        j, k = i + 1, len(nums) - 1
        while j < k:
            if nums[i] + nums[j] + nums[k] < target:
                count += k - j
                j += 1
            else:
                k -= 1
    return count
```

",,
"```python
def singleNumber(nums):
    xor_all = 0
    for num in nums:
        xor_all ^= num

    bit = xor_all & -xor_all
    n1 = 0
    n2 = 0
    for num in nums:
        if num & bit:
            n1 ^= num
        else:
            n2 ^= num

    return n1, n2
```

",,
"```python
from typing import List

def isTree(n: int, edges: List[List[int]]) -> bool:
    neighbors = [[] for _ in range(n)]
    for edge in edges:
        neighbors[edge[0]].append(edge[1])
        neighbors[edge[1]].append(edge[0])
    visited = [False] * n
    if hasCycle(neighbors, visited, -1, 0): return False
    return all(visited)

def hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:
    visited[node] = True
    for neighbor in neighbors[node]:
        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True
    return False
```

",,
"```python
def is_ugly(n: int) -> bool:
    if n <= 0:
        return False
    for factor in [2, 3, 5]:
        while n % factor == 0:
            n //= factor
    return n == 1
```

",,
"```python
def nthUglyNumber(n: int) -> int:
    ugly_numbers = [0] * n
    ugly_numbers[0] = 1
    i2, i3, i5 = 0, 0, 0

    for i in range(1, n):
        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)
        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1
        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1
        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1

    return ugly_numbers[n - 1]

```


",,
"```python
def min_cost(costs: List[List[int]]) -> int:
    if not costs:
        return 0

    n, k = len(costs), len(costs[0])

    for i in range(1, n):
        for j in range(k):
            min_cost = float(""inf"")
            for l in range(k):
                if l == j:
                    continue
                min_cost = min(min_cost, costs[i - 1][l])
            costs[i][j] += min_cost

    return min(costs[n - 1])
```


",,
"```python
def canPermutePalindrome(s: str) -> bool:
    count = {}
    for c in s:
        if c in count:
            count[c] += 1
        else:
            count[c] = 1
    odd_count = 0
    for value in count.values():
        if value % 2:
            odd_count += 1
    return odd_count <= 1
```

",,
"```python
from collections import Counter
from itertools import permutations

def generatePalindromes(s):
    result = []
    char_count = Counter(s)

    mid_char = """"
    half_str = []
    num_ocurrences = 0

    for char, count in char_count.items():
        if count % 2 == 1:
            num_ocurrences += 1
            mid_char = char
        half_str.extend([char] * (count // 2))

        if num_ocurrences > 1:
            return result

    for perm in set(permutations(half_str)):
        palindrome = """".join(perm) + mid_char + """".join(reversed(perm))
        result.append(palindrome)

    return result
```

",,
"```python
def missingNumber(nums):
    n = len(nums)
    expected_sum = (n * (n + 1)) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum
```

",,
"```python
from collections import deque, defaultdict, Counter

def alienOrder(words):
    graph = defaultdict(set)
    in_degree = Counter({c: 0 for word in words for c in word})
    
    for word1, word2 in zip(words, words[1:]):
        found = False
        for c1, c2 in zip(word1, word2):
            if c1 != c2:
                if c2 not in graph[c1]:
                    graph[c1].add(c2)
                    in_degree[c2] += 1
                found = True
                break
        if not found and len(word1) > len(word2):
            return """"
    
    q = deque([c for c in in_degree if in_degree[c] == 0])
    result = []
    while q:
        c = q.popleft()
        result.append(c)
        
        for neigh in graph[c]:
            in_degree[neigh] -= 1
            if in_degree[neigh] == 0:
                q.append(neigh)
                 
    if len(result) < len(in_degree):
        return """"
    
    return """".join(result)
```

",,
"```python
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        closest = root.val
        while root:
            if abs(target - closest) > abs(target - root.val):
                closest = root.val
            root = root.left if target < root.val else root.right
        return closest
```

",,
"```python
def encode(strs):
    encoded_string = """"
    for s in strs:
        encoded_string += str(len(s)) + ""#"" + s
    return encoded_string

def decode(s):
    strs = []
    i = 0
    while i < len(s):
        delimiter_pos = s.find('#', i)
        length = int(s[i:delimiter_pos])
        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])
        i = delimiter_pos + 1 + length
    return strs
```


",,
"```python
from heapq import heappush, heappop

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def closestKValues(root, target, k):
    values = []
    max_heap = []

    def inorder_traverse(node):
        if not node:
            return
        inorder_traverse(node.left)
        heappush(max_heap, (-abs(node.val - target), node.val))
        if len(max_heap) > k:
            heappop(max_heap)
        inorder_traverse(node.right)

    inorder_traverse(root)
    while max_heap:
        _, val = heappop(max_heap)
        values.append(val)
    return values
```

",,
"```python
class Solution:
    def numberToWords(self, num: int) -> str:
        if num == 0:
            return ""Zero""
        LESS_THAN_20 = ["""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"", ""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""]
        TENS = ["""", ""Ten"", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""]
        THOUSANDS = ["""", ""Thousand"", ""Million"", ""Billion""]

        def helper(num):
            if num == 0:
                return """"
            elif num < 20:
                return LESS_THAN_20[num] + "" ""
            elif num < 100:
                return TENS[num // 10] + "" "" + helper(num % 10)
            else:
                return LESS_THAN_20[num // 100] + "" Hundred "" + helper(num % 100)

        result = """"
        i = 0
        while num > 0:
            if num % 1000 != 0:
                result = helper(num % 1000) + THOUSANDS[i] + "" "" + result
            num //= 1000
            i += 1
        return result.strip()
```

",,
"```python
def hIndex(citations: List[int]) -> int:
    citations.sort(reverse=True)
    h = 0
    for i, citation in enumerate(citations):
        if citation >= i + 1:
            h = i + 1
        else:
            break
    return h
```

",,
"```python
def hIndex(citations: List[int]) -> int:
    n = len(citations)
    left, right = 0, n - 1

    while left <= right:
        mid = left + (right - left) // 2
        if citations[mid] == n - mid:
            return n - mid
        elif citations[mid] < n - mid:
            left = mid + 1
        else:
            right = mid - 1

    return n - left
```

",,
"```python
def numWays(n, k):
    if n == 0:
        return 0
    if n == 1:
        return k
    same = k
    different = k * (k - 1)
    for i in range(2, n):
        temp = different
        different = (same + different) * (k - 1)
        same = temp
    return same + different
```

",,
"```python
def knows(a: int, b:int) -> bool:
    pass

def findCelebrity(n: int) -> int:
    candidate = 0
    for i in range(1, n):
        if knows(candidate, i):
            candidate = i
    
    for i in range(n):
        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):
            return -1
    return candidate
```

",,
"```python
def first_bad_version(n):
    left, right = 1, n
    while left < right:
        mid = left + (right - left) // 2
        if is_bad_version(mid):
            right = mid
        else:
            left = mid + 1
    return left
```


",,
"```python
def numSquares(n):
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
            
    return dp[n]
```

",,
"```python
def wiggleSort(nums):
    for i in range(1, len(nums)):
        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):
            nums[i], nums[i-1] = nums[i-1], nums[i]
```

",,
"```python
class ZigzagIterator:

    def __init__(self, v1: List[int], v2: List[int]):
        self.v1, self.v2 = v1, v2
        self.index1, self.index2 = 0, 0

    def next(self) -> int:
        if self.index1 < len(self.v1) and (self.index1 <= self.index2 or self.index2 == len(self.v2)):
            result = self.v1[self.index1]
            self.index1 += 1
            return result
        if self.index2 < len(self.v2) and (self.index2 < self.index1 or self.index1 == len(self.v1)):
            result = self.v2[self.index2]
            self.index2 += 1
            return result

    def hasNext(self) -> bool:
        return self.index1 < len(self.v1) or self.index2 < len(self.v2)
```

",,
"```python
from typing import List

def addOperators(num: str, target: int) -> List[str]:
    def helper(num, target, pos, currVal, prevVal, currExpr):
        if pos == len(num):
            if currVal == target:
                res.append(currExpr)
            return

        for i in range(pos, len(num)):
            if i != pos and num[pos] == '0':
                break

            val = int(num[pos:i + 1])
            if pos == 0:
                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])
            else:
                helper(num, target, i + 1, currVal + val, val, currExpr + ""+"" + num[pos:i + 1])
                helper(num, target, i + 1, currVal - val, -val, currExpr + ""-"" + num[pos:i + 1])
                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + ""*"" + num[pos:i + 1])

    res = []
    helper(num, target, 0, 0, 0, """")
    return res
```


",,
"```python
def moveZeroes(nums):
    index = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[index] = nums[i]
            index += 1
    for i in range(index, len(nums)):
        nums[i] = 0
```

",,
"```python
class PeekingIterator:
    def __init__(self, iterator):
        self.iterator = iterator
        self.next_val = next(self.iterator, None)

    def peek(self):
        return self.next_val

    def next(self):
        current_val = self.next_val
        self.next_val = next(self.iterator, None)
        return current_val

    def hasNext(self):
        return self.next_val is not None
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode:
    successor = None
    while root:
        if root.val > p.val:
            successor = root
            root = root.left
        else:
            root = root.right
    return successor
```
",,
"```python
from collections import deque

def wallsAndGates(rooms):
    m, n = len(rooms), len(rooms[0])
    q = deque()
    INF = 2147483647

    for i in range(m):
        for j in range(n):
            if rooms[i][j] == 0:
                q.append((i, j))

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while q:
        i, j = q.popleft()

        for d in directions:
            ni, nj = i + d[0], j + d[1]

            if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF:
                rooms[ni][nj] = rooms[i][j] + 1
                q.append((ni, nj))

```

",,
"```python
def findDuplicate(nums):
    slow = nums[0]
    fast = nums[0]

    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    slow = nums[0]

    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow
```


",,
"```python
class ValidWordAbbr:

    def __init__(self, dictionary):
        self.word_map = {}
        for word in dictionary:
            abbr = self.get_abbreviation(word)
            if abbr not in self.word_map:
                self.word_map[abbr] = {word}
            else:
                self.word_map[abbr].add(word)

    def isUnique(self, word):
        abbr = self.get_abbreviation(word)
        abbr_group = self.word_map.get(abbr, set())
        return len(abbr_group) == 0 or (len(abbr_group) == 1 and word in abbr_group)

    def get_abbreviation(self, word):
        n = len(word)
        return word if n <= 2 else word[0] + str(n - 2) + word[-1]
```


",,
"```python
def gameOfLife(board):
    m, n = len(board), len(board[0])
    result = [[0] * n for _ in range(m)]
    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    
    for i in range(m):
        for j in range(n):
            liveNeighbors = 0
            
            for dir in dirs:
                newRow = i + dir[0]
                newCol = j + dir[1]
                
                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:
                    liveNeighbors += 1
            
            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):
                result[i][j] = 1
            elif board[i][j] == 0 and liveNeighbors == 3:
                result[i][j] = 1
                
    return result
```

",,
"```python
def word_pattern(pattern, s):
    words = s.split()
    if len(pattern) != len(words):
        return False

    char_map, word_map = {}, {}
    for c, word in zip(pattern, words):
        if c not in char_map and word not in word_map:
            char_map[c] = word
            word_map[word] = c
        else:
            if char_map.get(c) != word or word_map.get(word) != c:
                return False

    return True
```


",,
"```python
def wordPatternMatch(pattern: str, s: str) -> bool:
    def backtrack(p_index, s_index, pattern_map, words):
        if p_index == len(pattern) and s_index == len(s):
            return True
        if p_index == len(pattern) or s_index == len(s):
            return False

        p = pattern[p_index]
        if p in pattern_map:
            word = pattern_map[p]
            if not s.startswith(word, s_index):
                return False
            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)
        else:
            for length in range(1, len(s) - s_index + 1):
                word = s[s_index : s_index + length]
                if word in words:
                    continue
                pattern_map[p] = word
                words.add(word)
                if backtrack(p_index + 1, s_index + length, pattern_map, words):
                    return True
                pattern_map.pop(p)
                words.remove(word)
        return False

    return backtrack(0, 0, {}, set())
```

",,
"```python
def canWinNim(n):
    return n % 4 != 0
```

",,
"```python
def generate_possible_next_moves(current_state):
    result = []
    for i in range(1, len(current_state)):
        if current_state[i] == '+' and current_state[i - 1] == '+':
            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])
    return result
```

",,
"```python
def canWin(currentState: str) -> bool:
    for i in range(len(currentState) - 1):
        if currentState[i] == '+' and currentState[i + 1] == '+':
            temp = currentState[:i] + ""--"" + currentState[i + 2:]
            if not canWin(temp):
                return True
    return False
```

",,
"```python
import heapq

class MedianFinder:
    def __init__(self):
        self.left = []  # max heap
        self.right = []  # min heap

    def addNum(self, num: int) -> None:
        if not self.left or num <= -self.left[0]:
            heapq.heappush(self.left, -num)
        else:
            heapq.heappush(self.right, num)
        
        if len(self.left) < len(self.right):
            heapq.heappush(self.left, -heapq.heappop(self.right))
        elif len(self.left) > len(self.right) + 1:
            heapq.heappush(self.right, -heapq.heappop(self.left))

    def findMedian(self) -> float:
        if len(self.left) == len(self.right):
            return (-self.left[0] + self.right[0]) / 2
        else:
            return -self.left[0]
```


",,
"```python
def minTotalDistance(grid):
    m, n = len(grid), len(grid[0])
    rows, cols = [], []
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                rows.append(i)
                cols.append(j)

    cols.sort()
    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]
    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)
    return distance
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def serialize(root):
    if not root: return ""null,""
    return str(root.val) + "","" + serialize(root.left) + serialize(root.right)

def deserialize(data):
    def deserialize_helper(values):
        val = values.pop(0)
        if val == 'null': return None
        root = TreeNode(int(val))
        root.left = deserialize_helper(values)
        root.right = deserialize_helper(values)
        return root

    values = data.split("","")
    return deserialize_helper(values[:-1])  # Excluding the last empty element
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def longest_consecutive_sequence(root, longest_path):
    if root is None:
        return 0
    left = longest_consecutive_sequence(root.left, longest_path)
    right = longest_consecutive_sequence(root.right, longest_path)
    curr_path = 1
    if root.left and root.left.val == root.val + 1:
        curr_path = max(curr_path, left + 1)
    if root.right and root.right.val == root.val + 1:
        curr_path = max(curr_path, right + 1)
    longest_path[0] = max(longest_path[0], curr_path)
    return curr_path

def longest_consecutive(root):
    longest_path = [0]
    longest_consecutive_sequence(root, longest_path)
    return longest_path[0]
```


",,
"```python
def get_hint(secret: str, guess: str) -> str:
    bulls = cows = 0
    secret_count = [0] * 10
    guess_count = [0] * 10

    for i in range(len(secret)):
        if secret[i] == guess[i]:
            bulls += 1
        else:
            secret_count[int(secret[i])] += 1
            guess_count[int(guess[i])] += 1
   
    for i in range(10):
        cows += min(secret_count[i], guess_count[i])
    
    return f""{bulls}A{cows}B""
```


",,
"```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    max_length = 1
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
        max_length = max(max_length, dp[i])
    return max_length
```

",,
"```python
from collections import deque

class Solution:
    def removeInvalidParentheses(self, s: str):
        visited = set()
        queue = deque([s])
        result = []
        found = False

        while queue:
            cur = queue.popleft()

            if self.is_valid(cur):
                found = True
                result.append(cur)

            if found: continue

            for i in range(len(cur)):
                if cur[i] == '(' or cur[i] == ')':
                    next_str = cur[:i] + cur[i+1:]
                    if next_str not in visited:
                        visited.add(next_str)
                        queue.append(next_str)

        return result

    def is_valid(self, s: str) -> bool:
        count = 0
        for c in s:
            if c == '(': count += 1
            if c == ')':
                count -= 1
                if count < 0: return False
        return count == 0
```


",,
"```python
def minArea(image, x, y):
    top, bottom, left, right = x, x, y, y
    for i, row in enumerate(image):
        for j, cell in enumerate(row):
            if cell == '1':
                top, bottom = min(top, i), max(bottom, i)
                left, right = min(left, j), max(right, j)
    return (bottom - top + 1) * (right - left + 1)
```

",,
"```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.pSum = [0] * (len(nums) + 1)
        for i, num in enumerate(nums):
            self.pSum[i + 1] = self.pSum[i] + num

    def sumRange(self, left: int, right: int) -> int:
        return self.pSum[right + 1] - self.pSum[left]
```

",,
"```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        self.dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + matrix[i - 1][j - 1]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]
```

",,
"```python
def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:
    def index(x: int, y: int) -> int:
        return x * n + y
    
    def find(x: int) -> int:
        if roots[x] != x:
            roots[x] = find(roots[x])
        return roots[x]

    roots = [-1] * (m * n)
    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]
    islandCount = 0
    result = []

    for i, j in positions:
        idx = index(i, j)
        if roots[idx] != -1:
            result.append(islandCount)
            continue
        islandCount += 1
        roots[idx] = idx
        for dx, dy in dirs:
            ni, nj = i + dx, j + dy
            neighbor = index(ni, nj)
            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:
                root_neighbor = find(neighbor)
                if idx != root_neighbor:
                    roots[root_neighbor] = idx
                    islandCount -= 1
        result.append(islandCount)
    return result
```


",,
"```python
def isAdditiveNumber(num):
    for i in range(1, len(num) // 2 + 1):
        for j in range(1, (len(num) - i) // 2 + 1):
            if check(num[:i], num[i:i+j], num[i+j:]):
                return True
    return False

def check(num1, num2, remaining):
    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):
        return False
    _sum = add(num1, num2)
    if remaining == _sum:
        return True
    if not remaining.startswith(_sum):
        return False
    return check(num2, _sum, remaining[len(_sum):])

def add(num1, num2):
    carry, result = 0, []
    i, j = len(num1) - 1, len(num2) - 1
    while i >= 0 or j >= 0 or carry > 0:
        n1 = int(num1[i]) if i >= 0 else 0
        n2 = int(num2[j]) if j >= 0 else 0
        _sum = n1 + n2 + carry
        carry = _sum // 10
        result.append(str(_sum % 10))
        i, j = i - 1, j - 1
    return ''.join(result[::-1])
```

",,
"```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.prefix_sum = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]

    def sumRange(self, left: int, right: int) -> int:
        return self.prefix_sum[right + 1] - self.prefix_sum[left]
```


",,
"```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]
                
    def update(self, row: int, col: int, val: int) -> None:
        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]
        delta = val - oldValue
        for i in range(row + 1, len(self.dp)):
            for j in range(col + 1, len(self.dp[0])):
                self.dp[i][j] += delta

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]
```


",,
"```python
def maxProfit(prices):
    profit = 0
    for i in range(1, len(prices)):
        profit += max(prices[i] - prices[i - 1], 0)
    return profit
```

",,
"```python
from collections import deque
from typing import List

def find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:
    if n == 1:
        return [0]

    adj_list = [set() for _ in range(n)]
    for a, b in edges:
        adj_list[a].add(b)
        adj_list[b].add(a)

    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)

    while n > 2:
        leaves_size = len(leaves)
        n -= leaves_size
        for _ in range(leaves_size):
            leaf = leaves.popleft()
            for neighbor in adj_list[leaf]:
                adj_list[neighbor].remove(leaf)
                if len(adj_list[neighbor]) == 1:
                    leaves.append(neighbor)

    return list(leaves)
```

",,
"```python
def multiply(mat1, mat2):
    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])
    result = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(k):
            if mat1[i][j] != 0:
                for l in range(n):
                    result[i][l] += mat1[i][j] * mat2[j][l]
    return result
```

",,
"```python
def maxCoins(nums):
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n for _ in range(n)]

    for length in range(1, n - 1):
        for left in range(1, n - length):
            right = left + length - 1
            for i in range(left, right + 1):
                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])

    return dp[1][n - 2]
```

",,
"```python
def nthSuperUglyNumber(n, primes):
    ugly = [0] * n
    ugly[0] = 1
    indices = [0] * len(primes)

    for i in range(1, n):
        min_val = float(""inf"")

        for j in range(len(primes)):
            min_val = min(min_val, ugly[indices[j]] * primes[j])

        ugly[i] = min_val

        for j in range(len(primes)):
            if ugly[i] == ugly[indices[j]] * primes[j]:
                indices[j] += 1

    return ugly[-1]
```

",,
"```python
from collections import defaultdict, deque
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def verticalOrder(root: Optional[TreeNode]) -> List[List[int]]:
    if not root: return []

    column_table = defaultdict(list)
    q = deque([(root, 0)])

    while q:
        cur_node, column = q.popleft()

        if cur_node:
            column_table[column].append(cur_node.val)
            q.append((cur_node.left, column - 1))
            q.append((cur_node.right, column + 1))

    return [column_table[key] for key in sorted(column_table)]
```

",,
"```python
def countSmaller(nums):
    def merge_sort(indices):
        if len(indices) <= 1:
            return indices
        mid = len(indices) // 2
        left = merge_sort(indices[:mid])
        right = merge_sort(indices[mid:])
        return merge(left, right)

    def merge(left, right):
        merged, count = [], 0
        while left and right:
            if nums[left[0]] <= nums[right[0]]:
                counts[left[0]] += count
                merged.append(left.pop(0))
            else:
                count += len(left)
                merged.append(right.pop(0))
        for i in left:
            counts[i] += count
        return merged + left + right

    counts = [0] * len(nums)
    merge_sort(list(range(len(nums))))
    return counts
```

",,
"```python
def removeDuplicateLetters(s):
    count = [0] * 256
    visited = [False] * 256
    st = []

    for ch in s:
        count[ord(ch)] += 1

    for ch in s:
        count[ord(ch)] -= 1
        if visited[ord(ch)]:
            continue
        while st and ch < st[-1] and count[ord(st[-1])] > 0:
            visited[ord(st.pop())] = False
        st.append(ch)
        visited[ord(ch)] = True

    return """".join(st)   
```

",,
"```python
from collections import deque

def shortestDistance(grid: list[list[int]]) -> int:
    m, n = len(grid), len(grid[0])

    total_count = [[0] * n for _ in range(m)]
    dist_sum = [[0] * n for _ in range(m)]
    house_count = 0

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                house_count += 1
                q = deque([(i, j)])
                visited = [[False] * n for _ in range(m)]
                level = 1
                while q:
                    for _ in range(len(q)):
                        x, y = q.popleft()
                        for dx, dy in dirs:
                            x_new, y_new = x + dx, y + dy
                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:
                                visited[x_new][y_new] = True
                                q.append((x_new, y_new))
                                dist_sum[x_new][y_new] += level
                                total_count[x_new][y_new] += 1
                    level += 1

    min_dist = float(""inf"")
    for i in range(m):
        for j in range(n):
            if total_count[i][j] == house_count:
                min_dist = min(min_dist, dist_sum[i][j])

    return -1 if min_dist == float(""inf"") else min_dist
```


",,
"```python
def maxProduct(words):
    n = len(words)
    mask = [0] * n
    for i, word in enumerate(words):
        for c in word:
            mask[i] |= (1 << (ord(c) - ord('a')))
    
    max_product = 0
    for i in range(n):
        for j in range(i + 1, n):
            if (mask[i] & mask[j]) == 0:
                max_product = max(max_product, len(words[i]) * len(words[j]))
    
    return max_product
```


",,
"```python
def bulbSwitch(n):
    return int(n**0.5)
```

",,
"```python
def generateAbbreviations(word):
    if not word:
        return [""""]
    res = []
    for i in range(len(word) + 1):
        for item in generateAbbreviations(word[i+1:]):
            if i == 0 or not item or not item[0].isdigit():
                res.append(word[:i+1] + item)
            if item and item[0].isdigit():
                res.append(word[:i] + '1' + item)
    return res
```

",,
"
```javascript
function maxNumber(nums1, nums2, k) {
    function maxArray(nums, k) {
        let ans = [];
        for (let i = 0; i < nums.length; i++) {
            while (nums.length - i > k - ans.length && ans.length && ans[ans.length - 1] < nums[i])
                ans.pop();
            if (ans.length < k) ans.push(nums[i]);
        }
        return ans;
    }

    function merge(nums1, nums2) {
        let ans = [], i = 0, j = 0;
        while (i < nums1.length || j < nums2.length)
            ans.push((nums1.slice(i).join('') >= nums2.slice(j).join('') ? nums1[i++] : nums2[j++]));
        return ans;
    }

    let result = [];
    for (let i = Math.max(0, k - nums2.length); i <= k && i <= nums1.length; i++) {
        const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i));
        if (candidate.join('') > result.join('')) result = candidate;
    }
    return result;
}
```


",,
"```python
def coinChange(coins, amount):
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] <= amount else -1
```

",,
"```python
def countComponents(n, edges):
    adj_list = [[] for _ in range(n)]
    for edge in edges:
        adj_list[edge[0]].append(edge[1])
        adj_list[edge[1]].append(edge[0])

    visited = [False] * n
    connected_components = 0

    def dfs(node):
        visited[node] = True
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                dfs(neighbor)

    for i in range(n):
        if not visited[i]:
            dfs(i)
            connected_components += 1

    return connected_components
```


",,
"```python
def wiggleSort(nums):
    nums.sort()
    for i in range(1, len(nums) - 1, 2):
        nums[i], nums[i + 1] = nums[i + 1], nums[i]
```


",,
"```python
def maxSubArrayLen(nums: List[int], k: int) -> int:
    sum_index = {}
    maxLength = sum = 0
    for i, num in enumerate(nums):
        sum += num
        if sum == k:
            maxLength = i + 1
        if sum - k in sum_index:
            maxLength = max(maxLength, i - sum_index[sum - k])
        if sum not in sum_index:
            sum_index[sum] = i
    return maxLength
```


",,
"```python
def is_power_of_three(n: int) -> bool:
    if n < 1:
        return False
    
    while n % 3 == 0:
        n //= 3
    
    return n == 1
```

",,
"```python
def countRangeSum(nums, lower, upper):
    sums = [0] * (len(nums) + 1)
    for i in range(len(nums)):
        sums[i + 1] = sums[i] + nums[i]

    def mergeSort(start, end):
        if start == end:
            return 0
        mid = start + (end - start) // 2
        count = mergeSort(start, mid) + mergeSort(mid + 1, end)

        j, k = mid + 1, mid + 1
        for i in range(start, mid + 1):
            while j <= end and sums[j] - sums[i] < lower: j += 1
            while k <= end and sums[k] - sums[i] <= upper: k += 1
            count += k - j

        sums[start:end + 1] = sorted(sums[start:end + 1])
        return count

    return mergeSort(0, len(nums))
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def odd_even_list(head: ListNode) -> ListNode:
    if not head:
        return None
    odd, even, even_head = head, head.next, head.next
    while even and even.next:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    odd.next = even_head
    return head
```

",,
"```python
dx = (0, 0, 1, -1)
dy = (1, -1, 0, 0)

def dfs(matrix, memo, i, j):
    if memo[i][j] != 0:
        return memo[i][j]
    
    max_len = 0
    for k in range(4):
        ni, nj = i + dx[k], j + dy[k]
        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):
            max_len = max(max_len, dfs(matrix, memo, ni, nj))
    
    memo[i][j] = max_len + 1
    return memo[i][j]

def longest_increasing_path(matrix):
    m, n = len(matrix), len(matrix[0])
    
    memo = [[0] * n for _ in range(m)]
    
    ans = 0
    for i in range(m):
        for j in range(n):
            ans = max(ans, dfs(matrix, memo, i, j))
    
    return ans
```


",,
"```python
def minPatches(nums, n):
    max_sum = 0
    patches = 0
    i = 0

    while max_sum < n:
        if i < len(nums) and nums[i] <= max_sum + 1:
            max_sum += nums[i]
            i += 1
        else:
            max_sum += max_sum + 1
            patches += 1

    return patches
```


",,
"```python
def is_valid_serialization(preorder: str) -> bool:
    nodes = preorder.split(',')
    node_count = 1

    for node in nodes:
        node_count -= 1
        if node_count < 0:
            return False
        if node != '#':
            node_count += 2

    return node_count == 0
```

",,
"```python
from collections import defaultdict

def findItinerary(tickets):
    flights = defaultdict(list)
    itinerary = []

    for ticket in tickets:
        flights[ticket[0]].append(ticket[1])
        flights[ticket[0]].sort(reverse=True)

    def dfs(airport):
        while flights[airport]:
            dfs(flights[airport].pop())
        itinerary.append(airport)

    dfs(""JFK"")
    
    return itinerary[::-1]
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def largestBSTSubtree(root: TreeNode) -> int:
    def largestBSTUtil(root):
        if not root:
            return True, 0, float('inf'), float('-inf')
        
        left = largestBSTUtil(root.left)
        right = largestBSTUtil(root.right)
        
        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:
            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])
            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])
        
        return False, -1, float('inf'), float('-inf')
    
    largestBST = [0]
    largestBSTUtil(root)
    
    return largestBST[0]
```

",,
"```python
def findTriplets(nums: List[int]) -> bool:
    first = float('inf')
    second = float('inf')

    for num in nums:
        if num <= first:
            first = num
        elif num <= second:
            second = num
        else:
            return True
    return False
```

",,
"```python
def is_path_crossing(distance):
    visited = set([(0, 0)])
    x, y = 0, 0
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    
    for i, d in enumerate(distance):
        dx, dy = directions[i % 4]
        for _ in range(d):
            x += dx
            y += dy
            if (x, y) in visited:
                return True
            visited.add((x, y))
    return False
```


",,
"```python
def palindrome_pairs(words):
    def is_palindrome(s):
        return s == s[::-1]

    result = []
    for i in range(len(words)):
        for j in range(len(words)):
            if i == j:
                continue
            concat = words[i] + words[j]
            if is_palindrome(concat):
                result.append([i, j])
    return result
```

",,
"```python
def rob(self, root: TreeNode) -> int:
    def rob_helper(node):
        if not node:
            return 0, 0

        left_with_node, left_without_node = rob_helper(node.left)
        right_with_node, right_without_node = rob_helper(node.right)

        with_node = node.val + left_without_node + right_without_node
        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)
        return with_node, without_node

    return max(rob_helper(root))
```

",,
"```python
def countBits(n):
    ans = [0] * (n + 1)
    for i in range(1, n + 1):
        ans[i] = ans[i & (i - 1)] + 1
    return ans
```

",,
"```python
from typing import List, Union

def depth_sum(nested_list: List[Union[int, List]]) -> int:
    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:
        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)

    return depth_sum_helper(nested_list, 1)
```


",,
"```python
def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    char_count = {}
    left = 0
    max_length = 0

    for right, char in enumerate(s):
        char_count[char] = char_count.get(char, 0) + 1

        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1

        max_length = max(max_length, right - left + 1)

    return max_length
```

",,
"```python
class NestedIterator:
    def __init__(self, nestedList):
        def flatten(nestedList, flatList):
            for item in nestedList:
                if isinstance(item, int):
                    flatList.append(item)
                else:
                    flatten(item, flatList)
        self.flatList = []
        flatten(nestedList, self.flatList)
        self.index = 0

    def next(self):
        result = self.flatList[self.index]
        self.index += 1
        return result

    def hasNext(self):
        return self.index < len(self.flatList)
```

",,
"```python
def isPowerOfFour(n: int) -> bool:
    if n <= 0:
        return False
    while n % 4 == 0:
        n //= 4
    return n == 1
```

",,
"```python
def integer_break(n):
    if n <= 3:
        return n - 1
    product = 1
    while n > 4:
        product *= 3
        n -= 3
    return product * n
```

",,
"```python
def reverseString(s: List[str]) -> None:
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left, right = left + 1, right - 1
```

",,
"```python
def reverseVowels(s: str) -> str:
    vowels = set('aeiouAEIOU')
    s_list = list(s)
    i, j = 0, len(s) - 1
    while i < j:
        if s_list[i] not in vowels:
            i += 1
        elif s_list[j] not in vowels:
            j -= 1
        else:
            s_list[i], s_list[j] = s_list[j], s_list[i]
            i += 1
            j -= 1
    return ''.join(s_list)
```

",,
"```python
from collections import deque

class MovingAverage:
    def __init__(self, size: int):
        self.queue = deque()
        self.maxSize = size
        self.sum = 0.0

    def next(self, val: int) -> float:
        if len(self.queue) == self.maxSize:
            self.sum -= self.queue.popleft()
        self.queue.append(val)
        self.sum += val
        return self.sum / len(self.queue)
```

",,
"```python
from heapq import heappush, heappop
from collections import Counter

def k_most_frequent(nums, k):
    frequency = Counter(nums)
    min_heap = []

    for num, freq in frequency.items():
        heappush(min_heap, (freq, num))
        if len(min_heap) > k:
            heappop(min_heap)

    return [heappop(min_heap)[1] for _ in range(k)]
```


",,
"```python
class TicTacToe:
    def __init__(self, n: int):
        self.rows, self.cols = [0] * n, [0] * n
        self.diagonal = self.anti_diagonal = self.n = n

    def move(self, row: int, col: int, player: int) -> int:
        to_add = 1 if player == 1 else -1

        self.rows[row] += to_add
        self.cols[col] += to_add

        if row == col:
            self.diagonal += to_add
        if row + col == self.n - 1:
            self.anti_diagonal += to_add

        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n
                or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n):
            return player

        return 0
```


",,
"```python
def intersection(nums1, nums2):
    set1 = set(nums1)
    result = set1.intersection(nums2)
    return list(result)
```

",,
"```python
def intersect(nums1, nums2):
    count_map = {}
    result = []
    
    for num in nums1:
        count_map[num] = count_map.get(num, 0) + 1
    
    for num in nums2:
        if count_map.get(num, 0) > 0:
            result.append(num)
            count_map[num] -= 1

    return result
```


",,
"```python
def numberOfPatterns(m: int, n: int) -> int:
    def dfs(curr, remaining):
        if remaining < 0:
            return 0
        if remaining == 0:
            return 1

        visited[curr] = True
        cnt = 0
        for next in range(1, 10):
            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):
                cnt += dfs(next, remaining - 1)
        visited[curr] = False

        return cnt

    jumps = [[0] * 10 for _ in range(10)]
    jumps[1][3] = jumps[3][1] = 2
    jumps[1][7] = jumps[7][1] = 4
    jumps[3][9] = jumps[9][3] = 6
    jumps[7][9] = jumps[9][7] = 8
    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5

    visited = [False] * 10

    cnt = 0
    for i in range(m, n + 1):
        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9
        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8
        cnt += dfs(5, i - 1)      # 5

    return cnt
```


",,
"```python
from collections import OrderedDict

class SummaryRanges:

    def __init__(self):
        self.intervals = OrderedDict()

    def addNum(self, val: int) -> None:
        if not self.intervals or next(iter(self.intervals)) > val + 1:
            self.intervals[val] = val
        else:
            keys = list(self.intervals.keys())
            idx = bisect_left(keys, val)
            if idx > 0 and keys[idx - 1] <= val <= self.intervals[keys[idx - 1]]:
                pass
            elif idx < len(keys) and val + 1 == keys[idx]:
                self.intervals[val] = self.intervals[keys[idx]]
                del self.intervals[keys[idx]]
            else:
                self.intervals[val] = val

    def getIntervals(self):
        return list(self.intervals.items())
```


",,
"```python
from collections import deque

class SnakeGame:
    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.width = width
        self.height = height
        self.food = food
        self.pos = 0
        self.score = 0
        self.snake = deque([(0, 0)])
        self.occupied = {(0, 0)}
        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}
        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}

    def move(self, direction: str) -> int:
        new_x = self.snake[-1][0] + self.dx[direction]
        new_y = self.snake[-1][1] + self.dy[direction]

        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:
            return -1

        new_head = (new_x, new_y)
        tail = self.snake.popleft()

        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):
            self.score += 1
            self.pos += 1
        else:
            self.occupied.remove(tail)

        if new_head in self.occupied:
            return -1

        self.snake.append(new_head)
        self.occupied.add(new_head)
        return self.score
```

",,
"```python
from bisect import bisect_left

def max_envelopes(envelopes):
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    dp = []
    
    for _, h in envelopes:
        idx = bisect_left(dp, h)
        if idx == len(dp):
            dp.append(h)
        else:
            dp[idx] = h

    return len(dp)
```

",,
"```python
from collections import defaultdict
from typing import List

class Twitter:

    class Tweet:
        def __init__(self, time, tweetId):
            self.time = time
            self.tweetId = tweetId

    def __init__(self):
        self.tweets = defaultdict(list)
        self.following = defaultdict(set)
        self.timeStamp = 0

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[userId].append(self.Tweet(self.timeStamp, tweetId))
        self.timeStamp += 1

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = self.tweets[userId][:]
        for user in self.following[userId]:
            feed.extend(self.tweets[user])

        feed.sort(key=lambda x: x.time, reverse=True)
        return [t.tweetId for t in feed[:10]]

    def follow(self, followerId: int, followeeId: int) -> None:
        if followerId != followeeId:
            self.following[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.following[followerId].discard(followeeId)
```


",,
"```python
def isReflected(points):
    min_x = min(point[0] for point in points)
    max_x = max(point[0] for point in points)
    point_set = {(point[0], point[1]) for point in points}
    
    sum_x = min_x + max_x
    for point in points:
        if (sum_x - point[0], point[1]) not in point_set:
            return False

    return True
```

",,
"```python
def countNumbersWithUniqueDigits(n):
    if n == 0:
        return 1
    
    total = 10
    unique_digits = 9
    current_available_digits = 9
    
    while n > 1 and current_available_digits > 0:
        unique_digits *= current_available_digits
        total += unique_digits
        current_available_digits -= 1
        n -= 1
        
    return total
```


",,
"```python
import heapq
from collections import Counter

def rearrange_string(s, k):
    if k == 0:
        return s

    counter = Counter(s)
    max_heap = [(-count, char) for char, count in counter.items()]
    heapq.heapify(max_heap)

    result = []
    while max_heap:
        temp = []

        for _ in range(k):
            if not max_heap:
                break

            count, char = heapq.heappop(max_heap)
            result.append(char)

            if count + 1 < 0:
                temp.append((count + 1, char))

        for item in temp:
            heapq.heappush(max_heap, item)

        if not max_heap:
            break

        if len(result) < len(s):
            result.extend([' '] * (k - len(temp)))

    if len(result) < len(s):
        return """"
    return """".join(result)
```


",,
"```python
class Logger:
    def __init__(self):
        self.message_timestamps = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10:
            self.message_timestamps[message] = timestamp
            return True
        return False
```

",,
"```python
def sort_transformed_array(nums, a, b, c):
    result = [0] * len(nums)
    i, j = 0, len(nums) - 1
    index = len(nums) - 1 if a >= 0 else 0
    
    while i <= j:
        left = nums[i] * nums[i] * a + nums[i] * b + c
        right = nums[j] * nums[j] * a + nums[j] * b + c
        
        if a >= 0:
            if left >= right:
                result[index] = left
                index -= 1
                i += 1
            else:
                result[index] = right
                index -= 1
                j -= 1
        else:
            if left <= right:
                result[index] = left
                index += 1
                i += 1
            else:
                result[index] = right
                index += 1
                j -= 1
    return result
```

",,
"```python
def maxKilledEnemies(grid):
    if not grid: return 0
    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0
    colhits = [0] * n
    for i in range(m):
        for j in range(n):
            if j == 0 or grid[i][j - 1] == 'W':
                rowhits = 0
                k = j
                while k < n and grid[i][k] != 'W':
                    rowhits += grid[i][k] == 'E'
                    k += 1
            if i == 0 or grid[i - 1][j] == 'W':
                colhits[j] = 0
                k = i
                while k < m and grid[k][j] != 'W':
                    colhits[j] += grid[k][j] == 'E'
                    k += 1
            if grid[i][j] == '0':
                result = max(result, rowhits + colhits[j])
    return result
```

",,
"```python
from collections import deque

class HitCounter:

    def __init__(self):
        self.queue = deque()

    def hit(self, timestamp: int) -> None:
        self.queue.append(timestamp)

    def getHits(self, timestamp: int) -> int:
        while self.queue and self.queue[0] <= timestamp - 300:
            self.queue.popleft()
        return len(self.queue)
```

",,
"```python
from sortedcontainers import SortedList

def maxSumSubmatrix(matrix, k):
    rows = len(matrix)
    cols = len(matrix[0])
    max_sum = float('-inf')

    for l in range(cols):
        sums = [0] * rows
        for r in range(l, cols):
            for i in range(rows):
                sums[i] += matrix[i][r]

            sorted_sums = SortedList()
            sorted_sums.add(0)
            curr_sum = 0
            for sum in sums:
                curr_sum += sum
                it = sorted_sums.bisect_left(curr_sum - k)
                if it != len(sorted_sums):
                    max_sum = max(max_sum, curr_sum - sorted_sums[it])
                sorted_sums.add(curr_sum)

    return max_sum
```


",,
"```python
from typing import List, Union

NestedInteger = Union[int, List[Union[int, ""NestedInteger""]]]

def depthSumInverse(nestedList: List[NestedInteger]) -> int:
    max_depth = max_depth_helper(nestedList)
    return sum_helper(nestedList, max_depth)

def max_depth_helper(nested_list: List[NestedInteger]) -> int:
    depth = 1
    for nested in nested_list:
        if isinstance(nested, list):
            depth = max(depth, 1 + max_depth_helper(nested))
    return depth

def sum_helper(nested_list: List[NestedInteger], depth: int) -> int:
    sum = 0
    for nested in nested_list:
        if isinstance(nested, int):
            sum += depth * nested
        else:
            sum += sum_helper(nested, depth - 1)
    return sum
```

",,
"```python
def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):
    if targetCapacity > jug1Capacity + jug2Capacity:
        return False
    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:
        return True
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_leaves(node, result, level):
    if not node:
        return -1
    left_level = find_leaves(node.left, result, level + 1)
    right_level = find_leaves(node.right, result, level + 1)
    level = max(left_level, right_level) + 1
    if len(result) <= level:
        result.append([])
    result[level].append(node.val)
    return level

def findLeaves(root):
    result = []
    find_leaves(root, result, 0)
    return result
```

",,
"```python
def is_perfect_square(num: int) -> bool:
    if num < 2:
        return True
    left, right = 2, num // 2
    while left <= right:
        mid = left + (right - left) // 2
        square = mid * mid
        if square == num:
            return True
        if square > num:
            right = mid - 1
        else:
            left = mid + 1
    return False
```

",,
"```python
def largestDivisibleSubset(nums):
    nums.sort()
    n = len(nums)
    count = [1] * n
    prev = [-1] * n

    max_idx = 0
    for i in range(1, n):
        for j in range(i):
            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:
                count[i] = count[j] + 1
                prev[i] = j
        if count[max_idx] < count[i]:
            max_idx = i

    res = []
    i = max_idx
    while i >= 0:
        res.append(nums[i])
        i = prev[i]

    return res
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def plusOne(head: ListNode) -> ListNode:
    def plusOneDfs(node):
        if not node:
            return 1
        carry = plusOneDfs(node.next)
        if carry + node.val == 10:
            node.val = 0
            return 1
        else:
            node.val += carry
            return 0

    if not head:
        return head
    carry = plusOneDfs(head)
    if carry == 1:
        new_head = ListNode(1)
        new_head.next = head
        return new_head
    return head
```


",,
"```python
def get_updated_array(length, updates):
    arr = [0] * length

    for start, end, inc in updates:
        arr[start] += inc
        if end + 1 < length:
            arr[end + 1] -= inc

    for i in range(1, length):
        arr[i] += arr[i - 1]

    return arr
```

",,
"```python
def add(a, b):
    MAX = 0x7FFFFFFF
    MASK = 0xFFFFFFFF
    while b:
        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK
    return a if a <= MAX else ~(a ^ MASK)
```

",,
"```python
def powmod(a, b):
    if b == 0:
        return 1
    res = powmod(a, b // 2)
    return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337

def superPow(a, b):
    n = 0
    for bi in b:
        n = (n * 10 + bi) % 1140
    return powmod(a % 1337, n + 1140)
```

",,
"```python
import heapq

def kSmallestPairs(nums1, nums2, k):
    if not nums1 or not nums2:
        return []
    
    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]
    heapq.heapify(heap)
    result = []

    while k > 0 and heap:
        s, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        if j + 1 < len(nums2):
            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1

    return result
```

",,
"```python
def guessNumber(n):
    low, high = 1, n
    while low <= high:
        mid = low + (high - low) // 2
        result = guess(mid)
        if result == 0:
            return mid
        elif result < 0:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

",,
"```python
def getMoneyAmount(n: int) -> int:
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n - 1, 0, -1):
        for j in range(i + 1, n + 1):
            min_cost = float(""inf"")
            for k in range(i, j):
                cost = k + max(dp[i][k - 1], dp[k + 1][j])
                min_cost = min(min_cost, cost)
            dp[i][j] = min_cost
    return dp[1][n]
```

",,
"```python
def wiggleMaxLength(nums):
    if len(nums) < 2:
        return len(nums)

    up, down = 1, 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            up = down + 1
        elif nums[i] < nums[i - 1]:
            down = up + 1
    return max(up, down)
```

",,
"```python
def combination_sum(nums, target):
    dp = [0] * (target + 1)
    dp[0] = 1

    for num in nums:
        for i in range(num, target + 1):
            dp[i] += dp[i - num]

    return dp[target]
```


",,
"```python
import heapq

def kthSmallest(matrix, k):
    n = len(matrix)
    min_heap = []

    for i in range(n):
        heapq.heappush(min_heap, (matrix[i][0], i, 0))

    while k > 1:
        val, row, col = heapq.heappop(min_heap)

        if col + 1 < n:
            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))

        k -= 1

    return min_heap[0][0]
```

",,
"```python
from collections import deque

class PhoneDirectory:
    def __init__(self, maxNumbers: int):
        self.available = [True] * maxNumbers
        self.released = deque()
    
    def get(self) -> int:
        if self.released:
            number = self.released.popleft()
            self.available[number] = False
            return number
        for i in range(len(self.available)):
            if self.available[i]:
                self.available[i] = False
                return i
        return -1
    
    def check(self, number: int) -> bool:
        return self.available[number]
    
    def release(self, number: int) -> None:
        if not self.available[number]:
            self.available[number] = True
            self.released.append(number)
```


",,
"```python
import random

class RandomizedSet:
    def __init__(self):
        self.index_map = {}
        self.nums = []

    def insert(self, val: int) -> bool:
        if val in self.index_map:
            return False

        self.index_map[val] = len(self.nums)
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.index_map:
            return False

        last = self.nums[-1]
        self.index_map[last] = self.index_map[val]
        self.nums[self.index_map[val]] = last

        self.nums.pop()
        del self.index_map[val]
        return True

    def getRandom(self) -> int:
        return self.nums[random.randint(0, len(self.nums) - 1)]
```

",,
"```python
import random
from collections import defaultdict

class RandomizedCollection:
    def __init__(self):
        self.indices = defaultdict(set)
        self.nums = []

    def insert(self, val):
        self.nums.append(val)
        self.indices[val].add(len(self.nums) - 1)
        return len(self.indices[val]) == 1

    def remove(self, val):
        if not self.indices[val]:
            return False

        idx = self.indices[val].pop()
        if idx < len(self.nums) - 1:
            last = self.nums[-1]
            self.nums[idx] = last
            self.indices[last].remove(len(self.nums) - 1)
            self.indices[last].add(idx)
        self.nums.pop()
        return True

    def getRandom(self):
        return self.nums[random.randint(0, len(self.nums) - 1)]
```


",,
"```python
import random

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def __init__(self, head: ListNode):
        self.head = head

    def getRandom(self) -> int:
        current, result = self.head, 0
        for i, node in enumerate(self.iterate_nodes(current)):
            if random.randint(0, i) == 0:
                result = node.val
        return result

    def iterate_nodes(self, current):
        while current:
            yield current
            current = current.next
```

",,
"```python
def can_construct(ransom_note, magazine):
    letter_count = {}
    
    for c in magazine:
        letter_count[c] = letter_count.get(c, 0) + 1
        
    for c in ransom_note:
        if c not in letter_count or letter_count[c] == 0:
            return False
        letter_count[c] -= 1
        
    return True
```

",,
"```python
import random

class Solution:
    def __init__(self, nums):
        self.original = nums

    def reset(self):
        return self.original

    def shuffle(self):
        shuffled = self.original[:]
        for i in range(len(shuffled) - 1, 0, -1):
            j = random.randint(0, i)
            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        return shuffled
```


",,
"```python
class NestedInteger:
    def __init__(self, value=None):
        pass

    def add(self, ni):
        pass

def deserialize(s: str) -> NestedInteger:
    if s[0] != '[':
        return NestedInteger(int(s))

    stack = []
    curr, start = None, 0

    for i, c in enumerate(s):
        if c == '[':
            if curr:
                stack.append(curr)
            curr = NestedInteger()
            start = i + 1
        elif c == ',' or c == ']':
            if i > start:
                curr.add(NestedInteger(int(s[start:i])))
            start = i + 1

            if c == ']' and stack:
                popped = stack.pop()
                popped.add(curr)
                curr = popped

    return curr
```

",,
"```python
def lexicographical_order_helper(current, n, result):
    if current > n:
        return

    result.append(current)
    for i in range(10):
        lexicographical_order_helper(current * 10 + i, n, result)

def lexical_order(n):
    result = []
    for i in range(1, 10):
        lexicographical_order_helper(i, n, result)
    return result
```

",,
"```python
def firstUniqChar(s):
    char_count = {}
    for c in s:
        char_count[c] = char_count.get(c, 0) + 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1
```


",,
"```python
def length_longest_path(input: str) -> int:
    dir_length_stack = []
    max_file_length = 0
    lines = input.split('\n')

    for line in lines:
        level = line.count('\t')
        line = line.lstrip('\t')

        while len(dir_length_stack) > level:
            dir_length_stack.pop()

        if dir_length_stack:
            length = dir_length_stack[-1] + len(line) + 1
        else:
            length = len(line)
        dir_length_stack.append(length)

        if '.' in line:
            max_file_length = max(max_file_length, length)
            
    return max_file_length
```


",,
"```python
def findTheDifference(s: str, t: str) -> str:
    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))
```

",,
"```python
def last_remaining(n: int) -> int:
    direction = True
    head = 1
    remaining = n
    step = 1

    while remaining > 1:
        if direction or remaining % 2 == 1:
            head += step
        remaining //= 2
        step *= 2
        direction = not direction

    return head
```

",,
"```python
def isRectangleCover(rectangles):
    area = 0
    points = set()
    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')

    for rect in rectangles:
        lx, ly = min(lx, rect[0]), min(ly, rect[1])
        rx, ry = max(rx, rect[2]), max(ry, rect[3])

        area += (rect[2] - rect[0]) * (rect[3] - rect[1])

        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])

        points ^= {p1, p2, p3, p4}

    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \
           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points
```

",,
"```python
def is_subsequence(s, t):
    si, ti = 0, 0

    while si < len(s) and ti < len(t):
        if s[si] == t[ti]:
            si += 1
        ti += 1

    return si == len(s)
```


",,
"```python
def validUtf8(data):
    count = 0
    for byte in data:
        if count == 0:
            if byte >> 5 == 0b110:
                count = 1
            elif byte >> 4 == 0b1110:
                count = 2
            elif byte >> 3 == 0b11110:
                count = 3
            elif byte >> 7:
                return False
        else:
            if byte >> 6 != 0b10:
                return False
            count -= 1
    return count == 0
```

",,
"```python
def decodeString(s):
    counts = []
    results = []
    current = """"
    ptr = 0

    while ptr < len(s):
        if s[ptr].isdigit():
            count = 0
            while s[ptr].isdigit():
                count = count * 10 + int(s[ptr])
                ptr += 1
            counts.append(count)
        elif s[ptr] == '[':
            results.append(current)
            current = """"
            ptr += 1
        elif s[ptr] == ']':
            prev = results.pop()
            count = counts.pop()
            current = prev + current * count
            ptr += 1
        else:
            current += s[ptr]
            ptr += 1

    return current
```

",,
"```python
def longestSubstring(s: str, k: int) -> int:
    if not s or k <= 0:
        return 0

    char_count = {}
    for ch in s:
        char_count[ch] = char_count.get(ch, 0) + 1

    for char, count in char_count.items():
        if count < k:
            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))
    return len(s)
```

",,
"```python
def maxRotateFunction(nums):
    n = len(nums)
    total_sum = sum(nums)
    f = sum(i * num for i, num in enumerate(nums))

    max_f = f
    for i in range(1, n):
        f += total_sum - n * nums[-i]
        max_f = max(max_f, f)

    return max_f
```


",,
"```python
def min_operations(n):
    steps = 0
    while n > 1:
        n = n // 2 if n % 2 == 0 else n - 1
        steps += 1
    return steps
```

",,
"```python
import random

class Solution:

    def __init__(self, nums):
        self.nums = nums

    def pick(self, target):
        count, res = 0, 0
        for i, num in enumerate(self.nums):
            if num == target:
                count += 1
                if random.randint(0, count - 1) == 0:
                    res = i
        return res
```

",,
"```python
from collections import defaultdict

def dfs(s1, s2, graph):
    if s1 not in graph or s2 not in graph:
        return -1.0
    if s1 == s2:
        return 1.0
    
    for neighbor, weight in graph[s1]:
        if neighbor not in visited:
            visited.add(neighbor)
            temp = dfs(neighbor, s2, graph)
            if temp > 0:
                return weight * temp
    return -1.0

def calcEquation(equations, values, queries):
    graph = defaultdict(list)
    for (s1, s2), value in zip(equations, values):
        graph[s1].append((s2, value))
        graph[s2].append((s1, 1 / value))
    
    ans = []
    for s1, s2 in queries:
        visited = set()
        ans.append(dfs(s1, s2, graph))
    return ans
```

",,
"```python
def findNthDigit(n):
    size = 1
    length = 9
    start = 1

    while n > length * size:
        n -= length * size
        size += 1
        length *= 10
        start *= 10

    start += (n - 1) // size
    s = str(start)
    return int(s[(n - 1) % size])
```

",,
"```python
def readBinaryWatch(turnedOn: int):
    def count_bits(n):
        return bin(n).count('1')

    times = []
    for h in range(12):
        for m in range(60):
            if count_bits(h) + count_bits(m) == turnedOn:
                times.append(f""{h}:{m:02d}"")
    return times
```

",,
"```python
def remove_k_digits(num, k):
    stack = []
    for c in num:
        while k > 0 and stack and stack[-1] > c:
            stack.pop()
            k -= 1
        stack.append(c)
    while k > 0:
        stack.pop()
        k -= 1
    return ''.join(stack).lstrip('0') or '0'
```

",,
"```python
def can_cross(stones):
    dp = {stone: set() for stone in stones}
    dp[0].add(0)

    for stone in stones:
        for k in dp[stone]:
            for jump in (k - 1, k, k + 1):
                if jump > 0 and stone + jump in dp:
                    dp[stone + jump].add(jump)

    return bool(dp[stones[-1]])
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sum_of_left_leaves(root):
    if not root:
        return 0
    left_sum = 0
    if root.left and not root.left.left and not root.left.right:
        left_sum += root.left.val
    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)
```

",,
"```python
def to_hex(num: int) -> str:
    if num == 0:
        return '0'
    hex_str = ''
    hex_digits = '0123456789abcdef'
    n = num & 0xffffffff
    while n:
        hex_str = hex_digits[n & 0xf] + hex_str
        n >>= 4
    return hex_str
```

",,
"```python
from typing import List

def reconstructQueue(people: List[List[int]]) -> List[List[int]]:
    people.sort(key=lambda x: (-x[0], x[1]))

    result = []
    for p in people:
        result.insert(p[1], p)
    return result
```


",,
"```python
import heapq

def trapRainWater(heightMap):
    m, n = len(heightMap), len(heightMap[0])
    pq = []
    visited = [[False] * n for _ in range(m)]

    for i in range(m):
        heapq.heappush(pq, (heightMap[i][0], i, 0))
        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))
        visited[i][0] = visited[i][n - 1] = True

    for i in range(1, n - 1):
        heapq.heappush(pq, (heightMap[0][i], 0, i))
        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))
        visited[0][i] = visited[m - 1][i] = True

    water, maxHeight = 0, 0
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))

    while pq:
        h, r, c = heapq.heappop(pq)
        maxHeight = max(maxHeight, h)
        for dx, dy in dirs:
            x, y = r + dx, c + dy
            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:
                continue
            if heightMap[x][y] < maxHeight:
                water += maxHeight - heightMap[x][y]
            heapq.heappush(pq, (heightMap[x][y], x, y))
            visited[x][y] = True

    return water
```

",,
"```python
def validWordAbbreviation(word, abbr):
    i, j = 0, 0
    while i < len(word) and j < len(abbr):
        if abbr[j].isdigit():
            if abbr[j] == '0': return False  # leading zero
            num = 0
            while j < len(abbr) and abbr[j].isdigit():
                num = num * 10 + int(abbr[j])
                j += 1
            i += num
        else:
            if word[i] != abbr[j]: return False
            i, j = i + 1, j + 1
    return i == len(word) and j == len(abbr)
```

",,
"```python
def longestPalindrome(s: str) -> int:
    charCount = [0] * 128
    result = 0
    for c in s:
        charCount[ord(c)] += 1
    for count in charCount:
        result += count // 2 * 2
        if result % 2 == 0 and count % 2 == 1:
            result += 1
    return result
```

",,
"```python
def splitArray(nums, m):
    left, right = max(nums), sum(nums)

    while left < right:
        mid = (left + right) // 2
        count, cur_sum = 1, 0
        for num in nums:
            cur_sum += num
            if cur_sum > mid:
                cur_sum = num
                count += 1

        if count > m:
            left = mid + 1
        else:
            right = mid

    return left
```

",,
"```python
def abbreviate(s, k, i):
    if i == len(s):
        return str(k) if k > 0 else """"
    if k == 0:
        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else """")
    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else """")

def is_abbreviation(target, word):
    i, j = 0, 0
    while i < len(target) and j < len(word):
        if target[i] == word[j]:
            i, j = i + 1, j + 1
        elif target[i].isdigit():
            k = 0
            while i < len(target) and target[i].isdigit():
                k = k * 10 + int(target[i])
                i += 1
            j += k
        else:
            return False
    return i == len(target) and j == len(word)

def min_abbreviation(target, dictionary):
    ans = target
    for k in range(0, len(target) + 1):
        for i in range(0, len(target) - k + 1):
            current = abbreviate(target, k, i)
            if len(current) < len(ans):
                valid = True
                for word in dictionary:
                    if is_abbreviation(current, word):
                        valid = False
                        break
                if valid:
                    ans = current
    return ans
```


",,
"```python
def fizzBuzz(n):
    result = []
    for i in range(1, n + 1):
        if i % 15 == 0:
            result.append(""FizzBuzz"")
        elif i % 3 == 0:
            result.append(""Fizz"")
        elif i % 5 == 0:
            result.append(""Buzz"")
        else:
            result.append(str(i))
    return result
```

",,
"```python
def numberOfArithmeticSlices(nums):
    n = len(nums)
    count, cur = 0, 0
    for i in range(2, n):
        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
            cur += 1
            count += cur
        else:
            cur = 0
    return count
```

",,
"```python
def third_max(nums):
    top3 = set()
    for num in nums:
        top3.add(num)
        if len(top3) > 3:
            top3.remove(min(top3))
    return min(top3) if len(top3) == 3 else max(top3)
```

",,
"```python
def addStrings(num1: str, num2: str) -> str:
    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []

    while i >= 0 or j >= 0 or carry:
        sum = carry

        if i >= 0:
            sum += int(num1[i])
            i -= 1
        if j >= 0:
            sum += int(num2[j])
            j -= 1

        carry = sum // 10
        result.append(str(sum % 10))

    return ''.join(result[::-1])
```


",,
"```python
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    
    return dp[target]
```

",,
"```python
def pacificAtlantic(heights):
    def dfs(r, c, prev_height, visited):
        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):
            return
        if heights[r][c] >= prev_height and not visited[r][c]:
            visited[r][c] = True
            dfs(r - 1, c, heights[r][c], visited)
            dfs(r + 1, c, heights[r][c], visited)
            dfs(r, c - 1, heights[r][c], visited)
            dfs(r, c + 1, heights[r][c], visited)

    m, n = len(heights), len(heights[0])
    pacific = [[False] * n for _ in range(m)]
    atlantic = [[False] * n for _ in range(m)]

    for r in range(m):
        dfs(r, 0, -1, pacific)
        dfs(r, n - 1, -1, atlantic)
    for c in range(n):
        dfs(0, c, -1, pacific)
        dfs(m - 1, c, -1, atlantic)

    result = []
    for r in range(m):
        for c in range(n):
            if pacific[r][c] and atlantic[r][c]:
                result.append([r, c])
    return result
```


",,
"```python
def words_typing(sentence, rows, cols):
    total_chars = sum(len(word) + 1 for word in sentence)

    result = 0
    index = 0
    for _ in range(rows):
        remaining_cols = cols
        while True:
            word_len = len(sentence[index])
            if remaining_cols >= word_len:
                remaining_cols -= word_len + 1
                index = (index + 1) % len(sentence)
                if index == 0:
                    result += 1
            else:
                break

    return result
```

",,
"```python
def countBattleships(board):
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if (board[i][j] == 'X' and
                (i == 0 or board[i - 1][j] == '.') and
                (j == 0 or board[i][j - 1] == '.')):
                count += 1
    return count
```

",,
"```python
def strong_password(password):
    missing_lower = 1
    missing_upper = 1
    missing_digit = 1
    total = len(password)
    
    for c in password:
        if c.islower(): missing_lower = 0
        if c.isupper(): missing_upper = 0
        if c.isdigit(): missing_digit = 0
    
    missing = missing_lower + missing_upper + missing_digit
    if total < 6: return max(missing, 6 - total)
    if total > 20: return missing + total - 20

    return missing
```

",,
"```python
def findMaximumXOR(nums):
    max_xor = 0
    mask = 0

    for i in range(31, -1, -1):
        mask |= (1 << i)
        prefixes = {num & mask for num in nums}

        possible_max = max_xor | (1 << i)

        for prefix in prefixes:
            if prefix ^ possible_max in prefixes:
                max_xor = possible_max
                break

    return max_xor
```

",,
"```python
def valid_word_square(words):
    for i in range(len(words)):
        for j in range(len(words[i])):
            if j >= len(words) or i >= len(words[j]) or words[i][j] != words[j][i]:
                return False
    return True
```


",,
"```python
def find_digits_in_ascending_order(s):
    count = [0] * 10
    for c in s:
        if c == 'z': count[0] += 1
        if c == 'w': count[2] += 1
        if c == 'u': count[4] += 1
        if c == 'x': count[6] += 1
        if c == 'g': count[8] += 1
        if c == 'o': count[1] += 1
        if c == 'h': count[3] += 1
        if c == 'f': count[5] += 1
        if c == 's': count[7] += 1
        if c == 'i': count[9] += 1
    count[1] -= count[0] + count[2] + count[4]
    count[3] -= count[8]
    count[5] -= count[4]
    count[7] -= count[6]
    count[9] -= count[5] + count[6] + count[8]
    
    res = []
    for i in range(10):
        res.extend([str(i)] * count[i])
    return ''.join(res)
```


",,
"```python
def characterReplacement(s:str, k:int) -> int:
    n = len(s)
    left = 0
    right = 0
    maxFreq = 0
    result = 0
    freq = [0] * 26

    for right in range(n):
        freq[ord(s[right]) - ord('A')] += 1
        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])

        if right - left + 1 - maxFreq > k:
            freq[ord(s[left]) - ord('A')] -= 1
            left += 1

        result = max(result, right - left + 1)

    return result
```


",,
"```python
from collections import defaultdict

def wordSquares(words):
    def build(row, squares, word_lens):
        if row == word_lens:
            res.append(list(squares))
            return
        prefix = ''.join(squares[i][row] for i in range(row))
        for w in prefixes[prefix]:
            squares[row] = w
            build(row+1, squares, word_lens)

    if not words: return []
    res = []
    word_lens = len(words[0])
    
    prefixes = defaultdict(list)
    for word in words:
        for i in range(word_lens+1):
            prefixes[word[:i]].append(word)
            
    for word in words:
        build(1, [word] + [None]*(word_lens-1), word_lens)
        
    return res
```

",,
"```python
class Node:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:
            return None

        first = None
        last = None
        
        def inOrder(node):
            nonlocal first, last
            
            if not node:
                return

            inOrder(node.left)

            if last:
                last.right = node
                node.left = last
            else:
                first = node
            
            last = node

            inOrder(node.right)

        inOrder(root)

        first.left = last
        last.right = first

        return first
```


",,
"```python
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def build(grid, row, col, size):
    if size == 1:
        return Node(grid[row][col] == 1, True, None, None, None, None)
    half = size // 2
    topLeft = build(grid, row, col, half)
    topRight = build(grid, row, col + half, half)
    bottomLeft = build(grid, row + half, col, half)
    bottomRight = build(grid, row + half, col + half, half)
    if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and topLeft.val == topRight.val and topLeft.val == bottomLeft.val and topLeft.val == bottomRight.val:
        return topLeft
    return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)

def construct(grid):
    return build(grid, 0, 0, len(grid))
```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Codec:
    def serialize(self, root):
        if root is None:
            return """"
        
        data = str(root.val) + "" ""
        for child in root.children:
            data += self.serialize(child)
        data += ""# ""
        return data

    def deserialize(self, data):
        def dfs(iter_data):
            val = next(iter_data)
            if val == ""#"":
                return None
            
            node = Node(int(val))
            while True:
                child = dfs(iter_data)
                if child is None:
                    break
                node.children.append(child)
            return node

        return dfs(iter(data.split()))

```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        currentLevel = []
        nextLevel = []
        
        for node in queue:
            currentLevel.append(node.val)
            nextLevel.extend(node.children)
            
        result.append(currentLevel)
        queue = nextLevel
            
    return result
```

",,
"```python
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child

def flatten(head: Node) -> Node:
    if not head:
        return None
    
    cur, prev, next_node = head, None, None

    while cur:
        next_node = cur.next

        if cur.child:
            cur.next = flatten(cur.child)
            cur.child.prev = cur
            cur.child = None

            if next_node:
                prev = cur
                while cur.next:
                    cur = cur.next
                    prev = prev.next

                cur.next = next_node
                next_node.prev = prev

        cur = next_node

    return head
```

",,
"```python
class NaryTreeNode:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class BinaryTreeNode:
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def encode(root: NaryTreeNode) -> BinaryTreeNode:
    if not root:
        return None
    binary_root = BinaryTreeNode(root.val)
    if root.children:
        binary_root.left = encode(root.children[0])
    sibling = binary_root.left
    for child in root.children[1:]:
        sibling.right = encode(child)
        sibling = sibling.right
    return binary_root

def decode(root: BinaryTreeNode) -> NaryTreeNode:
    if not root:
        return None
    nary_root = NaryTreeNode(root.val)
    sibling = root.left
    while sibling:
        nary_root.children.append(decode(sibling))
        sibling = sibling.right
    return nary_root
```

",,
"```python
class AllOne:
    def __init__(self):
        self.data = dict()

    def inc(self, key: str) -> None:
        self.data[key] = self.data.get(key, 0) + 1

    def dec(self, key: str) -> None:
        self.data[key] = self.data.get(key, 0) - 1
        if self.data[key] == 0:
            del self.data[key]

    def getMaxKey(self) -> str:
        if not self.data:
            return """"
        return max(self.data, key=lambda x: self.data[x])

    def getMinKey(self) -> str:
        if not self.data:
            return """"
        return min(self.data, key=lambda x: self.data[x])
```


",,
"```python
from collections import deque

def minMutation(start, end, bank):
    q = deque([start])
    visited = set([start])
    depth = 0

    while q:
        levelSize = len(q)
        for _ in range(levelSize):
            current = q.popleft()
            if current == end:
                return depth

            for gene in bank:
                if gene not in visited:
                    diff = sum(1 for j in range(8) if current[j] != gene[j])
                    if diff == 1:
                        q.append(gene)
                        visited.add(gene)
        depth += 1
    return -1
```


",,
"```python
def count_segments(s: str) -> int:
    return len(s.split())
```

",,
"```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[1])
    
    count = 0
    prev_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:
            count += 1
        else:
            prev_end = intervals[i][1]
    
    return count
```

",,
"```python
def findRightInterval(intervals):
    starts = {interval[0]: index for index, interval in enumerate(intervals)}
    res = []

    for interval in intervals:
        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)
        res.append(starts[right] if right != -1 else -1)

    return res
```

",,
"```python
def path_sum_helper(node, target_sum, current_sum):
    if node is None:
        return 0

    current_sum += node.val
    total_paths = 1 if current_sum == target_sum else 0
    total_paths += path_sum_helper(node.left, target_sum, current_sum)
    total_paths += path_sum_helper(node.right, target_sum, current_sum)
    return total_paths

def path_sum(root, target_sum):
    if root is None:
        return 0

    return path_sum_helper(root, target_sum, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)
```


",,
"```python
def find_anagrams(s, p):
    if len(s) < len(p):
        return []

    s_count = [0] * 26
    p_count = [0] * 26
    for c in p:
        p_count[ord(c) - ord('a')] += 1

    result = []
    for i in range(len(s)):
        s_count[ord(s[i]) - ord('a')] += 1
        if i >= len(p):
            s_count[ord(s[i - len(p)]) - ord('a')] -= 1
        if s_count == p_count:
            result.append(i - len(p) + 1)

    return result
```

",,
"```python
def parseTernary(expression: str) -> str:
    stack = []
    for c in reversed(expression):
        if stack and stack[-1] == '?':
            stack.pop()  # Pop '?'
            first = stack.pop()
            stack.pop()  # Pop ':'
            second = stack.pop()
            stack.append(first if c == 'T' else second)
        else:
            stack.append(c)
    return stack[-1]
```


",,
"```python
def find_kth_number(n, k):
    nums = [i for i in range(1, n + 1)]
    nums.sort(key=lambda x: str(x))
    return nums[k - 1]
```


",,
"```python
def arrange_coins(n: int) -> int:
    k = 0
    while n > k:
        k += 1
        n -= k
    return k
```

",,
"```python
def find_duplicates(nums):
    duplicates = []
    for i in range(len(nums)):
        index = abs(nums[i]) - 1
        if nums[index] < 0:
            duplicates.append(abs(nums[i]))
        else:
            nums[index] *= -1
    return duplicates
```

",,
"```python
def compress(chars):
    index, i = 0, 0
    
    while i < len(chars):
        count = 1
        while i + count < len(chars) and chars[i] == chars[i + count]:
            count += 1
            
        chars[index] = chars[i]
        index += 1
        
        if count > 1:
            count_str = str(count)
            for c in count_str:
                chars[index] = c
                index += 1
                
        i += count
        
    return index
```

",,
"```python
def is_shortest_and_unique_supersequence(nums, sequences):
    pos = {val: idx for idx, val in enumerate(nums)}

    for seq in sequences:
        if pos[seq[0]] > pos[seq[-1]]:
            return False
    return True
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    result = ListNode(0)
    current = result
    carry = 0
    while l1 or l2 or carry:
        sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        if l1: l1 = l1.next
        if l2: l2 = l2.next
    return result.next
```

",,
"```python
def numberOfArithmeticSlices(nums):
    res = 0
    n = len(nums)
    dp = [dict() for _ in range(n)]

    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            if diff <= -2**31 or diff > 2**31:
                continue

            dp[i][diff] = dp[i].get(diff, 0) + 1

            if diff in dp[j]:
                res += dp[j][diff]
                dp[i][diff] += dp[j][diff]

    return res
```


",,
"```python
def numberOfBoomerangs(points):
    count = 0

    for i in points:
        group_count = {}
        for j in points:
            dx, dy = i[0] - j[0], i[1] - j[1]
            dist = dx * dx + dy * dy
            group_count[dist] = group_count.get(dist, 0) + 1

        for g in group_count.values():
            count += g * (g - 1)

    return count
```

",,
"```python
def find_disappeared_numbers(nums):
    result = []
    
    for num in nums:
        index = abs(num) - 1
        nums[index] = -abs(nums[index])

    for i, num in enumerate(nums):
        if num > 0:
            result.append(i + 1)

    return result
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def serialize(root):
    if not root:
        return ""#""
    return str(root.val) + "","" + serialize(root.left) + "","" + serialize(root.right)

def deserialize(data):
    def deserialize_helper(values):
        val = next(values)
        if val == ""#"":
            return None
        node = TreeNode(int(val))
        node.left = deserialize_helper(values)
        node.right = deserialize_helper(values)
        return node

    values = iter(data.split("",""))
    return deserialize_helper(values)
```


",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def deleteNode(root, key):
    if root is None:
        return None

    if key < root.val:
        root.left = deleteNode(root.left, key)
    elif key > root.val:
        root.right = deleteNode(root.right, key)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        else:
            temp = root.right
            while temp.left is not None:
                temp = temp.left
            root.val = temp.val
            root.right = deleteNode(root.right, temp.val)

    return root
```

",,
"```python
from collections import Counter

def sort_by_frequency(s):
    freq = Counter(s)
    chars = list(s)
    chars.sort(key=lambda c: freq[c], reverse=True)
    return ''.join(chars)
```

",,
"```python
def findMinArrowShots(points):
    if not points:
        return 0
    points.sort(key=lambda x: x[1])

    arrows = 1
    end = points[0][1]

    for i in range(1, len(points)):
        if points[i][0] > end:
            arrows += 1
            end = points[i][1]

    return arrows
```

",,
"```python
def min_moves(nums):
    min_element = min(nums)
    moves = sum(num - min_element for num in nums)
    return moves
```


",,
"```python
def fourSumCount(nums1, nums2, nums3, nums4):
    hashMap = {}
    count = 0

    for i in nums1:
        for j in nums2:
            hashMap[i + j] = hashMap.get(i + j, 0) + 1

    for k in nums3:
        for l in nums4:
            count += hashMap.get(-(k + l), 0)

    return count
```

",,
"```python
def find_content_children(g, s):
    g.sort()
    s.sort()
    i = j = 0

    while i < len(g) and j < len(s):
        if s[j] >= g[i]:
            i += 1

        j += 1

    return i
```


",,
"```python
def find132pattern(nums):
    third, stack = float('-inf'), []
    for num in reversed(nums):
        if num < third:
            return True
        while stack and stack[-1] < num:
            third = stack.pop()
        stack.append(num)
    return False
```

",,
"```python
def circularArrayLoop(nums: List[int]) -> bool:
    N = len(nums)
    for i in range(N):
        slow, fast = i, i
        while True:
            slow = getNextIndex(slow, nums)
            fast = getNextIndex(getNextIndex(fast, nums), nums)
            if slow != fast and nums[slow] * nums[fast] > 0:
                break
            if slow == fast:
                break
        else:
            continue
        cycle = False
        start = slow
        while start != slow:
            cycle |= getNextIndex(start, nums) == start
            start = getNextIndex(start, nums)
        if not cycle:
            return True
    return False

def getNextIndex(idx: int, nums: List[int]) -> int:
    N = len(nums)
    return (idx + nums[idx]) % N
```


",,
"```python
def poor_pigs(buckets, minutes_to_die, minutes_to_test):
    pigs = 0
    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:
        pigs += 1
    return pigs
```


",,
"```python
def can_construct(s):
    n = len(s)
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            substr = s[:i]
            flag = True
            for j in range(i, n, i):
                if s[j:j+i] != substr:
                    flag = False
                    break

            if flag:
                return True

    return False
```


",,
"```python
class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.min_freq = 0
        self.key_value = {}
        self.key_freq = {}
        self.freq_list = {1: []}

    def get(self, key: int) -> int:
        if key not in self.key_value:
            return -1
        count = self.key_freq[key]
        self.key_freq[key] += 1
        self.freq_list[count].remove(key)

        if count == self.min_freq and not self.freq_list[count]:
            self.min_freq += 1

        if count + 1 not in self.freq_list:
            self.freq_list[count + 1] = []
        self.freq_list[count + 1].append(key)

        return self.key_value[key]

    def put(self, key: int, value: int) -> None:
        if self.capacity <= 0:
            return
        if key in self.key_value:
            self.key_value[key] = value
            self.get(key)
            return
        
        if len(self.key_value) >= self.capacity:
            evict = self.freq_list[self.min_freq][0]
            self.freq_list[self.min_freq].pop(0)
            del self.key_value[evict]

        self.key_value[key] = value
        self.key_freq[key] = 1
        self.min_freq = 1
        self.freq_list[1].append(key)
```


",,
"```python
def hammingDistance(x: int, y: int) -> int:
    xorResult = x ^ y
    dist = 0
    while xorResult:
        dist += xorResult & 1
        xorResult >>= 1
    return dist
```

",,
"```python
def min_moves2(nums):
    nums.sort()
    mid = nums[len(nums) // 2]
    moves = 0
    for num in nums:
        moves += abs(num - mid)
    return moves
```

",,
"```python
def islandPerimeter(grid):
    perimeter = 0
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            if grid[row][col] == 1:
                perimeter += 4
                if row > 0 and grid[row - 1][col] == 1:
                    perimeter -= 2
                if col > 0 and grid[row][col - 1] == 1:
                    perimeter -= 2
    return perimeter
```

",,
"```python
def canIWin(maxChoosableInteger, desiredTotal):
    if maxChoosableInteger >= desiredTotal: return True
    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False

    memo = {}
        
    def canWin(state):
        if state in memo:
            return memo[state]
        for i in range(1, maxChoosableInteger + 1):
            bitCheck = 1 << i
            if (state & bitCheck) == 0:
                if not canWin(state | bitCheck):
                    memo[state] = True
                    return True
    
        memo[state] = False
        return False

    return canWin(0)
```


",,
"```python
from collections import defaultdict

def minTransfers(transactions):
    balances = defaultdict(int)
    for transaction in transactions:
        balances[transaction[0]] -= transaction[2]
        balances[transaction[1]] += transaction[2]

    debts = [balance for balance in balances.values() if balance != 0]
    return dfs(debts, 0)

def dfs(debts, start):
    while start < len(debts) and debts[start] == 0:
        start += 1
    if start == len(debts):
        return 0
    result = float('inf')
    for i in range(start + 1, len(debts)):
        if (debts[start] > 0) != (debts[i] > 0):
            debts[i] += debts[start]
            result = min(result, 1 + dfs(debts, start + 1))
            debts[i] -= debts[start]
    return result
```


",,
"```python
def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:
    count1, count2, i, j = 0, 0, 0, 0
    while count1 < n1:
        if s1[i] == s2[j]:
            j += 1
            if j == len(s2):
                j = 0
                count2 += 1
        i += 1
        if i == len(s1):
            i = 0
            count1 += 1
    return count2 // n2
```


",,
"```python
def findSubstringInWraproundString(p: str) -> int:
    cnt = [0] * 26
    length = 0

    for i in range(len(p)):
        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):
            length += 1
        else:
            length = 1
        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)

    return sum(cnt)
```


",,
"```python
def validateIP(queryIP):
    ipv4_parts = queryIP.split('.')
    ipv6_parts = queryIP.split(':')

    if len(ipv4_parts) == 4:
        if is_valid_ipv4(ipv4_parts):
            return ""IPv4""
    elif len(ipv6_parts) == 8:
        if is_valid_ipv6(ipv6_parts):
            return ""IPv6""

    return ""Neither""

def is_valid_ipv4(parts):
    for part in parts:
        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):
            return False

        if not part.isdigit() or int(part) < 0 or int(part) > 255:
            return False

    return True

def is_valid_ipv6(parts):
    for part in parts:
        if not part or len(part) > 4:
            return False

        for ch in part:
            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):
                return False

    return True
```

",,
"```python
def isConvex(points):
    n = len(points)
    pre = cur = 0

    for i in range(n):
        x1 = points[(i + 1) % n][0] - points[i][0]
        y1 = points[(i + 1) % n][1] - points[i][1]
        x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0]
        y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1]
        cur = x1 * y2 - x2 * y1

        if cur == 0:
            continue
        if cur * pre < 0:
            return False
        pre = cur

    return True
```

",,
"```python
def rand7():
    pass  # Provided API

def rand10():
    result = None
    while True:
        result = (rand7() - 1) * 7 + rand7()
        if result <= 40:
            break
    return result % 10 + 1
```

",,
"```python
def encode(s: str) -> str:
    n = len(s)
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            reps = n // i
            sub = s[:i]
            composed = sub * reps
            if s == composed:
                return f""{reps}[{sub}]""
    return s
```

",,
"```python
def is_concatenated(word, word_dict):
    n = len(word)
    dp = [False] * (n + 1)
    dp[0] = True

    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and word[j:i] in word_dict:
                dp[i] = True
                break

    return dp[n]


def find_all_concatenated_words(words):
    word_dict = set(words)
    result = []

    for word in words:
        if is_concatenated(word, word_dict):
            result.append(word)

    return result
```

",,
"```python
from itertools import chain

def makesquare(matchsticks):
    if len(matchsticks) < 4:
        return False
    total = sum(matchsticks)
    if total % 4:
        return False
    target = total // 4
    matchsticks.sort(reverse=True)
    sums = [0]*4
    return dfs(matchsticks, sums, target, 0)

def dfs(matchsticks, sums, target, index):
    if index == len(matchsticks):
        return sums[0] == target and sums[1] == target and sums[2] == target
    for i in range(4):
        if sums[i] + matchsticks[index] <= target:
            sums[i] += matchsticks[index]
            if dfs(matchsticks, sums, target, index + 1):
                return True
            sums[i] -= matchsticks[index]
    return False
```


",,
"```python
def findMaxForm(strs, m, n):
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for s in strs:
        ones = s.count('1')
        zeros = len(s) - ones
        
        for i in range(m, zeros - 1, -1):
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
    
    return dp[m][n]
```

",,
"```python
def findRadius(houses, heaters):
    houses.sort()
    heaters.sort()
    result, i = 0, 0

    for house in houses:
        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):
            i += 1
        result = max(result, abs(heaters[i] - house))

    return result
```

",,
"```python
def find_complement(num: int) -> int:
    bit_length = 0
    mask = num
    while mask > 0:
        mask >>= 1
        bit_length += 1
    all_ones = (1 << bit_length) - 1

    return num ^ all_ones
```

",,
"```python
def total_hamming_distance(nums):
    total_distance = 0
    n = len(nums)

    for i in range(32):
        bit_count = sum(((num >> i) & 1) for num in nums)
        total_distance += bit_count * (n - bit_count)

    return total_distance
```

",,
"```python
import random
from math import sqrt, pi, cos, sin

class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self):
        r = sqrt(random.random()) * self.radius
        theta = random.random() * 2 * pi
        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]
```

",,
"```python
def largestPalindrome(n):
    if n == 1: 
        return 9
    upper_limit = 10**n - 1
    lower_limit = upper_limit // 10
    for i in range(upper_limit, lower_limit, -1):
        temp = i
        reverse = 0
        while temp != 0:
            reverse = reverse * 10 + temp % 10
            temp //= 10
        palindrome = i * (10**n) + reverse
        for j in range(upper_limit, lower_limit, -1):
            product = palindrome // j
            if palindrome % j == 0 and product <= upper_limit:
                return palindrome % 1337
    return -1
```

",,
"```python
from sortedcontainers import SortedList

def medianSlidingWindow(nums, k):
    window = SortedList(nums[:k])
    medians = []
    
    for i in range(k, len(nums) + 1):
        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))
        
        if i < len(nums):
            window.remove(nums[i - k])
            window.add(nums[i])

    return medians
```


",,
"```python
def magical_string(n: int) -> int:
    if n == 0:
        return 0
    if n <= 3:
        return 1

    magic = [1, 2, 2]
    count_ones = 1
    index = 2
    value = 1

    while len(magic) < n:
        for _ in range(magic[index]):
            magic.append(value)
            if value == 1 and len(magic) <= n:
                count_ones += 1
        value = 3 - value
        index += 1

    return count_ones
```


",,
"```python
def license_key_formatting(s: str, k: int) -> str:
    result = []
    count = 0
    for c in reversed(s):
        if c != '-':
            if count == k:
                result.append('-')
                count = 0
            result.append(c.upper())
            count += 1
    return ''.join(reversed(result))
```

",,
"```python
def smallest_good_base(n: str) -> str:
    num_n = int(n)

    for m in range(int(num_n.bit_length()), 0, -1):
        k = int(num_n ** (1.0 / m))
        if sum(k**i for i in range(m+1)) == num_n:
            return str(k)

    return ""-1""
```

",,
"```python
def findPermutation(s: str) -> list[int]:
    perm = [0] * (len(s) + 1)
    left = 1
    i = 0
    while i < len(s):
        if s[i] == 'I':
            perm[i] = left
            left += 1
            while i + 1 < len(s) and s[i + 1] == 'D':
                i += 1
        i += 1
    perm[len(s)] = left
    left += 1
    for i in reversed(range(len(s))):
        if s[i] == 'D':
            perm[i] = left
            left += 1
    return perm
```

",,
"```python
def findMaxConsecutiveOnes(nums):
    max_consecutive, current_consecutive = 0, 0
    for num in nums:
        current_consecutive = current_consecutive + 1 if num == 1 else 0
        max_consecutive = max(max_consecutive, current_consecutive)
    return max_consecutive
```

",,
"```python
def can_win(nums):
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = nums[i]
    for len in range(1, n):
        for i in range(n - len):
            j = i + len
            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
    return dp[0][n - 1] >= 0
```


",,
"```python
def findMaxConsecutiveOnes(nums: List[int]) -> int:
    max_count, count_zeros, left = 0, 0, 0
    for right in range(len(nums)):
        if nums[right] == 0:
            count_zeros += 1
        while count_zeros > 1:
            if nums[left] == 0:
                count_zeros -= 1
            left += 1
        max_count = max(max_count, right - left + 1)
    return max_count
```

",,
"```python
from collections import Counter

def find_min_step(board: str, hand: str) -> int:
    def find_min_step_helper(board, memo, hand):
        if not board:
            return 0
        if board in memo:
            return memo[board]

        result = float('inf')
        i = 0
        while i < len(board):
            j = i
            while j < len(board) and board[i] == board[j]:
                j += 1            

            color = board[i]
            required = 3 - (j - i)
            if hand[color] >= required:
                hand[color] -= required
                next_board = board[:i] + board[j:]
                tmp = find_min_step_helper(next_board, memo, hand)
                if tmp != -1:
                    result = min(result, tmp + required)
                hand[color] += required
            i = j

        memo[board] = -1 if result == float('inf') else result
        return memo[board]

    hand_count = Counter(hand)
    memo = {}
    return find_min_step_helper(board, memo, hand_count)
```


",,
"```python
from math import comb

def kthSmallestPath(destination, k):
    row, col = destination
    ans = """"

    for i in range(row + col):
        if row == 0:
            ans += 'H'
            col -= 1
        elif col == 0:
            ans += 'V'
            row -= 1
        elif k <= comb(row + col - 1, row - 1):
            ans += 'H'
            col -= 1
        else:
            ans += 'V'
            k -= comb(row + col - 1, row - 1)
            row -= 1

    return ans
```


",,
"```python
def hasPath(maze, start, destination):
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))
    q = [start]
    while q:
        x, y = q.pop(0)
        if x == destination[0] and y == destination[1]:
            return True
        for dx, dy in dirs:
            i, j = x, y
            while 0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and maze[i + dx][j + dy] == 0:
                i += dx
                j += dy
            if maze[i][j] == 0:
                maze[i][j] = 1
                q.append((i, j))
    return False
```

",,
"```python
from typing import List

def findSubsequences(nums: List[int]) -> List[List[int]]:
    res = set()
    dfs(nums, 0, [], res)
    return list(res)

def dfs(nums, start, path, res):
    if len(path) >= 2:
        res.add(tuple(path))
    for i in range(start, len(nums)):
        if path and path[-1] > nums[i]:
            continue
        dfs(nums, i + 1, path + [nums[i]], res)
```

",,
"```python
def constructRectangle(area: int) -> List[int]:
    width = int(area**0.5)
    while area % width != 0:
        width -= 1
    length = area // width
    return [length, width]
```

",,
"```python
def reversePairs(nums):
    def mergeSort(l, r):
        if l >= r:
            return 0
        
        mid = (l + r) // 2
        count = mergeSort(l, mid) + mergeSort(mid + 1, r)
        j = mid + 1
        for i in range(l, mid + 1):
            while j <= r and nums[i] > 2 * nums[j]:
                j += 1
            count += j - (mid + 1)
        
        nums[l:r + 1] = sorted(nums[l:r + 1])
        
        return count
    
    return mergeSort(0, len(nums) - 1)
```


",,
"```python
def findTargetSumWays(nums, target):
    total_sum = sum(nums)
    if total_sum < target or (total_sum + target) % 2 != 0:
        return 0
    target_sum = (total_sum + target) // 2
    dp = [0] * (target_sum + 1)
    dp[0] = 1
    for num in nums:
        for j in range(target_sum, num - 1, -1):
            dp[j] += dp[j - num]
    return dp[target_sum]
```


",,
"```python
def find_poisoned_duration(time_series, duration):
    if not time_series:
        return 0
    total = 0
    for i in range(1, len(time_series)):
        total += min(time_series[i] - time_series[i - 1], duration)
    return total + duration
```

",,
"```python
def next_greater_element(nums1, nums2):
    next_greater = {}
    stack = []

    for num in nums2:
        while stack and stack[-1] < num:
            next_greater[stack.pop()] = num
        stack.append(num)

    return [next_greater.get(n, -1) for n in nums1]
```

",,
"```python
import random
from typing import List

class Solution:
    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.areas = [0] * len(rects)
        self.total_area = 0

        for i, rect in enumerate(rects):
            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)
            self.areas[i] = area
            self.total_area += area

    def pick(self) -> List[int]:
        rnd = random.randint(0, self.total_area - 1)
        idx = 0
        while rnd >= self.areas[idx]:
            rnd -= self.areas[idx]
            idx += 1

        x = random.randint(self.rects[idx][0], self.rects[idx][2])
        y = random.randint(self.rects[idx][1], self.rects[idx][3])
        
        return [x, y]
```


",,
"```python
from typing import List

def findDiagonalOrder(mat: List[List[int]]) -> List[int]:
    m, n = len(mat), len(mat[0])
    result = [0] * (m * n)
    row, col = 0, 0
    for i in range(m * n):
        result[i] = mat[row][col]
        if (row + col) % 2 == 0:
            if col == n - 1:
                row += 1
            elif row == 0:
                col += 1
            else:
                row -= 1
                col += 1
        else:
            if row == m - 1:
                col += 1
            elif col == 0:
                row += 1
            else:
                row += 1
                col -= 1
    return result
```

",,
"```python
from heapq import heappush, heappop

class Solution:
    def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:
        m, n = len(maze), len(maze[0])
        dist = [[float(""inf"")] * n for _ in range(m)]
        dirs = [""d"", ""l"", ""r"", ""u""]
        dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]]
        dist[ball[0]][ball[1]] = 0
        pq = [(0, """", ball[0], ball[1])]
        
        while pq:
            cur_dist, cur_path, x, y = heappop(pq)
            if [x, y] == hole:
                return cur_path

            for k, d in enumerate(dirs):
                dist_move, r, c = 0, x + dirs_vector[k][0], y + dirs_vector[k][1]
                while 0 <= r < m and 0 <= c < n and maze[r][c] == 0 and [r, c] != hole:
                    r += dirs_vector[k][0]
                    c += dirs_vector[k][1]
                    dist_move += 1
                r -= dirs_vector[k][0]
                c -= dirs_vector[k][1]
                dist_move -= 1
                
                if dist[x][y] + dist_move < dist[r][c]:
                    dist[r][c] = dist[x][y] + dist_move
                    heappush(pq, (cur_dist + dist_move, cur_path + d, r, c))
        
        return ""impossible""
```

",,
"```python
def find_words(words):
    rows = [
        set(""qwertyuiopQWERTYUIOP""),
        set(""asdfghjklASDFGHJKL""),
        set(""zxcvbnmZXCVBNM"")
    ]
    res = []

    for word in words:
        row = -1
        for i in range(3):
            if word[0] in rows[i]:
                row = i
                break

        if all(c in rows[row] for c in word):
            res.append(word)

    return res
```


",,
"```python
def findMode(root):
    def InOrder(node):
        if not node: return
        yield from InOrder(node.left)
        yield node.val
        yield from InOrder(node.right)
        
    counts = collections.Counter(InOrder(root))
    max_count = max(counts.values(), default=0)
    return [k for k, v in counts.items() if v == max_count]
```

",,
"```python
import heapq

def findMaximizedCapital(k: int, w: int, profits, capital) -> int:
    project_pool = list(zip(capital, profits))
    project_pool.sort(reverse=True)
    
    profit_pool = []
    
    while k:
        while project_pool and project_pool[-1][0] <= w:
            heapq.heappush(profit_pool, -project_pool.pop()[1])
        
        if not profit_pool:
            break
        
        w -= heapq.heappop(profit_pool)
        k -= 1
        
    return w
```

",,
"```python
def nextGreaterElements(nums):
    result = [-1] * len(nums)
    stack = []

    for i in range(len(nums) * 2):
        index = i % len(nums)
        while stack and nums[stack[-1]] < nums[index]:
            result[stack.pop()] = nums[index]
        if i < len(nums):
            stack.append(index)

    return result
```

",,
"```python
def convert_to_base7(num: int) -> str:
    if num == 0:
        return ""0""
    result = """"
    negative = num < 0
    if negative:
        num *= -1
    while num > 0:
        result = str(num % 7) + result
        num //= 7
    return ""-"" + result if negative else result
```

",,
"```python
from queue import PriorityQueue

def shortestDistance(maze, start, destination):
    m, n = len(maze), len(maze[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dist = [[-1 for _ in range(n)] for _ in range(m)]

    q = PriorityQueue()

    dist[start[0]][start[1]] = 0
    q.put((0, start[0], start[1]))

    while not q.empty():
        cur = q.get()
        x, y = cur[1], cur[2]

        for dir in directions:
            newX, newY = x + dir[0], y + dir[1]
            step = 0

            while 0 <= newX < m and 0 <= newY < n and maze[newX][newY] == 0:
                newX += dir[0]
                newY += dir[1]
                step += 1

            newX -= dir[0]
            newY -= dir[1]

            if dist[newX][newY] == -1 or dist[x][y] + step < dist[newX][newY]:
                dist[newX][newY] = dist[x][y] + step
                q.put((dist[newX][newY], newX, newY))

    return dist[destination[0]][destination[1]]
```


",,
"```python
def find_relative_ranks(score):
    rank_sort = sorted(range(len(score)), key=lambda i: score[i], reverse=True)
    result = [0] * len(score)
    for i, rank in enumerate(rank_sort):
        result[rank] = i + 1
    return result
```


",,
"```python
def checkPerfectNumber(num: int) -> bool:
    if num <= 1:
        return False
    sum = 1
    i = 2
    while i * i <= num:
        if num % i == 0:
            sum += i
            if i * i != num:
                sum += num // i
        i += 1
    return sum == num
```

",,
"```python
from collections import defaultdict

def helper(node, counts):
    if not node: return 0
    val = node.val + helper(node.left, counts) + helper(node.right, counts)
    counts[val] += 1
    return val

def findFrequentTreeSum(root):
    counts = defaultdict(int)
    helper(root, counts)
    max_count = max(counts.values(), default=0)
    return [s for s, c in counts.items() if c == max_count]
```


",,
"```python
def fib(n: int) -> int:
    if n < 2:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
```

",,
"```python
class Node:
    def __init__(self, val, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

def inorder_successor(node: Node) -> Node:
    if node.right:
        node = node.right
        while node.left:
            node = node.left
        return node

    while node.parent and node == node.parent.right:
        node = node.parent

    return node.parent
```

",,
"```python
def findBottomLeftValue(self, root: TreeNode) -> int:
    result = [0, 0] # [depth, value]
    self.helper(root, 1, result)
    return result[1]

def helper(self, node, depth, result):
    if not node:
        return
    if depth > result[0]:
        result[0] = depth
        result[1] = node.val

    self.helper(node.left, depth+1, result)
    self.helper(node.right, depth+1, result)
```


",,
"```python
def find_rotate_steps(ring: str, key: str) -> int:
    n, m = len(ring), len(key)
    dp = [[0] * n for _ in range(m + 1)]

    for i in range(m - 1, -1, -1):
        for j in range(n):
            dp[i][j] = float('inf')
            for k in range(n):
                if ring[k] == key[i]:
                    diff = abs(j - k)
                    step = min(diff, n - diff)
                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])

    return dp[0][0] + m
```


",,
"```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def largestValues(root: TreeNode):
    if not root:
        return []
    result = []
    queue = deque([root])

    while queue:
        size = len(queue)
        max_val = float('-inf')
        for _ in range(size):
            node = queue.popleft()
            max_val = max(max_val, node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(max_val)

    return result
```

",,
"```python
def longestPalindromeSubseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                
    return dp[0][n - 1]
```

",,
"```python
def find_min_moves(machines):
    n = len(machines)
    total_dresses = sum(machines)
    if total_dresses % n != 0:
        return -1
    average = total_dresses // n
    moves = 0
    imbalance = 0
    
    for i in range(n):
        imbalance += machines[i] - average
        moves = max(moves, abs(imbalance), machines[i] - average)
        
    return moves
```

",,
"```python
def change(amount, coins):
    dp = [1] + [0] * amount
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]
```

",,
"```python
import random

class Solution:
    def __init__(self, m: int, n: int):
        self.m, self.n = m, n
        self.total = m * n
        self.matrix = [[0] * n for _ in range(m)]

    def flip(self):
        idx = random.randint(0, self.total - 1)
        self.total -= 1

        for i in range(self.m):
            for j in range(self.n):
                if self.matrix[i][j] == 0:
                    if idx == 0:
                        self.matrix[i][j] = 1
                        return [i, j]
                    idx -= 1
        return [-1, -1] # This line should never be reached

    def reset(self):
        self.total = self.m * self.n
        for row in self.matrix:
            for j in range(self.n):
                row[j] = 0
```


",,
"```python
def detectCapitalUse(word: str) -> bool:
    numCapital = sum(1 for c in word if c.isupper())
    return numCapital == 0 or numCapital == len(word) or (numCapital == 1 and word[0].isupper())
```


",,
"```python
def findLUSlength(a: str, b: str) -> int:
    if a == b:
        return -1
    return max(len(a), len(b))
```

",,
"```python
def find_lus_length(strs):
    max_length = -1
    for i in range(len(strs)):
        is_uncommon = True
        for j in range(len(strs)):
            if i != j and strs[i] in strs[j]:
                is_uncommon = False
                break
        if is_uncommon:
            max_length = max(max_length, len(strs[i]))
    return max_length
```


",,
"```python
def checkSubarraySum(nums, k):
    n, sum_ = len(nums), 0
    mp = {0: -1}
    for i, num in enumerate(nums):
        sum_ += num
        if k != 0:
            sum_ %= k
        if sum_ in mp:
            if i - mp[sum_] > 1:
                return True
        else:
            mp[sum_] = i
    return False
```

",,
"```python
def findLongestWord(s, dictionary):
    def is_subsequence(target, source):
        iter_source = iter(source)
        return all(char in iter_source for char in target)

    dictionary = sorted(dictionary)
    longest = ''
    for word in dictionary:
        if is_subsequence(word, s) and len(word) > len(longest):
            longest = word
    return longest
```


",,
"```python
def findMaxLength(nums):
    counts = {0: -1}
    max_len = count = 0
    for i, num in enumerate(nums):
        count += 1 if num == 1 else -1
        if count in counts:
            max_len = max(max_len, i - counts[count])
        else:
            counts[count] = i
    return max_len
```

",,
"```python
def countArrangement(n: int) -> int:
    def helper(idx: int, visited: List[bool], n: int) -> int:
        if idx > n:
            return 1

        count = 0
        for i in range(1, n+1):
            if not visited[i] and (idx % i == 0 or i % idx == 0):
                visited[i] = True
                count += helper(idx+1, visited, n)
                visited[i] = False

        return count

    visited = [False] * (n+1)
    return helper(1, visited, n)
```

",,
"```python
def wordsAbbreviation(words):
    def abbrev(word, k):
        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word

    n = len(words)
    abbr = [abbrev(word, 1) for word in words]
    prefix_len = [1] * n

    for i in range(n):
        while abbr.count(abbr[i]) > 1:
            groups = {}
            for j in range(i + 1, n):
                if abbr[i] == abbr[j]:
                    if abbr[j] not in groups:
                        groups[abbr[j]] = []
                    groups[abbr[j]].append(j)
            for group_members in groups.values():
                for j in group_members:
                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)
                    prefix_len[j] += 1
            abbr[i] = abbrev(words[i], prefix_len[i] + 1)
            prefix_len[i] += 1

    return abbr
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapNodes(head, k):
    first, second, temp = head, head, head
    for _ in range(k - 1):
        temp = temp.next
    first = temp
    temp = temp.next
    while temp:
        temp = temp.next
        second = second.next

    first.val, second.val = second.val, first.val
    return head
```

",,
"```python
from typing import List

def reveal(board: List[List[str]], row: int, col: int, directions: List[List[int]]) -> None:
    if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or board[row][col] != 'E':
        return

    mines = 0
    for dir in directions:
        newRow, newCol = row + dir[0], col + dir[1]
        if newRow >= 0 and newRow < len(board) and newCol >= 0 and newCol < len(board[0]) and board[newRow][newCol] == 'M':
            mines += 1

    if mines > 0:
        board[row][col] = str(mines)
    else:
        board[row][col] = 'B'
        for dir in directions:
            reveal(board, row + dir[0], col + dir[1], directions)

def updateBoard(board: List[List[str]], click: List[int]) -> List[List[str]]:
    row, col = click

    if board[row][col] == 'M':
        board[row][col] = 'X'
    else:
        directions = [[1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1]]
        reveal(board, row, col, directions)

    return board
```
",,
"```python
class TreeNode:
    def __init__(self, x: int):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        result = float('inf')
        prev = None

        def inorderTraversal(node):
            nonlocal result, prev
            if node is None:
                return
            inorderTraversal(node.left)
            if prev is not None:
                result = min(result, node.val - prev.val)
            prev = node
            inorderTraversal(node.right)

        inorderTraversal(root)
        return result
```

",,
"```python
def findLonelyPixel(picture):
    m, n = len(picture), len(picture[0])
    row, col = [0] * m, [0] * n
    
    for i in range(m):
        for j in range(n):
            if picture[i][j] == 'B':
                row[i] += 1
                col[j] += 1
                
    lonely = 0
    for i in range(m):
        for j in range(n):
            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:
                lonely += 1
                
    return lonely
```

",,
"```python
def find_pairs(nums, k):
    if k < 0:
        return 0
    starters = set()
    occurrences = {}
    for num in nums:
        if num + k in occurrences:
            starters.add(num)
        if num - k in occurrences:
            starters.add(num - k)
        occurrences[num] = occurrences.get(num, 0) + 1
    return len(starters)
```

",,
"```python
def findBlackPixel(picture, target):
    m, n = len(picture), len(picture[0])
    rows = [0] * m
    cols = [0] * n
    rowCounts = {}
    for i in range(m):
        row = """"
        for j in range(n):
            if picture[i][j] == 'B':
                rows[i] += 1
                cols[j] += 1
            row += picture[i][j]
        if rows[i] == target:
            rowCounts[row] = rowCounts.get(row, 0) + 1
    ans = 0
    for row, count in rowCounts.items():
        if count == target:
            for j in range(n):
                if row[j] == 'B' and cols[j] == target:
                    ans += count
    return ans
```

",,
"```python
import random
import string

class Solution:
    def __init__(self):
        self.url_map = {}
        self.alphabet = string.ascii_letters + string.digits

    def encode(self, longUrl: str) -> str:
        key = ''.join(random.choices(self.alphabet, k=6))

        while key in self.url_map:
            key = ''.join(random.choices(self.alphabet, k=6))

        self.url_map[key] = longUrl
        return ""http://tinyurl.com/"" + key

    def decode(self, shortUrl: str) -> str:
        return self.url_map[shortUrl[-6:]]
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def str2tree(self, s: str) -> TreeNode:
        def str2tree_helper(idx):
            if idx[0] >= len(s):
                return None

            sign = 1
            if s[idx[0]] == '-':
                sign = -1
                idx[0] += 1
                
            num = 0
            while idx[0] < len(s) and s[idx[0]].isdigit():
                num = num * 10 + int(s[idx[0]])
                idx[0] += 1

            node = TreeNode(sign * num)

            if idx[0] < len(s) and s[idx[0]] == '(':
                idx[0] += 1
                node.left = str2tree_helper(idx)
                idx[0] += 1
            if idx[0] < len(s) and s[idx[0]] == '(':
                idx[0] += 1
                node.right = str2tree_helper(idx)
                idx[0] += 1

            return node

        idx = [0]
        return str2tree_helper(idx)
```


",,
"```python
def complexNumberMultiply(num1: str, num2: str) -> str:
    real1, imag1 = map(int, num1[:-1].split('+'))
    real2, imag2 = map(int, num2[:-1].split('+'))

    real = real1 * real2 - imag1 * imag2
    imag = real1 * imag2 + real2 * imag1

    return f""{real}+{imag}i""
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def __init__(self):
        self.sum = 0

    def convertBST(self, root: TreeNode) -> TreeNode:
        if root:
            self.convertBST(root.right)
            self.sum += root.val
            root.val = self.sum
            self.convertBST(root.left)
        
        return root
```

",,
"```python
def findMinDifference(timePoints):
    timePoints.sort()
    min_difference = float('inf')

    for i in range(len(timePoints)):
        h1, m1 = map(int, timePoints[i].split(':'))
        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))
        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))
        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)

    return min_difference
```

",,
"```python
def singleNonDuplicate(nums):
    low, high = 0, len(nums) - 1
    while low < high:
        mid = low + (high - low) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            low = mid + 2
        else:
            high = mid
    return nums[low]
```

",,
"```python
def reverseStr(s, k):
    chars = list(s)
    for i in range(0, len(chars), 2 * k):
        chars[i:i + k] = reversed(chars[i:i + k])
    return """".join(chars)
```

",,
"```python
from collections import deque

def updateMatrix(mat):
    m, n = len(mat), len(mat[0])
    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]
    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])

    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while queue:
        x, y = queue.popleft()
        for dx, dy in directions:
            newX, newY = x + dx, y + dy
            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:
                distance[newX][newY] = distance[x][y] + 1
                queue.append((newX, newY))

    return distance
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def diameter_of_binary_tree(root):
    def _diameter_of_binary_tree(node):
        if not node:
            return 0, 0
        left_height, left_diameter = _diameter_of_binary_tree(node.left)
        right_height, right_diameter = _diameter_of_binary_tree(node.right)
        height = 1 + max(left_height, right_height)
        diameter = max(left_height + right_height, max(left_diameter, right_diameter))
        return height, diameter

    return _diameter_of_binary_tree(root)[1]
```

",,
"```python
def findContestMatch(n):
    matches = [str(i) for i in range(1, n + 1)]

    while n > 1:
        for i in range(n // 2):
            matches[i] = ""("" + matches[i] + "","" + matches[n - 1 - i] + "")""
        n //= 2

    return matches[0]
```


",,
"```python
class Solution:
    def leftBoundary(self, node, boundary):
        if not node or not (node.left or node.right):
            return
        boundary.append(node.val)
        if node.left:
            self.leftBoundary(node.left, boundary)
        else:
            self.leftBoundary(node.right, boundary)

    def rightBoundary(self, node, boundary):
        if not node or not (node.left or node.right):
            return
        if node.right:
            self.rightBoundary(node.right, boundary)
        else:
            self.rightBoundary(node.left, boundary)
        boundary.append(node.val)

    def leaves(self, node, boundary):
        if not node:
            return
        if not (node.left or node.right):
            boundary.append(node.val)
        self.leaves(node.left, boundary)
        self.leaves(node.right, boundary)

    def boundaryOfBinaryTree(self, root):
        res = []
        if not root:
            return res
        res.append(root.val)
        self.leftBoundary(root.left, res)
        self.leaves(root, res)
        self.rightBoundary(root.right, res)
        return res
```


",,
"```python
def removeBoxes(boxes):
    def dfs(l, r, k):
        if l > r: return 0
        if dp[l][r][k] != 0: return dp[l][r][k]

        while r > l and boxes[r] == boxes[r - 1]:
            r -= 1
            k += 1
            
        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)

        for i in range(l, r):
            if boxes[i] == boxes[r]:
                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))
                
        return dp[l][r][k]

    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]
    return dfs(0, len(boxes) - 1, 0)
```

",,
"```python
def findCircleNum(isConnected):
    def dfs(isConnected, visited, i):
        visited[i] = True
        for j in range(len(isConnected)):
            if isConnected[i][j] == 1 and not visited[j]:
                dfs(isConnected, visited, j)

    provinces = 0
    visited = [False] * len(isConnected)
    for i in range(len(isConnected)):
        if not visited[i]:
            dfs(isConnected, visited, i)
            provinces += 1
    return provinces
```

",,
"```python
def find_triplet_equal_sum(nums):
    n = len(nums)
    prefix_sum = [0] * (n + 1)

    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    for i in range(1, n - 2):
        for j in range(i + 2, n - 1):
            for k in range(j + 2, n):
                s1 = prefix_sum[i]
                s2 = prefix_sum[j] - prefix_sum[i + 1]
                s3 = prefix_sum[k] - prefix_sum[j + 1]
                s4 = prefix_sum[n] - prefix_sum[k + 1]
                if s1 == s2 == s3 == s4:
                    return True
    return False
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def longest_consecutive(root: TreeNode) -> int:
    def longest_consecutive_path_util(node, max_length):
        if not node:
            return 0
        left = longest_consecutive_path_util(node.left, max_length) + 1
        right = longest_consecutive_path_util(node.right, max_length) + 1
        if node.left and node.left.val != node.val + 1:
            left = 1
        if node.right and node.right.val != node.val + 1:
            right = 1
        length = max(left, right)
        max_length[0] = max(max_length[0], left + right - 1)
        return length

    max_length = [0]
    longest_consecutive_path_util(root, max_length)
    return max_length[0]
```

",,
"```python
def checkRecord(s: str) -> bool:
    late, absent = 0, 0
    for c in s:
        if c == 'A':
            absent += 1
            late = 0
        elif c == 'L':
            late += 1
        else:
            late = 0

        if absent >= 2 or late >= 3:
            return False
    return True
```

",,
"```python
def checkRecord(n: int) -> int:
    M = 1000000007
    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]
    while n:
        next_dp = [0] * 6
        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M
        next_dp[1] = dp[0]
        next_dp[2] = dp[1]
        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M
        next_dp[4] = dp[3]
        next_dp[5] = dp[4]
        dp = next_dp
        n -= 1
    return sum(dp) % M
```


",,
"```python
def optimal_division(nums):
    n = len(nums)
    if n == 1:
        return str(nums[0])
    if n == 2:
        return str(nums[0]) + '/' + str(nums[1])
    res = str(nums[0]) + '/('
    for i in range(1, n - 1):
        res += str(nums[i]) + '/'
    res += str(nums[n - 1]) + ')'
    return res
```


",,
"```python
from collections import defaultdict

def least_bricks(wall):
    edge_count = defaultdict(int)
    max_count = 0

    for row in wall:
        edge_position = 0
        for i in range(len(row) - 1):
            edge_position += row[i]
            edge_count[edge_position] += 1
            max_count = max(max_count, edge_count[edge_position])

    return len(wall) - max_count
```


",,
"```python
def splitLoopedString(strs):
    ans = ''
    cur = ''.join(max(s, s[::-1]) for s in strs)
    
    for i, s in enumerate(strs):
        for xstr in (s, s[::-1]):
            for j in range(len(xstr)):
                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]
                ans = max(ans, t)
        cur = cur[len(s):] + cur[:len(s)]
    
    return ans
```


",,
"```python
from itertools import permutations

def nextGreaterElement(n: int) -> int:
    num_str = str(n)
    num_permutations = sorted(set(int("""".join(p)) for p in permutations(num_str)))
    index = num_permutations.index(n)
    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:
        return num_permutations[index + 1]
    return -1
```

",,
"```python
def reverse_words_in_string(s: str) -> str:
    return "" "".join(word[::-1] for word in s.split("" ""))
```

",,
"```python
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        if quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        
        quadTree1.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        quadTree1.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)
        quadTree1.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        quadTree1.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        
        if (quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and
            quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and
            quadTree1.topLeft.val == quadTree1.topRight.val and
            quadTree1.topLeft.val == quadTree1.bottomLeft.val and
            quadTree1.topLeft.val == quadTree1.bottomRight.val):
            quadTree1.isLeaf = True
            quadTree1.val = quadTree1.topLeft.val
        
        return quadTree1
```


",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def max_depth(root):
    if root is None:
        return 0
    max_depth = 0
    for child in root.children:
        max_depth = max(max_depth, max_depth(child))
    return max_depth + 1
```

",,
"```python
def subarraySum(nums, k):
    prefix_sum_frequency = {0: 1}
    prefix_sum, result = 0, 0
    
    for num in nums:
        prefix_sum += num
        result += prefix_sum_frequency.get(prefix_sum - k, 0)
        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1

    return result
```

",,
"```python
def array_pair_sum(nums):
    nums.sort()
    return sum(nums[::2])
```

",,
"```python
def longestLine(mat):
    rows, cols = len(mat), len(mat[0])
    max_length = 0
    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]

    for r in range(rows):
        for c in range(cols):
            if mat[r][c] == 1:
                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1
                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1
                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1
                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1
                max_length = max(max_length, max(dp[r][c]))

    return max_length
```


",,
"```python
def findTilt(self, root):
    def findTiltUtil(node):
        if not node: return 0, 0
        
        leftSum, leftTilt = findTiltUtil(node.left)
        rightSum, rightTilt = findTiltUtil(node.right)
    
        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)

    return findTiltUtil(root)[1]
```


",,
"```python
def is_palindrome(s: str) -> bool:
    return s == s[::-1]

def closest_palindrome(n: str) -> int:
    num = int(n)
    left = num - 1
    right = num + 1

    while True:
        if is_palindrome(str(left)):
            return left
        if is_palindrome(str(right)):
            return right
        left -= 1
        right += 1
```

",,
"```python
def arrayNesting(nums):
    n = len(nums)
    max_len = 0
    for i in range(n):
        if nums[i] != -1:
            start = nums[i]
            count = 0
            while nums[start] != -1:
                temp = start
                start = nums[start]
                count += 1
                nums[temp] = -1
            max_len = max(max_len, count)
    return max_len
```

",,
"```python
def matrixReshape(mat, r, c):
    m, n = len(mat), len(mat[0])
    if m * n != r * c:
        return mat

    reshaped = [[0] * c for _ in range(r)]
    for i in range(m * n):
        reshaped[i // c][i % c] = mat[i // n][i % n]

    return reshaped
```

",,
"```python
def checkInclusion(s1: str, s2: str) -> bool:
    if len(s1) > len(s2): 
        return False
    
    s1_map = [0] * 26
    s2_map = [0] * 26
    
    for i in range(len(s1)):
        s1_map[ord(s1[i]) - ord('a')] += 1
        s2_map[ord(s2[i]) - ord('a')] += 1
    
    for i in range(len(s2) - len(s1)):
        if s1_map == s2_map: 
            return True
        
        s2_map[ord(s2[i]) - ord('a')] -= 1
        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1

    return s1_map == s2_map
```


",,
"```python
def maxVacationDays(flights, days):
    n = len(flights)
    k = len(days[0])
    memo = [[-1] * k for _ in range(n)]

    def dfs(currentWeek, currentCity):
        if currentWeek == k:
            return 0
        if memo[currentCity][currentWeek] != -1:
            return memo[currentCity][currentWeek]

        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)

        for i in range(n):
            if flights[currentCity][i] == 1:
                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))

        memo[currentCity][currentWeek] = maxVacation
        return maxVacation

    return dfs(0, 0)
```


",,
"
```javascript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function isSubtree(root, subRoot) {
    if (root === null) return false;
    if (isIdentical(root, subRoot)) return true;
    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

function isIdentical(n1, n2) {
    if (n1 === null || n2 === null) return n1 === n2;
    if (n1.val !== n2.val) return false;
    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);
}
```


",,
"```python
def minDistance(height, width, tree, squirrel, nuts):
    totalDist = 0
    minDiff = float(""inf"")
    
    for nut in nuts:
        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])
        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])
        
        totalDist += 2 * treeDist
        minDiff = min(minDiff, squirrelDist - treeDist)
    
    return totalDist + minDiff
```


",,
"```python
def maxNumberOfCandies(candyType):
    uniqueCandies = set(candyType)
    return min(len(uniqueCandies), len(candyType) // 2)
```


",,
"```python
def findPaths(m, n, maxMove, startRow, startColumn):               
    MOD = 10**9 + 7                     
    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]
    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))

    for k in range(1, maxMove + 1):                                
        for i in range(m):                                         
            for j in range(n):                                           
                for move in moves:              
                    ni, nj = i + move[0], j + move[1]
                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 
                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          
                    else:
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD

    return dp[maxMove][startRow][startColumn]
```

",,
"```python
def findUnsortedSubarray(nums):
    sorted_nums = sorted(nums)
    start, end = 0, len(nums) - 1
    while start < len(nums) and nums[start] == sorted_nums[start]:
        start += 1
    while end > start and nums[end] == sorted_nums[end]:
        end -= 1
    return end - start + 1
```

",,
"```python
from collections import defaultdict

def killProcess(pid, ppid, kill):
    children = defaultdict(list)
    for i in range(len(pid)):
        children[ppid[i]].append(pid[i])

    def dfs(id, killed):
        killed.append(id)
        for child in children[id]:
            dfs(child, killed)

    killed = []
    dfs(kill, killed)
    return killed
```

",,
"```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                dp[i][j] = i + j
            elif word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])

    return dp[m][n]
```

",,
"```python
def cross_product(p, q, r):
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])

def fence(trees):
    trees.sort(key=lambda p: (p[0], p[1]))
    hull = []
    for p in trees:
        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:
            hull.pop()
        hull.append(p)

    for p in reversed(trees):
        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:
            hull.pop()
        hull.append(p)
    
    return hull
```

",,
"```python
class FileSystem:
    class Node:
        def __init__(self):
            self.is_file = False
            self.content = """"
            self.children = {}

    def __init__(self):
        self.root = self.Node()

    def ls(self, path: str):
        node = self.root
        path_parts = self.split_path(path)

        for part in path_parts:
            node = node.children[part]

        if node.is_file:
            return path_parts[-1:]
        else:
            return sorted(node.children.keys())

    def mkdir(self, path: str):
        node = self.root
        path_parts = self.split_path(path)

        for part in path_parts:
            if part not in node.children:
                node.children[part] = self.Node()
            node = node.children[part]

    def addContentToFile(self, filePath: str, content: str):
        node = self.root
        path_parts = self.split_path(filePath)

        for part in path_parts:
            if part not in node.children:
                node.children[part] = self.Node()
            node = node.children[part]

        node.is_file = True
        node.content += content

    def readContentFromFile(self, filePath: str) -> str:
        node = self.root
        path_parts = self.split_path(filePath)

        for part in path_parts:
            node = node.children[part]

        return node.content

    @staticmethod
    def split_path(path: str):
        return [part for part in path.split(""/"") if part]

```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

def preorder(root):
    result = []
    if not root:
        return result
    nodes = [root]

    while nodes:
        current = nodes.pop()
        result.append(current.val)
        nodes.extend(reversed(current.children))
    return result
```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children or []

def postorder(root):
    result = []
    if not root:
        return result
    
    stk = [root]
    
    while stk:
        current = stk.pop()
        result.append(current.val)
        
        for child in current.children:
            stk.append(child)
    
    return result[::-1]
```

",,
"```python
def is_valid(code, i):
    if i >= len(code) or code[i] != '<':
        return False, i
    i += 1
    name_start = i
    while i < len(code) and code[i].isupper():
        i += 1
    name_len = i - name_start
    if name_len < 1 or name_len > 9 or code[i] != '>':
        return False, i
    i += 1

    while i < len(code) and code[i] != '<':
        i += 1
    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':
        return False, i
    return True, i + 2 + name_len

def validate_code_snippet(code):
    is_valid_code, i = is_valid(code, 0)
    return is_valid_code and i == len(code)
```

",,
"```python
from fractions import Fraction

def fractionAddition(expression: str) -> str:
    fractions = expression.replace('+', ' +').replace('-', ' -').split()
    result = sum(Fraction(fraction) for fraction in fractions)
    return f""{result.numerator}/{result.denominator}""
```

",,
"```python
def validSquare(p1, p2, p3, p4):
    def dist_sq(p, q):
        return (p[0] - q[0])**2 + (p[1] - q[1])**2

    points = [p1, p2, p3, p4]
    dists = set()

    for i in range(4):
        for j in range(i + 1, 4):
            dists.add(dist_sq(points[i], points[j]))

    return len(dists) == 2 and 0 not in dists
```

",,
"```python
def findLHS(nums):
    count = {}
    for num in nums:
        count[num] = count.get(num, 0) + 1

    longest_sequence = 0
    for key in count:
        if key + 1 in count:
            longest_sequence = max(longest_sequence, count[key] + count[key + 1])

    return longest_sequence
```

",,
"```python
def maxCount(m: int, n: int, ops: List[List[int]]) -> int:
    for op in ops:
        m = min(m, op[0])
        n = min(n, op[1])
    return m * n
```

",,
"```python
from typing import List

def findRestaurant(list1: List[str], list2: List[str]) -> List[str]:
    restaurantMap = {restaurant: i for i, restaurant in enumerate(list1)}

    minSum = float(""inf"")
    result = []
    for j, restaurant in enumerate(list2):
        if restaurant in restaurantMap:
            totalSum = j + restaurantMap[restaurant]
            if totalSum < minSum:
                result = [restaurant]
                minSum = totalSum
            elif totalSum == minSum:
                result.append(restaurant)

    return result
```


",,
"```python
def findIntegers(n: int) -> int:
    dp = [[0, 0] for _ in range(32)]
    dp[0][0], dp[0][1] = 1, 1

    for i in range(1, 32):
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]
        dp[i][1] = dp[i - 1][0]

    ans = 0
    prev_bit = 0
    for i in range(30, -1, -1):
        if n & (1 << i):
            ans += dp[i][0]
            if prev_bit:
                break
            prev_bit = 1
        else:
            prev_bit = 0

    return ans + 1
```


",,
"```python
class StringIterator:
    def __init__(self, compressedString: str):
        self.s = compressedString
        self.i = 0
        self.count = 0
        self.ch = "" ""
    
    def next(self) -> str:
        if not self.hasNext():
            return "" ""
        if self.count == 0:
            self.ch = self.s[self.i]
            self.i += 1
            while self.i < len(self.s) and self.s[self.i].isdigit():
                self.count = self.count * 10 + int(self.s[self.i])
                self.i += 1
        self.count -= 1
        return self.ch
    
    def hasNext(self) -> bool:
        return self.i < len(self.s) or self.count != 0
```


",,
"```python
def canPlaceFlowers(flowerbed, n):
    count = 0
    for i in range(len(flowerbed)):
        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):
            flowerbed[i] = 1
            count += 1
        if count >= n:
            return True
    return count >= n
```


",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def tree2str(t):
    if not t:
        return """"
    if not t.left and not t.right:
        return str(t.val)
    if not t.right:
        return ""{}({})"".format(t.val, tree2str(t.left))
    return ""{}({})({})"".format(t.val, tree2str(t.left), tree2str(t.right))
```

",,
"```python
from collections import defaultdict

def find_duplicate(paths):
    content_map = defaultdict(list)
    for path in paths:
        parts = path.split()
        directory = parts[0]
        for file in parts[1:]:
            start = file.index('(')
            end = file.index(')')
            content = file[start + 1:end]
            file_path = directory + '/' + file[:start]
            content_map[content].append(file_path)

    result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1]
    return result
```

",,
"```python
def triangleNumber(nums: list) -> int:
    nums.sort()
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            for k in range(j + 1, len(nums)):
                if nums[i] + nums[j] > nums[k]:
                    count += 1
                else:
                    break
    return count
```

",,
"```python
def addBoldTag(s: str, words: list) -> str:
    n = len(s)
    marked = [False] * n
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                marked[i] = True
            pos = s.find(word, pos + 1)
    result = []
    i = 0
    while i < n:
        if marked[i]:
            result.append(""<b>"")
            while i < n and marked[i]:
                result.append(s[i])
                i += 1
            result.append(""</b>"")
        else:
            result.append(s[i])
            i += 1
    return """".join(result)
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:
    if root1 is None: return root2
    if root2 is None: return root1

    root1.val += root2.val
    root1.left = merge_trees(root1.left, root2.left)
    root1.right = merge_trees(root1.right, root2.right)
    return root1
```

",,
"```python
from collections import Counter

def least_interval(tasks, n):
    task_freq = Counter(tasks)

    max_f = max(task_freq.values())
    max_count = sum(1 for count in task_freq.values() if count == max_f)

    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)
```


",,
"```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.size = k
        self.data = [0]*k
        self.front = -1
        self.rear = -1

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        if self.isEmpty():
            self.front = 0
        self.rear = (self.rear + 1) % self.size
        self.data[self.rear] = value
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.front == -1

    def isFull(self) -> bool:
        return (self.rear + 1) % self.size == self.front
```


",,
"```python
def add_one_row_helper(node, val, depth, current_depth):
    if not node:
        return
    if current_depth == depth - 1:
        left = node.left
        right = node.right
        node.left = TreeNode(val)
        node.left.left = left
        node.right = TreeNode(val)
        node.right.right = right
    else:
        add_one_row_helper(node.left, val, depth, current_depth + 1)
        add_one_row_helper(node.right, val, depth, current_depth + 1)
        
def add_one_row(root, val, depth):
    if depth == 1:
        new_root = TreeNode(val)
        new_root.left = root
        return new_root
    add_one_row_helper(root, val, depth, 1)
    return root
```

",,
"```python
def maxDistance(arrays: List[List[int]]) -> int:
    max_dist = 0
    min_val = arrays[0][0]
    max_val = arrays[0][-1]
    
    for arr in arrays[1:]:
        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))
        min_val = min(min_val, arr[0])
        max_val = max(max_val, arr[-1])
        
    return max_dist
```

",,
"```python
def smallestFactorization(num: int) -> int:
    if num == 1:
        return 1
    result = 0
    factor = 1
    for i in range(9, 1, -1):
        while num % i == 0:
            num //= i
            result += i * factor
            factor *= 10
            if result > 2**31 - 1:
                return 0
    return result if num == 1 else 0
```

",,
"```python
def maximumProduct(nums):
    nums.sort()
    n = len(nums)
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])
```

",,
"```python
def kInversePairs(n: int, k: int) -> int:
    mod = 10**9 + 7
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        dp[i][0] = 1
        for j in range(1, k + 1):
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod
            if j - i >= 0:
                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod
    return dp[n][k]
```

",,
"```python
import heapq

def scheduleCourse(courses):
    courses.sort(key=lambda x: x[1])
    curr_time, duration_sum = 0, []

    for duration, deadline in courses:
        curr_time += duration
        heapq.heappush(duration_sum, -duration)

        if curr_time > deadline:
            curr_time += heapq.heappop(duration_sum)

    return len(duration_sum)
```

",,
"```python
class Excel:

    def __init__(self, height: int, width: str):
        self.mat = [[0] * (ord(width) - ord('A') + 1) for _ in range(height)]
        self.formulas = {}

    def set(self, row: int, column: str, val: int) -> None:
        pos = column + str(row)
        if pos in self.formulas:
            del self.formulas[pos]
        self.mat[row - 1][ord(column) - ord('A')] = val

    def get(self, row: int, column: str) -> int:
        pos = column + str(row)
        if pos in self.formulas:
            return self.sum(row, column, self.formulas[pos])
        return self.mat[row - 1][ord(column) - ord('A')]

    def sum(self, row: int, column: str, numbers) -> int:
        total = 0
        for num in numbers:
            if ':' in num:
                start, end = num.split(':')
                start_row, end_row = int(start[1:]), int(end[1:])
                start_col, end_col = start[0], end[0]
                for r in range(start_row, end_row + 1):
                    for c in range(ord(start_col), ord(end_col) + 1):
                        total += self.get(r, chr(c))
            else:
                total += self.get(int(num[1:]), num[0])
        self.set(row, column, total)
        self.formulas[column + str(row)] = numbers
        return total
```


",,
"```python
import heapq

def smallestRange(nums):
    minHeap = []
    maxVal = -1e9
    
    for i, lst in enumerate(nums):
        heapq.heappush(minHeap, (lst[0], i))
        maxVal = max(maxVal, lst[0])
        
    listIndices = [0] * len(nums)
    minRange = 1e9
    start, end = -1, -1
    
    while len(minHeap) == len(nums):
        val, listIdx = heapq.heappop(minHeap)
        range_ = maxVal - val
        
        if range_ < minRange:
            minRange = range_
            start, end = val, maxVal
            
        listIndices[listIdx] += 1
        if listIndices[listIdx] < len(nums[listIdx]):
            newVal = nums[listIdx][listIndices[listIdx]]
            heapq.heappush(minHeap, (newVal, listIdx))
            maxVal = max(maxVal, newVal)
            
    return [start, end]
```

",,
"```python
def judge_square_sum(c):
    for a in range(int(c ** 0.5) + 1):
        b = int((c - a * a) ** 0.5)
        if a * a + b * b == c:
            return True
    return False
```

",,
"```python
def findDerangement(n: int) -> int:
    MOD = 10**9 + 7
    dp = [0] * (n + 1)
    dp[2] = 1
    for i in range(3, n + 1):
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD
    return dp[n]
```

",,
"```python
class LogSystem:

    def __init__(self):
        self.logs = {}
        self.time_granularity = {
            ""Year"": 0, ""Month"": 1, ""Day"": 2, ""Hour"": 3, ""Minute"": 4, ""Second"": 5
        }
        self.size_map = [4, 7, 10, 13, 16, 19]

    def put(self, id: int, timestamp: str) -> None:
        self.logs[timestamp] = id

    def retrieve(self, start: str, end: str, granularity: str) -> list[int]:
        size_substring = self.size_map[self.time_granularity[granularity]]
        res = []

        for k, v in self.logs.items():
            if start[:size_substring] <= k[:size_substring] <= end[:size_substring]:
                res.append(v)

        return res
```


",,
"```python
def exclusiveTime(n, logs):
    res = [0] * n
    stack = []
    prev_time = 0

    for log in logs:
        parts = log.split(':')
        id = int(parts[0])
        type = parts[1]
        time = int(parts[2])

        if type == ""start"":
            if stack:
                res[stack[-1]] += time - prev_time
            stack.append(id)
            prev_time = time
        else:
            res[stack.pop()] += time - prev_time + 1
            prev_time = time + 1

    return res
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def averageOfLevels(root: TreeNode):
    result = []
    queue = [root]

    while queue:
        sum_ = 0
        count = 0
        temp = []
        while queue:
            node = queue.pop(0)
            sum_ += node.val
            count += 1
            if node.left: temp.append(node.left)
            if node.right: temp.append(node.right)
        queue = temp
        result.append(sum_ / count)

    return result
```

",,
"```python
from typing import List

def shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:
    def helper(index):
        if index == len(special):
            return sum(needs[i] * price[i] for i in range(len(needs)))

        no_offer = helper(index + 1)
        can_apply_offer = True
        for i in range(len(needs)):
            needs[i] -= special[index][i]
            if needs[i] < 0:
                can_apply_offer = False

        with_offer = float('inf')
        if can_apply_offer:
            offer_cost = special[index][-1] + helper(index)
            with_offer = min(no_offer, offer_cost)

        for i in range(len(needs)):
            needs[i] += special[index][i]
        
        return with_offer if can_apply_offer else no_offer

    return helper(0)
```


",,
"```python
def num_decodings(s: str) -> int:
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)

    for i in range(2, n + 1):
        c, prev_c = s[i - 1], s[i - 2]
        
        if c == '*':
            dp[i] = 9 * dp[i - 1]
            if prev_c == '1': dp[i] += 9 * dp[i - 2]
            elif prev_c == '2': dp[i] += 6 * dp[i - 2]
            elif prev_c == '*': dp[i] += 15 * dp[i - 2]
        else:
            dp[i] = dp[i - 1] if c != '0' else 0
            num = int(s[i - 2 : i])
            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]
            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]

        dp[i] %= MOD
    return dp[n]
```

",,
"```python
def solve_equation(equation: str) -> str:
    coef = val = left = operate = 0
    equation += '+'
    parts = [s.strip()+c for c in equation if c in '+-' for s in equation.split(c)]
    for part in parts:
        if part == '=':
            left = -1
            operate = 1
        else:
            n, x = part.split('x')
            value_to_change = 1 if n else int(n)
            if x:
                coef += (1 if part[0] == '+' else -1) * left * operate * value_to_change
            else:
                val += (1 if part[0] == '+' else -1) * left * operate * value_to_change
            operate = 1 - x.find('x')

    if coef == 0:
        return ""Infinite solutions"" if val == 0 else ""No solution""
    return ""x="" + str(-val // coef)
```


",,
"```python
class MyCircularDeque:

    def __init__(self, k: int):
        self.buffer = [0] * k
        self.front = -1
        self.rear = 0
        self.capacity = k

    def insertFront(self, value: int) -> bool:
        if self.isFull():
            return False
        if self.front == -1:
            self.front = 0
        else:
            self.front = (self.front - 1 + self.capacity) % self.capacity
        self.buffer[self.front] = value
        return True

    def insertLast(self, value: int) -> bool:
        if self.isFull():
            return False
        self.buffer[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        if self.front == -1:
            self.front = 0
        return True

    def deleteFront(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear - 1:
            self.front = -1
        else:
            self.front = (self.front + 1) % self.capacity
        return True

    def deleteLast(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear - 1:
            self.rear = 0
            self.front = -1
        else:
            self.rear = (self.rear - 1 + self.capacity) % self.capacity
        return True

    def getFront(self) -> int:
        if self.isEmpty():
            return -1
        return self.buffer[self.front]

    def getRear(self) -> int:
        if self.isEmpty():
            return -1
        return self.buffer[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.front == -1

    def isFull(self) -> bool:
        return self.front == self.rear
```

",,
"```python
from typing import List
import heapq

class TrieNode:
    def __init__(self):
        self.children = {}
        self.sentence = """"
        self.times = 0

class AutocompleteSystem:

    def __init__(self, sentences: List[str], times: List[int]):
        self.root = TrieNode()
        self.current = self.root
        self.search = """"
        
        for i in range(len(sentences)):
            self.insert(sentences[i], times[i])

    def insert(self, sentence: str, times: int):
        curr = self.root
        for c in sentence:
            if c not in curr.children:
                curr.children[c] = TrieNode()
            curr = curr.children[c]
        curr.sentence = sentence
        curr.times += times

    def input(self, c: str) -> List[str]:
        if c == '#':
            self.insert(self.search, 1)
            self.search = """"
            self.current = self.root
            return []
        
        self.search += c
        if not self.current:
            return []
        
        if c not in self.current.children:
            self.current = None
            return []
        
        self.current = self.current.children[c]
        heap = []
        for child in self.current.children.values():
            if child.times:
                heapq.heappush(heap, (-child.times, child.sentence))
        
        res = []
        for _ in range(3):
            if not heap:
                break
            res.append(heapq.heappop(heap)[1])
        return res
```


",,
"```python
def findMaxAverage(nums, k):
    n = len(nums)
    sum_ = sum(nums[:k])
    max_avg = sum_ / k
    for i in range(k, n):
        sum_ = sum_ - nums[i - k] + nums[i]
        max_avg = max(max_avg, sum_ / k)
    return max_avg
```

",,
"```python
def findMaxAverage(nums, k):
    total = sum(nums[:k])
    max_avg = total / k
    for i in range(k, len(nums)):
        total += nums[i] - nums[i - k]
        max_avg = max(max_avg, total / k)
    return max_avg
```

",,
"```python
def findErrorNums(nums):
    result = []
    for num in nums:
        index = abs(num) - 1
        if nums[index] > 0:
            nums[index] = -nums[index]
        else:
            result.append(index + 1)
    for i, num in enumerate(nums):
        if num > 0:
            result.append(i + 1)
            break
    return result
```

",,
"```python
def findLongestChain(pairs):
    pairs.sort(key=lambda x: x[1])

    max_chain_length = 0
    last_right = float('-inf')
    for pair in pairs:
        if pair[0] > last_right:
            last_right = pair[1]
            max_chain_length += 1

    return max_chain_length
```


",,
"```python
def countSubstrings(s: str) -> int:
    n = len(s)
    count = 0
    for center in range(2 * n - 1):
        left = center // 2
        right = left + center % 2
        while left >= 0 and right < n and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
    return count
```

",,
"```python
def replaceWords(dict, sentence):
    roots = set(dict)
    words = sentence.split()
    result = []

    for word in words:
        prefix = ''
        for i in range(1, len(word) + 1):
            prefix = word[:i]
            if prefix in roots:
                break
        result.append(prefix)

    return ' '.join(result)
```

",,
"```python
from collections import deque

def predict_party_victory(senate: str) -> str:
    radiant = deque()
    dire = deque()
    n = len(senate)
    
    for i, s in enumerate(senate):
        if s == 'R':
            radiant.append(i)
        else:
            dire.append(i)

    while radiant and dire:
        r = radiant.popleft()
        d = dire.popleft()

        if r < d:
            radiant.append(r + n)
        else:
            dire.append(d + n)

    return ""Dire"" if not radiant else ""Radiant""
```


",,
"```python
def min_steps(n):
    result = 0
    i = 2
    while i <= n:
        while n % i == 0:
            result += i
            n //= i
        i += 1
    return result
```

",,
"```python
def maxA(n: int) -> int:
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        dp[i] = i
        for j in range(1, i - 2):
            dp[i] = max(dp[i], dp[j] * (i - j - 1))
    return dp[n]
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findDuplicateSubtrees(root):
    tree_count = {}
    result = []
    findDuplicateSubtreesHelper(root, tree_count, result)
    return result

def findDuplicateSubtreesHelper(root, tree_count, result):
    if root is None:
        return """"
    subtree = ""{},{},{}"".format(root.val, findDuplicateSubtreesHelper(root.left, tree_count, result), findDuplicateSubtreesHelper(root.right, tree_count, result))
    tree_count[subtree] = tree_count.get(subtree, 0) + 1
    if tree_count[subtree] == 2:
        result.append(root)
    return subtree
```


",,
"```python
def findTarget(root, k):
    nodes = set()
    return findNode(root, k, nodes)

def findNode(root, k, nodes):
    if not root:
        return False
    if k - root.val in nodes:
        return True
    nodes.add(root.val)
    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def constructMaximumBinaryTree(nums):
    def helper(nums, left, right):
        if left > right:
            return None

        maxIdx = left
        for i in range(left + 1, right + 1):
            if nums[i] > nums[maxIdx]:
                maxIdx = i

        root = TreeNode(nums[maxIdx])
        root.left = helper(nums, left, maxIdx - 1)
        root.right = helper(nums, maxIdx + 1, right)
        return root

    return helper(nums, 0, len(nums) - 1)
```


",,
"```python
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
def printTree(root):
    if not root:
        return [[]]

    # Calculate Depth
    depth = 0
    q = deque([root])
    while q:
        depth += 1
        for _ in range(len(q)):
            node = q.popleft()
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

    res = [["""" for _ in range((1 << depth) - 1)] for _ in range(depth)]

    # Fill in matrix
    q.append(root)
    level = 0
    step = (1 << (depth - 1))
    while q:
        cur_pos = step - 1
        for _ in range(len(q)):
            node = q.popleft()
            res[level][cur_pos] = str(node.val)
            cur_pos += (step << 1)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        step >>= 1
        level += 1

    return res
```


",,
"```python
def cheapestJump(coins, maxJump):
    n = len(coins)
    dp = [float('inf')] * n
    parent = [-1] * n
    dp[0] = coins[0]
    for i in range(n):
        if coins[i] == -1:
            continue
        for j in range(1, maxJump + 1):
            if i + j >= n:
                break
            next = i + j
            cost = coins[next] + dp[i]
            if cost < dp[next]:
                dp[next] = cost
                parent[next] = i
    ans = []
    if dp[n - 1] == float('inf'):
        return ans
    cur = n - 1
    while cur != -1:
        ans.append(cur + 1)
        cur = parent[cur]
    ans.reverse()
    return ans
```

",,
"```python
def judgeCircle(moves: str) -> bool:
    x, y = 0, 0
    for move in moves:
        if move == 'U': y += 1
        elif move == 'D': y -= 1
        elif move == 'R': x += 1
        elif move == 'L': x -= 1
    return x == 0 and y == 0
```

",,
"```python
from typing import List

def findClosestElements(arr: List[int], k: int, x: int) -> List[int]:
    left = 0
    right = len(arr) - k

    while left < right:
        mid = left + (right - left) // 2
        if x - arr[mid] > arr[mid + k] - x:
            left = mid + 1
        else:
            right = mid

    return arr[left:left + k]
```

",,
"```python
def can_split(nums):
    freq = [0] * 20001
    needed = [0] * 20001
    for n in nums:
        freq[n] += 1
    for n in nums:
        if not freq[n]: continue
        if not needed[n - 1]:
            if freq[n + 1] and freq[n + 2]:
                freq[n] -= 1; freq[n + 1] -= 1; freq[n + 2] -= 1;
                needed[n + 2] += 1
            else: return False
        else:
            freq[n] -= 1; needed[n - 1] -= 1;
            needed[n] += 1
    return True
```

",,
"```python
def newInteger(n):
    result = 0
    base = 1
    while n:
        result += n % 9 * base
        n //= 9
        base *= 10
    return result
```

",,
"```python
def imageSmoother(img):
    m, n = len(img), len(img[0])
    result = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            count, total = 0, 0
            for x in range(i - 1, i + 2):
                for y in range(j - 1, j + 2):
                    if 0 <= x < m and 0 <= y < n:
                        total += img[x][y]
                        count += 1
            result[i][j] = total // count

    return result
```

",,
"```python
from collections import deque

def widthOfBinaryTree(root):
    if not root:
        return 0

    maxWidth = 0
    q = deque([(root, 1)])

    while q:
        levelSize = len(q)
        left, _ = q[0]
        right = left
        for _ in range(levelSize):
            node, pos = q.popleft()
            right = pos

            if node.left:
                q.append((node.left, 2 * pos))
            if node.right:
                q.append((node.right, 2 * pos + 1))
        
        maxWidth = max(maxWidth, right - left + 1)
    
    return maxWidth
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def checkEqualTree(self, root: TreeNode) -> bool:
        def _sum(node, seen):
            if not node:
                return 0
            s = node.val + _sum(node.left, seen) + _sum(node.right, seen)
            seen.add(s)
            return s

        seen = set()
        total = _sum(root, seen)
        return total % 2 == 0 and (total // 2) in seen
```


",,
"```python
def strange_printer(s: str) -> int:
    n = len(s)
    if n == 0: return 0
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 1
    for len in range(1, n):
        for i in range(n - len):
            j = i + len
            dp[i][j] = dp[i+1][j] + 1
            for k in range(i + 1, j + 1):
                if s[i] == s[k]:
                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])
    return dp[0][n-1]
```

",,
"```python
def checkPossibility(nums):
    cnt = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            cnt += 1
            if i == 1 or nums[i] >= nums[i - 2]:
                nums[i-1] = nums[i]
            else:
                nums[i] = nums[i - 1]
            if cnt > 1:
                return False
    return True
```

",,
"```python
def sumPaths(root, val):
    if not root: return 0
    val = val * 10 + root.val
    if not root.left and not root.right: return val
    return sumPaths(root.left, val) + sumPaths(root.right, val)

def pathSum(nums):
    root = TreeNode(nums[0] % 10)
    for num in nums:
        depth, pos, val = num // 100, num % 100 // 10, num % 10
        cur = root
        for d in reversed(range(depth - 1)):
            if (pos >> d) & 1:
                if not cur.right: cur.right = TreeNode(val)
                cur = cur.right
            else:
                if not cur.left: cur.left = TreeNode(val)
                cur = cur.left
    return sumPaths(root, 0)
```

",,
"```python
def constructArray(n: int, k: int) -> List[int]:
    answer = [0] * n
    for i in range(n):
        if i % 2 == 0:
            answer[i] = i // 2 + 1
        else:
            answer[i] = n - (i - 1) // 2
            k -= 1
    if k > 0:
        for i in range(n - 2, -1, -1):
            if k > 0:
                answer[i] = answer[i + 1] - answer[i]
                k -= 1
    return answer
```

",,
"```python
def findKthNumber(m, n, k):
    low, high = 1, m * n
    while low < high:
        mid = low + (high - low) // 2
        count = 0
        for i in range(1, m+1):
            count += min(mid // i, n)
        if count < k:
            low = mid + 1
        else:
            high = mid
    return low
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
    if not root:
        return None

    if root.val < low:
        return self.trimBST(root.right, low, high)
    elif root.val > high:
        return self.trimBST(root.left, low, high)
    else:
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)

    return root
```

",,
"```python
def maximumSwap(num):
    num_str = list(str(num))
    last = {int(v): i for i, v in enumerate(num_str)}

    for i, v in enumerate(num_str):
        for d in range(9, int(v), -1):
            if last.get(d, -1) > i:
                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]
                return int("""".join(num_str))

    return num
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_second_minimum_value(root, current=-1):
    if root is None:
        return current
    if current == -1 or root.val < current:
        current = root.val
    if root.left is not None and root.right is not None:
        if root.val == root.left.val:
            current = find_second_minimum_value(root.left, current)
            if root.val != root.right.val:
                current = root.right.val if current == -1 else min(current, root.right.val)
        else:
            current = find_second_minimum_value(root.right, current)
            if root.val != root.left.val:
                current = root.left.val if current == -1 else min(current, root.left.val)
    return current
```

",,
"```python
def num_light_configuration(n, presses):
    dp = [[0] * (presses + 1) for _ in range(n+1)]
    dp[0][0] = 1

    for i in range(n + 1):
        for j in range(1, presses + 1):
            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)

    return dp[n][presses]
```

",,
"```python
def findNumberOfLIS(nums):
    n = len(nums)
    maxLength = ans = 0
    length = [1] * n
    count = [1] * n

    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                if length[i] == length[j] + 1:
                    count[i] += count[j]
                elif length[i] < length[j] + 1:
                    length[i] = length[j] + 1
                    count[i] = count[j]
        if maxLength == length[i]:
            ans += count[i]
        elif maxLength < length[i]:
            maxLength = length[i]
            ans = count[i]

    return ans
```


",,
"```python
def findLengthOfLCIS(nums):
    if not nums:
        return 0
    result, current = 1, 1
    for i in range(1, len(nums)):
        current = current + 1 if nums[i] > nums[i - 1] else 1
        result = max(result, current)
    return result
```

",,
"```python
from heapq import heappush, heappop
from collections import deque

def cutOffTree(forest: List[List[int]]) -> int:
    if not forest or not forest[0]: return 0
    m, n = len(forest), len(forest[0])
    trees = []
    
    for i in range(m):
        for j in range(n):
            if forest[i][j] > 1:
                heappush(trees, (forest[i][j], i, j))
    
    startX, startY = 0, 0
    totalSteps = 0
    while trees:
        tree, endX, endY = heappop(trees)
        steps = bfs(forest, startX, startY, endX, endY)
        if steps == -1:
            return -1
        totalSteps += steps
        startX, startY = endX, endY
    
    return totalSteps

def bfs(forest, startX, startY, endX, endY):
    if startX == endX and startY == endY:
        return 0
        
    m, n = len(forest), len(forest[0])
    visited = [[False] * n for _ in range(m)]
    q = deque([(startX, startY, 0)])
    visited[startX][startY] = True
    dirs = [-1, 0, 1, 0, -1]
    
    while q:
        x, y, steps = q.popleft()
        for k in range(4):
            newX, newY = x + dirs[k], y + dirs[k+1]
            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:
                if newX == endX and newY == endY:
                    return steps + 1
                q.append((newX, newY, steps + 1))
                visited[newX][newY] = True
    
    return -1
```

",,
"```python
class MagicDictionary:

    def __init__(self):
        self.word_list = {}

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            if len(word) not in self.word_list:
                self.word_list[len(word)] = []
            self.word_list[len(word)].append(word)

    def search(self, searchWord: str) -> bool:
        if len(searchWord) in self.word_list:
            for word in self.word_list[len(searchWord)]:
                diff = sum(c1 != c2 for c1, c2 in zip(searchWord, word))
                if diff == 1: return True
        return False
```

",,
"```python
class MapSum:
    def __init__(self):
        self.map = {}

    def insert(self, key: str, val: int) -> None:
        self.map[key] = val

    def sum(self, prefix: str) -> int:
        total = 0
        for key, value in self.map.items():
            if key.startswith(prefix):
                total += value
        return total
```

",,
"```python
def checkValidString(s: str) -> bool:
    left_balance, right_balance = 0, 0

    for i in range(len(s)):
        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1
        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1

        if left_balance < 0 or right_balance < 0:
            return False

    return True
```


",,
"```python
from itertools import permutations

def helper(cards, target=24):
    if len(cards) == 1:
        return abs(cards[0] - target) < 1e-6

    for i in range(len(cards)):
        for j in range(i + 1, len(cards)):
            a, b = cards[i], cards[j]
            rest = [cards[k] for k in range(len(cards)) if k != i and k != j]
            for e in a + b, a - b, a * b, a / b:
                if helper(rest + [e]):
                    return True
    return False

def canGet24(cards):
    return helper(cards)
```


",,
"```python
def validPalindrome(s: str) -> bool:
    i, j = 0, len(s) - 1
    while i < j:
        if s[i] != s[j]:
            temp1, temp2 = i + 1, j
            while temp1 < temp2 and s[temp1] == s[temp2]:
                temp1 += 1
                temp2 -= 1
            if temp1 >= temp2:
                return True

            temp1, temp2 = i, j - 1
            while temp1 < temp2 and s[temp1] == s[temp2]:
                temp1 += 1
                temp2 -= 1
            if temp1 >= temp2:
                return True

            return False
        i += 1
        j -= 1
    return True
```

",,
"```python
def nextClosestTime(time: str) -> str:
    digits = time[:2] + time[3:]
    next_time = time
    elapsed = float('inf')

    for a in digits:
        for b in digits:
            for c in digits:
                for d in digits:
                    candidate_time = f""{a}{b}:{c}{d}""
                    cand_elapsed = (int(candidate_time[:2]) * 60 + int(candidate_time[3:]) -
                                    int(time[:2]) * 60 - int(time[3:]) + 1440) % 1440
                    if 0 < cand_elapsed < elapsed:
                        elapsed = cand_elapsed
                        next_time = candidate_time

    return next_time
```

",,
"```python
def calPoints(ops):
    record = []
    for op in ops:
        if op == '+':
            record.append(record[-1] + record[-2])
        elif op == 'D':
            record.append(record[-1] * 2)
        elif op == 'C':
            record.pop()
        else:
            record.append(int(op))
    return sum(record)
```


",,
"```python
def kEmptySlots(bulbs, k):
    days = [0] * len(bulbs)
    for i, bulb in enumerate(bulbs):
        days[bulb - 1] = i

    ans = float('inf')
    left = 0
    right = k + 1
    while right < len(days):
        i = left + 1
        for i in range(left + 1, right):
            if days[i] < days[left] or days[i] < days[right]:
                left = i
                break
        else:
            ans = min(ans, max(days[left], days[right]))
            left += 1
            right += 1

    return -1 if ans == float('inf') else ans + 1
```


",,
"```python
from typing import List

def findRedundantConnection(edges: List[List[int]]) -> List[int]:
    def find(parent, x):
        if parent[x] != x:
            parent[x] = find(parent, parent[x])
        return parent[x]

    parent = list(range(len(edges) + 1))
    for edge in edges:
        root1 = find(parent, edge[0])
        root2 = find(parent, edge[1])
        if root1 == root2:
            return edge
        parent[root1] = root2
    return []
```


",,
"```python
def findRedundantDirectedConnection(edges):
    parent = [0] * (len(edges) + 1)
    candidateA = candidateB = None

    for u, v in edges:
        if parent[v] > 0:
            candidateA = [parent[v], v]
            candidateB = [u, v]
        else:
            parent[v] = u

    for i in range(1, len(edges) + 1):
        cycle = i
        steps = len(edges)
        while parent[cycle] != 0 and steps > 0:
            cycle = parent[cycle]
            steps -= 1
        if steps == 0:
            if not candidateA:
                return [parent[i], i]
            else:
                return candidateA

    return candidateB
```


",,
"```python
def min_repeats_to_substring(a: str, b: str) -> int:
    times = (len(b) + len(a) - 1) // len(a)

    for i in range(2):
        repeated_a = a * (times + i)
        if b in repeated_a:
            return times + i

    return -1
```

",,
"```python
def longestUnivaluePath(root):
    def findUnivaluePath(node):
        if not node:
            return 0
        left = findUnivaluePath(node.left)
        right = findUnivaluePath(node.right)
        left = left + 1 if node.left and node.left.val == node.val else 0
        right = right + 1 if node.right and node.right.val == node.val else 0
        maxLen[0] = max(maxLen[0], left + right)
        return max(left, right)

    maxLen = [0]
    findUnivaluePath(root)
    return maxLen[0]
```


",,
"```python
def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
    return self.helper(n, k, row, column, memo)

def helper(self, n, k, row, column, memo):
    if row < 0 or row >= n or column < 0 or column >= n:
        return 0.0
    if k == 0:
        return 1.0
    if memo[row][column][k] >= 0:
        return memo[row][column][k]

    result = 0.0
    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
    for move in moves:
        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8

    memo[row][column][k] = result
    return result
```

",,
"```python
def max_sum_of_three_subarrays(nums, k):
    n = len(nums)
    sums = [0] * (n - k + 1)
    left, right = [0] * n, [0] * n

    acc_sum = 0
    for i in range(n):
        acc_sum += nums[i]
        if i >= k:
            acc_sum -= nums[i - k]
        if i >= k - 1:
            sums[i - k + 1] = acc_sum

    left[0] = 0
    right[n - k] = n - k
    for i in range(1, n - k + 1):
        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]

    for i in range(n - k - 1, -1, -1):
        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]

    max_sum, ans = 0, [0] * 3
    for i in range(k, n - 2 * k + 1):
        left_idx, right_idx = left[i - k], right[i + k]
        total_sum = sums[left_idx] + sums[i] + sums[right_idx]
        if total_sum > max_sum:
            max_sum = total_sum
            ans = [left_idx, i, right_idx]

    return ans
```

",,
"```python
class Employee:
    def __init__(self, id: int, importance: int, subordinates: list):
        self.id = id
        self.importance = importance
        self.subordinates = subordinates

def getTotalImportance(employees, id):
    emap = {emp.id: emp for emp in employees}
    return dfs(emap, id)

def dfs(emap, id):
    emp = emap[id]
    return emp.importance + sum(dfs(emap, sub_id) for sub_id in emp.subordinates)
```

",,
"```python
from collections import Counter
from functools import lru_cache

def minStickers(stickers, target):
    target_count = Counter(target)
    memo = {}
    
    for s in stickers:
        sticker_count = Counter(s)
        state = ''.join(sticker_count & target_count)
        memo[state] = 1
    
    @lru_cache(None)
    def dp(state):
        counts = Counter(state)
        ans = float('inf')
        for key, value in memo.items():
            if any(counts[ch] < key.count(ch) for ch in state): continue
            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)
        return -1 if ans == float('inf') else ans
    
    return dp(target)
```

",,
"```python
import heapq
from collections import Counter

def k_frequent_words(words, k):
    word_count = Counter(words)
    heap = [(-count, word) for word, count in word_count.items()]
    heapq.heapify(heap)

    result = []
    for _ in range(k):
        result.append(heapq.heappop(heap)[1])

    return result
```

",,
"```python
def has_alternating_bits(n):
    prev_bit = n % 2
    n //= 2
    while n > 0:
        curr_bit = n % 2
        if curr_bit == prev_bit:
            return False
        prev_bit = curr_bit
        n //= 2
    return True
```


",,
"```python
def numDistinctIslands(grid):
    unique_islands = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                island_shape = []
                dfs(grid, i, j, i, j, island_shape)
                island_shape.sort()
                unique_islands.add(tuple(island_shape))
    return len(unique_islands)

def dfs(grid, i, j, i0, j0, shape):
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
        grid[i][j] = 2
        shape.append((i - i0, j - j0))
        dfs(grid, i - 1, j, i0, j0, shape)
        dfs(grid, i + 1, j, i0, j0, shape)
        dfs(grid, i, j - 1, i0, j0, shape)
        dfs(grid, i, j + 1, i0, j0, shape)
```

",,
"```python
def maxAreaOfIsland(grid):
    def dfs(i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return 0
        grid[i][j] = 0
        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)

    max_area = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j]:
                max_area = max(max_area, dfs(i, j))
    return max_area
```

",,
"```python
def count_binary_substrings(s: str) -> int:
    prev, curr, result = 0, 1, 0
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            curr += 1
        else:
            result += min(prev, curr)
            prev, curr = curr, 1
    return result + min(prev, curr)
```

",,
"```python
def findShortestSubArray(nums):
    freq_map, start_map = {}, {}
    max_freq, min_length = 0, len(nums)

    for i, num in enumerate(nums):
        if num not in start_map:
            start_map[num] = i
        freq_map[num] = freq_map.get(num, 0) + 1

        freq = freq_map[num]
        if freq > max_freq:
            max_freq = freq
            min_length = i - start_map[num] + 1
        elif freq == max_freq:
            min_length = min(min_length, i - start_map[num] + 1)

    return min_length
```

",,
"```python
def canPartitionKSubsets(nums, k):
    total_sum = sum(nums)
    if total_sum % k != 0:
        return False
    target = total_sum // k
    visited = [False] * len(nums)
    return dfs(nums, visited, 0, target, 0, k)

def dfs(nums, visited, start, target, curr_sum, k):
    if k == 1:
        return True
    if curr_sum == target:
        return dfs(nums, visited, 0, target, 0, k - 1)
    for i in range(start, len(nums)):
        if not visited[i] and curr_sum + nums[i] <= target:
            visited[i] = True
            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):
                return True
            visited[i] = False
    return False
```

",,
"```python
def fallingSquares(positions):
    ans = []
    intervals = []

    for p in positions:
        L, size = p
        R = L + size
        h = size
        for h2, R2 in intervals:
            if R2 > L and R > R2:
                h = max(h, size + h2)

        maxHeight = max((h2 for h2, R2 in intervals), default=0)
        ans.append(max(maxHeight, h))
        intervals.append((h, R))

    return ans
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root: TreeNode, val: int) -> TreeNode:
    if not root or root.val == val:
        return root
    return searchBST(root.right, val) if root.val < val else searchBST(root.left, val)
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def insertIntoBST(root, val):
    if root is None:
        return TreeNode(val)

    if val < root.val:
        root.left = insertIntoBST(root.left, val)
    else:
        root.right = insertIntoBST(root.right, val)

    return root
```

",,
"```python
def search(reader, target):
    left, right = 0, 1
    while reader.get(right) < target:
        left = right
        right <<= 1

    while left <= right:
        mid = left + ((right - left) >> 1)
        val = reader.get(mid)
        if val == target:
            return mid
        if val > target:
            right = mid - 1
        else:
            left = mid + 1
    return -1
```

",,
"```python
import heapq

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)
        
        while len(self.min_heap) > k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        if len(self.min_heap) < self.k:
            heapq.heappush(self.min_heap, val)
        elif val > self.min_heap[0]:
            heapq.heappushpop(self.min_heap, val)
        return self.min_heap[0]
```

",,
"```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```


",,
"```python
class MyHashSet:

    def __init__(self):
        self.storage = [False] * 1000001

    def add(self, key: int):
        self.storage[key] = True

    def remove(self, key: int):
        self.storage[key] = False

    def contains(self, key: int) -> bool:
        return self.storage[key]
```


",,
"```python
class MyHashMap:
    def __init__(self):
        self.size = 10007
        self.data = [[] for _ in range(self.size)]

    def put(self, key: int, value: int) -> None:
        bucket = self.data[key % self.size]
        for pair in bucket:
            if pair[0] == key:
                pair[1] = value
                return
        bucket.append([key, value])

    def get(self, key: int) -> int:
        bucket = self.data[key % self.size]
        for pair in bucket:
            if pair[0] == key:
                return pair[1]
        return -1

    def remove(self, key: int) -> None:
        bucket = self.data[key % self.size]
        for i, pair in enumerate(bucket):
            if pair[0] == key:
                bucket.pop(i)
                return
```

",,
"```python
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        cur = self.head
        for _ in range(index):
            cur = cur.next
        return cur.val

    def addAtHead(self, val: int) -> None:
        self.head = Node(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        if self.size == 0:
            self.addAtHead(val)
        else:
            cur = self.head
            while cur.next:
                cur = cur.next
            cur.next = Node(val)
            self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        if index == 0:
            self.addAtHead(val)
        else:
            cur = self.head
            for _ in range(index - 1):
                cur = cur.next
            cur.next = Node(val, cur.next)
            self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        if index == 0:
            self.head = self.head.next
        else:
            cur = self.head
            for _ in range(index - 1):
                cur = cur.next
            cur.next = cur.next.next
        self.size -= 1
```

",,
"```python
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insert(head, insertVal):
    if head is None:
        newNode = Node(insertVal)
        newNode.next = newNode
        return newNode

    prev, curr = head, head.next
    inserted = False

    while True:
        if prev.val <= insertVal <= curr.val:
            prev.next = Node(insertVal, curr)
            inserted = True
        elif prev.val > curr.val:
            if insertVal >= prev.val or insertVal <= curr.val:
                prev.next = Node(insertVal, curr)
                inserted = True
        prev, curr = curr, curr.next

        if prev == head or inserted:
            break

    if not inserted:
        prev.next = Node(insertVal, curr)

    return head
```


",,
"```python
def toLowerCase(s: str) -> str:
    return s.lower()
```

",,
"```python
import random

class Solution:
    def __init__(self, n: int, blacklist: List[int]):
        blacklist.sort()
        self.mapping = dict()
        idx = 0
        for black in blacklist:
            while idx < black:
                self.mapping[idx] = n - 1
                idx += 1
                n -= 1
            idx += 1
            n -= 1
        self.last = n

    def pick(self) -> int:
        num = random.randrange(self.last)
        return self.mapping.get(num, num)
```

",,
"```python
class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        def dfs(r, c, r0, c0):
            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]:
                grid[r][c] = 0
                island.append((r - r0, c - c0))
                dfs(r + 1, c, r0, c0)
                dfs(r - 1, c, r0, c0)
                dfs(r, c + 1, r0, c0)
                dfs(r, c - 1, r0, c0)

        def normalize(island):
            ret = []
            for p in island:
                x, y = p
                ret += [(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]
            ret.sort()
            return tuple(ret)

        distinctIslands = set()
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c]:
                    island = []
                    dfs(r, c, r, c)
                    distinctIslands.add(normalize(island))
        return len(distinctIslands)
```


",,
"```python
def minimumDeleteSum(s1: str, s2: str) -> int:
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    for i in range(1, len(s1) + 1):
        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
    for j in range(1, len(s2) + 1):
        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))
    return dp[len(s1)][len(s2)]
```

",,
"```python
def numSubarrayProductLessThanK(nums, k):
    if k <= 1:
        return 0
    prod = 1
    count = 0
    left = 0
    for right in range(len(nums)):
        prod *= nums[right]
        while prod >= k:
            prod /= nums[left]
            left += 1
        count += right - left + 1
    return count
```

",,
"```python
def maxProfit(prices, fee):
    cash, hold = 0, -prices[0]
    for price in prices:
        temp = cash
        cash = max(cash, hold + price - fee)
        hold = max(hold, temp - price)
    return cash
```

",,
"```python
from sortedcontainers import SortedList

class MaxStack:
    def __init__(self):
        self.mainStack = []
        self.maxSet = SortedList()

    def push(self, x: int) -> None:
        self.mainStack.append(x)
        self.maxSet.add(x)

    def pop(self) -> int:
        top = self.mainStack.pop()
        self.maxSet.remove(top)
        return top

    def top(self) -> int:
        return self.mainStack[-1]

    def peekMax(self) -> int:
        return self.maxSet[-1]

    def popMax(self) -> int:
        max_val = self.maxSet.pop()
        tempStack = []
        while self.mainStack[-1] != max_val:
            tempStack.append(self.mainStack.pop())
        self.mainStack.pop()
        while tempStack:
            self.mainStack.append(tempStack.pop())
        return max_val
```

",,
"```python
def is_one_bit_character(bits):
    i = 0
    while i < len(bits) - 1:
        i += bits[i] + 1
    return i == len(bits) - 1
```

",,
"```python
def findLength(nums1, nums2):
    m, n = len(nums1), len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxLength = 0

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if nums1[i] == nums2[j]:
                dp[i][j] = dp[i + 1][j + 1] + 1
                maxLength = max(maxLength, dp[i][j])

    return maxLength
```

",,
"```python
def smallestDistancePair(nums, k):
    nums.sort()
    low, high = 0, nums[-1] - nums[0]
    
    while low < high:
        mid = (low + high) // 2
        count, left = 0, 0

        for right in range(len(nums)):
            while nums[right] - nums[left] > mid:
                left += 1
            count += (right - left)

        if count < k:
            low = mid + 1
        else:
            high = mid
    
    return low
```


",,
"```python
def longest_word(words):
    built_words = set()
    result = ''

    for word in sorted(words):
        if len(word) == 1 or word[:-1] in built_words:
            if len(word) > len(result):
                result = word
            built_words.add(word)

    return result
```


",,
"```python
from collections import defaultdict

def accountsMerge(accounts):
    def dfs(id, visited, merged_emails):
        if id in visited:
            return
        visited.add(id)
        for email in accounts[id][1:]:
            merged_emails.add(email)
            dfs(email_to_id[email], visited, merged_emails)

    email_to_id = {}
    for i, account in enumerate(accounts):
        for email in account[1:]:
            email_to_id[email] = i

    result = []
    visited = set()
    for i, account in enumerate(accounts):
        if i not in visited:
            merged_emails = set()
            dfs(i, visited, merged_emails)
            result.append([account[0]] + sorted(merged_emails))
    return result
```


",,
"```python
def removeComments(self, source: List[str]) -> List[str]:
    result = []
    buffer = []
    in_block_comment = False

    for line in source:
        i = 0
        while i < len(line):
            if in_block_comment:
                if i < len(line) - 1 and line[i] == '*' and line[i + 1] == '/':
                    in_block_comment = False
                    i += 1
            else:
                if i < len(line) - 1 and line[i] == '/' and line[i + 1] == '*':
                    in_block_comment = True
                    i += 1
                elif i < len(line) - 1 and line[i] == '/' and line[i + 1] == '/':
                    break
                else:
                    buffer.append(line[i])
            i += 1

        if not in_block_comment and buffer:
            result.append(''.join(buffer))
            buffer.clear()

    return result
```


",,
"```python
def candyCrush(board):
    rows = len(board)
    cols = len(board[0])
    toDo = False
    
    for r in range(rows):
        for c in range(cols - 2):
            val = abs(board[r][c])
            if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]):
                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val
                toDo = True
                
    for r in range(rows - 2):
        for c in range(cols):
            val = abs(board[r][c])
            if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]):
                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val
                toDo = True
                
    for c in range(cols):
        wr = rows - 1
        for r in range(rows - 1, -1, -1):
            if board[r][c] > 0:
                board[wr][c] = board[r][c]
                wr -= 1
                
        for r in range(wr, -1, -1):
            board[r][c] = 0
                
    return candyCrush(board) if toDo else board
```

",,
"```python
def pivotIndex(nums):
    total_sum = sum(nums)
    left_sum = 0
    for i, num in enumerate(nums):
        if left_sum == total_sum - left_sum - num:
            return i
        left_sum += num
    return -1
```


",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def splitListToParts(root, k):
    result = [None] * k
    list_size = 0
    current_node = root
    while current_node:
        list_size += 1
        current_node = current_node.next

    base_size = list_size // k
    extra = list_size % k

    current_node = root
    for i in range(k):
        if not current_node:
            break
        result[i] = current_node
        current_part_size = base_size + (1 if i < extra else 0)
        for _ in range(current_part_size - 1):
            current_node = current_node.next
        next_node = current_node.next
        current_node.next = None
        current_node = next_node

    return result
```

",,
"```python
from collections import Counter

def parse(formula, i):
    counts = Counter()
    while i[0] < len(formula):
        if formula[i[0]] == '(':
            i[0] += 1
            temp = parse(formula, i)
            count = 0
            while i[0] < len(formula) and formula[i[0]].isdigit():
                count = count * 10 + int(formula[i[0]])
                i[0] += 1
            if count == 0: count = 1
            for name, c in temp.items():
                counts[name] += c * count
        elif formula[i[0]] == ')':
            i[0] += 1
            return counts
        else:
            name = formula[i[0]]
            i[0] += 1
            while i[0] < len(formula) and formula[i[0]].islower():
                name += formula[i[0]]
                i[0] += 1
            count = 0
            while i[0] < len(formula) and formula[i[0]].isdigit():
                count = count * 10 + int(formula[i[0]])
                i[0] += 1
            if count == 0: count = 1
            counts[name] += count
    return counts

def countOfAtoms(formula):
    i = [0]
    counts = parse(formula, i)
    ans = []
    for name, count in counts.items():
        ans.append(name)
        if count > 1: ans.append(str(count))
    return ''.join(ans)
```


",,
"```python
def min_window_sub_sequence(s1: str, s2: str) -> str:
    m, n = len(s1), len(s2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for j in range(0, m + 1):
        dp[0][j] = j

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[j - 1] == s2[i - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = dp[i][j - 1]

    start, length = 0, m + 1
    for j in range(1, m + 1):
        if dp[n][j] != 0 and j - dp[n][j] < length:
            start = dp[n][j]
            length = j - start

    return """" if length == m + 1 else s1[start:start + length]
```

",,
"```python
def is_self_dividing(num):
    n = num
    while n:
        digit = n % 10
        if digit == 0 or num % digit != 0:
            return False
        n //= 10
    return True

def self_dividing_numbers(left, right):
    return [i for i in range(left, right+1) if is_self_dividing(i)]
```

",,
"```python
from bisect import bisect_left, insort

class MyCalendar:

    def __init__(self):
        self.calendar = []

    def book(self, start, end):
        i = bisect_left(self.calendar, [start, end])
        if i % 2 == 1:
            return False
        if i > 0 and self.calendar[i-1] > start:
            return False
        if i < len(self.calendar) and end > self.calendar[i]:
            return False
        insort(self.calendar, start)
        insort(self.calendar, end)
        return True
```

",,
"```python
def countPalindromicSubsequences(s: str) -> int:
    n = len(s)
    MOD = 1000000007
    dp = [[0] * (n + 1) for _ in range(4)]

    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n + 1):
            c = ord(s[i]) - ord('a')
            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2
            dp[c][j] = (dp[c][j] + MOD) % MOD

    return sum(dp[c][n] for c in range(4)) % MOD
```


",,
"```python
class MyCalendarTwo:
    def __init__(self):
        self.singles = []
        self.doubles = []

    def book(self, start: int, end: int) -> bool:
        for d_start, d_end in self.doubles:
            if start < d_end and end > d_start:
                return False
        for s_start, s_end in self.singles:
            if start < s_end and end > s_start:
                self.doubles.append((max(start, s_start), min(end, s_end)))
        self.singles.append((start, end))
        return True
```


",,
"```python
from collections import defaultdict
import heapq

class MyCalendarThree:

    def __init__(self):
        self.timeline = defaultdict(int)

    def book(self, start: int, end: int) -> int:
        self.timeline[start] += 1
        self.timeline[end] -= 1
        ongoing, k = 0, 0
        for value in self.timeline.values():
            k = max(k, ongoing + value)
            ongoing += value
        return k
```


",,
"```python
def floodFill(image, sr, sc, newColor):
    startColor = image[sr][sc]
    def fill(sr, sc):
        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: 
            return
        image[sr][sc] = newColor
        fill(sr - 1, sc)
        fill(sr + 1, sc)
        fill(sr, sc - 1)
        fill(sr, sc + 1)
    
    fill(sr, sc)
    return image
```


",,
"```python
from collections import defaultdict

def areSentencesSimilar(sentence1, sentence2, similarPairs):
    if len(sentence1) != len(sentence2): return False
    similarityMap = defaultdict(set)
    for pair in similarPairs:
        similarityMap[pair[0]].add(pair[1])
        similarityMap[pair[1]].add(pair[0])
    for i in range(len(sentence1)):
        if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]:
            return False
    return True
```


",,
"```python
def asteroidCollision(asteroids):
    s = []
    for num in asteroids:
        if num > 0 or not s or s[-1] < 0:
            s.append(num)
        elif s[-1] <= -num:
            if s[-1] < -num:
                s.pop()
                s.append(num)
            else:
                s.pop()
    return s
```


",,
"```python
def evaluate(expression: str) -> int:
    def calculate(s, start, end, variables):
        if s[start] == '(':
            if s[start + 1:start + 4] == ""add"":
                first = start + 5
                second = first
                value1 = calculate(s, first, end, variables)
                second = s.index(' ', second) + 1
                value2 = calculate(s, second, end, variables)
                return value1 + value2
            elif s[start + 1:start + 5] == ""mult"":
                first = start + 6
                second = first
                value1 = calculate(s, first, end, variables)
                second = s.index(' ', second) + 1
                value2 = calculate(s, second, end, variables)
                return value1 * value2
            else:
                inner = variables.copy()
                idx = start + 5
                while idx < end - 1 and s[idx] != '(':
                    temp = idx
                    idx = s.index(' ', idx + 1)
                    var = s[temp:idx]
                    temp = idx + 1
                    if s[temp] == '(':
                        idx += 1
                    else:
                        idx = s.index(' ', idx + 1)
                    result = calculate(s, temp, idx, variables)
                    inner[var] = result
                    variables = inner
                return calculate(s, end - 1, end, variables)
        else:
            if s[start].isdigit() or s[start] == '-':
                end = s.find(' ', start) if ' ' in s[start:end] else end
                return int(s[start:end])
            else:
                end = s.find(' ', start) if ' ' in s[start:end] else end
                return variables[s[start:end]]

    return calculate(expression, 0, len(expression), {})
```

",,
"```python
from collections import defaultdict

def areSentencesSimilar(sentence1, sentence2, pairs):
    if len(sentence1) != len(sentence2):
        return False
    
    graph = defaultdict(set)
    for a, b in pairs:
        graph[a].add(b)
        graph[b].add(a)

    for a, b in zip(sentence1, sentence2):
        if a == b:
            continue
        if b not in graph[a]:
            return False

    return True
```

",,
"```python
def monotoneIncreasingDigits(n: int) -> int:
    n_str = [c for c in str(n)]

    i = len(n_str) - 1
    while i > 0:
        if n_str[i] < n_str[i - 1]:
            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)
            for j in range(i, len(n_str)):
                n_str[j] = '9'
        i -= 1

    return int(''.join(n_str))
```

",,
"```python
def daily_temperatures(temperatures):
    result = [0] * len(temperatures)
    stack = []

    for i, temp in enumerate(temperatures):
        while stack and temp > temperatures[stack[-1]]:
            idx = stack.pop()
            result[idx] = i - idx
        stack.append(i)

    return result
```

",,
"```python
def max_points(nums):
    dp = [0] * 100001
    max_points = 0
    for num in nums:
        dp[num] += 1
    for i in range(2, len(dp)):
        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])
        max_points = max(max_points, dp[i])
    return max_points
```

",,
"```python
def cherryPickup(self, grid: List[List[int]]) -> int:
    def dp(r1, c1, c2):
        r2 = r1 + c1 - c2
        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or
            grid[r1][c1] == -1 or grid[r2][c2] == -1):
            return float('-inf')
        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:
            return grid[r1][c1]
        elif memo[r1][c1][c2] != float('-inf'):
            return memo[r1][c1][c2]
        else:
            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]
            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),
                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))
            memo[r1][c1][c2] += max_cherries
        
        return memo[r1][c1][c2]
    
    N = len(grid)
    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]
    return max(0, dp(0, 0, 0))
```


",,
"```python
def to_lower_case(s: str) -> str:
    return s.lower()
```

",,
"```python
import heapq

def networkDelayTime(times, n, k):
    graph = {i: [] for i in range(1, n+1)}
    for u, v, w in times:
        graph[u].append((v, w))

    dist = {u: float('inf') for u in range(1, n+1)}
    dist[k] = 0

    pq = [(0, k)]

    while pq:
        curr_dist, u = heapq.heappop(pq)

        for v, weight in graph[u]:
            new_dist = curr_dist + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))

    max_time = max(dist.values())
    return max_time if max_time < float('inf') else -1
```


",,
"```python
import heapq
from collections import defaultdict

def networkDelayTime(times, n, k):
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))

    dist = {i: float('inf') for i in range(1, n + 1)}
    dist[k] = 0

    pq = [(0, k)]

    while pq:
        time, node = heapq.heappop(pq)

        if time > dist[node]:
            continue

        for neighbour, neighbourTime in graph[node]:
            candidate_dist = time + neighbourTime
            if candidate_dist < dist[neighbour]:
                dist[neighbour] = candidate_dist
                heapq.heappush(pq, (candidate_dist, neighbour))

    maxTime = max(dist.values())
    return maxTime if maxTime < float('inf') else -1
```

",,
"```python
def next_greatest_letter(letters, target):
    for letter in letters:
        if letter > target:
            return letter
    return letters[0]
```

",,
"```python
class WordFilter:

    def __init__(self, words):
        self.dict = {}
        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                self.dict[word[:j] + ""#"" + word[j:]] = i

    def f(self, prefix, suffix):
        return self.dict.get(prefix + ""#"" + suffix, -1)
```


",,
"```python
def minCostClimbingStairs(cost):
    for i in range(2, len(cost)):
        cost[i] += min(cost[i-1], cost[i-2])
    return min(cost[-1], cost[-2])
```

",,
"```python
def shortestCompletingWord(licensePlate: str, words: list[str]) -> str:
    from collections import Counter

    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())

    result = """"
    for word in words:
        word_count = Counter(word)

        valid = all(word_count[ch] >= count for ch, count in lp_count.items())

        if valid and (not result or len(word) < len(result)):
            result = word

    return result
```


",,
"```python
def shortest_completing_word(license_plate, words):
    target = [0] * 26
    for c in license_plate:
        if c.isalpha():
            target[ord(c.lower()) - ord('a')] += 1

    result = """"
    for word in words:
        current = [0] * 26
        for c in word:
            if c.isalpha():
                current[ord(c.lower()) - ord('a')] += 1

        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):
            result = word

    return result
```

",,
"```python
def countCornerRectangles(grid):
    count = 0
    m = len(grid)
    n = len(grid[0])
    
    for i in range(m - 1):
        for j in range(n - 1):
            if grid[i][j] == 1:
                for k in range(i + 1, m):
                    for l in range(j + 1, n):
                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:
                            count += 1
    return count
```

",,
"```python
def ipToCIDR(ip: str, n: int) -> List[str]:
    a, b, c, d = map(int, ip.split('.'))
    start = (a << 24) + (b << 16) + (c << 8) + d
    end = start + n - 1
    
    ans = []
    while start <= end:
        samePrefixBits = (~start & start).bit_length() - 1
        while ((end - start) >> samePrefixBits) < 1:
            samePrefixBits -= 1
        range = 1 << samePrefixBits
        ans.append(f""{start >> 24}.{(start >> 16) & 255}.{(start >> 8) & 255}.{start & 255}/{32 - samePrefixBits}"")
        start += range
    
    return ans
```


",,
"```python
from collections import deque

def openLock(deadends, target):
    dead = set(deadends)
    visited = set()
    q = deque([""0000""])

    if ""0000"" in dead:
        return -1

    visited.add(""0000"")
    moves = 0

    while q:
        level_size = len(q)
        for i in range(level_size):
            cur = q.popleft()

            if cur == target:
                return moves

            for j in range(4):
                for k in [-1, 1]:
                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]

                    if next_val not in visited and next_val not in dead:
                        visited.add(next_val)
                        q.append(next_val)

        moves += 1

    return -1
```


",,
"```python
from collections import deque

def openLock(deadends, target):
    dead = set(deadends)
    visited = set()
    wheel_states = deque([(""0000"", 0)])

    if ""0000"" in dead:
        return -1

    while wheel_states:
        current_state, turns = wheel_states.popleft()

        if current_state == target:
            return turns

        for i in range(4):
            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]
            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]

            if up_state not in visited and up_state not in dead:
                wheel_states.append((up_state, turns + 1))
                visited.add(up_state)

            if down_state not in visited and down_state not in dead:
                wheel_states.append((down_state, turns + 1))
                visited.add(down_state)

    return -1
```

",,
"```python
def reachNumber(target: int) -> int:
    target = abs(target)
    step = 0
    sum = 0
    while sum < target:
        step += 1
        sum += step
    while (sum - target) % 2 != 0:
        step += 1
        sum += step
    return step
```


",,
"```python
def min_moves(target: int) -> int:
    target = abs(target)
    step = 0
    total = 0
    while total < target or (total - target) % 2 != 0:
        step += 1
        total += step
    return step
```


",,
"```python
def pyramid_transition(bottom, allowed):
    mapping = {}
    for s in allowed:
        key = s[:2]
        if key not in mapping:
            mapping[key] = []
        mapping[key].append(s[2])
    return pyramid_transition_helper(bottom, """", 0, mapping)

def pyramid_transition_helper(bottom, top, idx, mapping):
    if len(bottom) == 1:
        return True
    if idx == len(bottom) - 1:
        return pyramid_transition_helper(top, """", 0, mapping)
    key = bottom[idx:idx + 2]
    if key not in mapping:
        return False
    for c in mapping[key]:
        if pyramid_transition_helper(bottom, top + c, idx + 1, mapping):
            return True
    return False
```


",,
"```python
from collections import defaultdict

def pyramidTransition(bottom, allowed):
    mapping = defaultdict(list)
    for s in allowed:
        mapping[s[:2]].append(s[2])
    return dfs("""", bottom, mapping)

def dfs(curr, bottom, mapping):
    if len(bottom) == 1:
        return True
    for i in range(len(bottom) - 1):
        if bottom[i:i+2] not in mapping:
            return False
    curr = """".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))
    return dfs(curr, curr, mapping)
```


",,
"```python
def addBoldTag(words, s):
    bold = [False] * len(s)
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                bold[i] = True
            pos = s.find(word, pos + 1)

    result = []
    for i in range(len(s)):
        if bold[i] and (i == 0 or not bold[i - 1]):
            result.append(""<b>"")
        result.append(s[i])
        if bold[i] and (i == len(s) - 1 or not bold[i + 1]):
            result.append(""</b>"")

    return """".join(result)
```

",,
"```python
def min_set_size(intervals):
    intervals.sort()
    n = len(intervals)
    end = intervals[0][1]
    count = 1

    for i in range(1, n):
        if end < intervals[i][0]:
            end = intervals[i][1]
            count += 1
        else:
            end = min(end, intervals[i][1])
    return count * 2
```

",,
"```python
def anagramMappings(nums1, nums2):
    num_map = {num: i for i, num in enumerate(nums2)}
    mapping = [num_map[num] for num in nums1]
    return mapping
```


",,
"```python
def makeLargestSpecial(s: str) -> str:
    count, i = 0, 0
    subs = []

    for j in range(len(s)):
        if s[j] == '1':
            count += 1
        else:
            count -= 1

        if count == 0:
            subs.append(""1"" + makeLargestSpecial(s[i+1:j]) + ""0"")
            i = j + 1

    subs.sort(reverse=True)
    return """".join(subs)
```


",,
"```python
def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def count_prime_set_bits(left: int, right: int) -> int:
    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))
```


",,
"```python
def partition_labels(s):
    last = {c:i for i, c in enumerate(s)}
    ans = []
    j = anchor = 0
    for i, c in enumerate(s):
        j = max(j, last[c])
        if i == j:
            ans.append(i - anchor + 1)
            anchor = i + 1
    return ans
```

",,
"```python
from collections import deque

class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def levelOrder(root):
    result = []

    if not root:
        return result

    toVisit = deque([root])

    while toVisit:
        size = len(toVisit)
        level = []

        for _ in range(size):
            currentNode = toVisit.popleft()
            level.append(currentNode.val)

            for child in currentNode.children:
                toVisit.append(child)

        result.append(level)

    return result
```

",,
"```python
def minSwapsCouples(row):
    n = len(row)
    position = [0] * n
    for i in range(n):
        position[row[i]] = i

    swaps = 0
    for i in range(0, n, 2):
        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1
        if row[i + 1] != partner:
            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]
            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]
            swaps += 1
    return swaps
```


",,
"```python
class Node:
    def __init__(self, val=0, prev=None, next=None, child=None):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child

def flatten(head: Node) -> Node:
    if not head:
        return None
    
    curr = head
    while curr:
        if curr.child:
            insert = curr.child
            next_node = curr.next
            
            insert.prev = curr
            curr.next = insert
            curr.child = None
            
            while insert.next:
                insert = insert.next
                
            if next_node:
                next_node.prev = insert
                insert.next = next_node
                
        curr = curr.next
        
    return head
```


",,
"```python
def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def count_prime_set_bits(left: int, right: int) -> int:
    count = 0
    for i in range(left, right + 1):
        bits = bin(i).count('1')
        if is_prime(bits):
            count += 1
    return count
```

",,
"```python
def partition_labels(s: str) -> list[int]:
    last_pos = {}
    for i, c in enumerate(s):
        last_pos[c] = i

    partitions = []
    start, end = 0, 0
    for i, c in enumerate(s):
        end = max(end, last_pos[c])
        if i == end:
            partitions.append(end - start + 1)
            start = i + 1
    return partitions
```


",,
"```python
def orderOfLargestPlusSign(n, mines):
    grid = [[1] * n for _ in range(n)]
    for mine in mines:
        grid[mine[0]][mine[1]] = 0
        
    left, right, up, down = [list(grid) for _ in range(4)]

    for i in range(n):
        for j in range(n):
            if grid[i][j]:
                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)
                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)

    ans = 0
    for i in range(n - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if grid[i][j]:
                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)
                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)
                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))

    return ans
```


",,
"```python
def minSwapsCouples(row):
    n = len(row) // 2
    swaps = 0
    position = {num: i for i, num in enumerate(row)}

    for i in range(0, len(row), 2):
        couple = row[i] - 1 if row[i] % 2 else row[i] + 1
        if row[i + 1] != couple:
            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]
            position[row[i + 1]], position[couple] = position[couple], i + 1
            swaps += 1

    return swaps
```

",,
"```python
def num_jewels_in_stones(jewels: str, stones: str) -> int:
    count = 0
    for stone in stones:
        if stone in jewels:
            count += 1
    return count
```

",,
"```python
class Node:
    def __init__(self, val: bool, isLeaf: bool, topLeft: 'Node', topRight: 'Node', bottomLeft: 'Node', bottomRight: 'Node'):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def construct(grid):
    def helper(x, y, length):
        if length == 1:
            return Node(grid[x][y] == 1, True, None, None, None, None)

        tl = helper(x, y, length // 2)
        tr = helper(x, y + length // 2, length // 2)
        bl = helper(x + length // 2, y, length // 2)
        br = helper(x + length // 2, y + length // 2, length // 2)

        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val and tr.val == bl.val and bl.val == br.val:
            return Node(tl.val, True, None, None, None, None)
        else:
            return Node(False, False, tl, tr, bl, br)

    return helper(0, 0, len(grid))
```

",,
"```python
class TreeNode:
    def __init__(self, isLeaf, val, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):
        self.isLeaf = isLeaf
        self.val = val
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def intersect(quadTree1, quadTree2):    
    if quadTree1.isLeaf:
        return quadTree1 if quadTree1.val else quadTree2
    if quadTree2.isLeaf:
        return quadTree2 if quadTree2.val else quadTree1

    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft)
    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight)
    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight)

    if quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and quadTree1.topLeft.val == quadTree1.topRight.val == quadTree1.bottomLeft.val == quadTree1.bottomRight.val:
        quadTree1.isLeaf = True
        quadTree1.val = quadTree1.topLeft.val

    return quadTree1
```


",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []
 
def max_depth(root):
    if root is None:
        return 0
    depth = 0
    for child in root.children:
        depth = max(depth, max_depth(child))
    return 1 + depth
```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def helper(root, result):
    if not root:
        return
    result.append(root.val)
    for child in root.children:
        helper(child, result)

def preorder(root):
    result = []
    helper(root, result)
    return result
```

",,
"```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def postorder(root: 'Node'):
    if root is None:
        return []
    
    result = []
    stack = [root]

    while stack:
        curr = stack.pop()
        result.append(curr.val)
        stack.extend(curr.children)

    return result[::-1]
```

",,
"```python
def isToeplitzMatrix(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    for i in range(rows - 1):
        for j in range(cols - 1):
            if matrix[i][j] != matrix[i+1][j+1]:
                return False
    return True
```


",,
"```python
import heapq

def rearrange_string(s):
    counts = {}
    for c in s:
        counts[c] = counts.get(c, 0) + 1
    
    pq = [(-count, char) for char, count in counts.items()]
    heapq.heapify(pq)
    
    result = []
    previous = (0, '')
    
    while pq:
        count, char = heapq.heappop(pq)
        result.append(char)
        
        if previous[0] < 0:
            heapq.heappush(pq, previous)
        
        count += 1
        previous = (count, char)
    
    result_str = ''.join(result)
    return result_str if len(result_str) == len(s) else """"
```


",,
"```python
def max_chunks_to_sorted(arr):
    max_val, chunks = 0, 0
    for i, value in enumerate(arr):
        max_val = max(max_val, value)
        if max_val == i:
            chunks += 1
    return chunks
```

",,
"```python
def max_chunks_to_sorted(arr):
    max_so_far, count = 0, 0
    for i, val in enumerate(arr):
        max_so_far = max(max_so_far, val)
        if max_so_far == i:
            count += 1
    return count
```


",,
"```python
from collections import Counter

def numRabbits(answers):
    count = Counter(answers)
    rabbits = 0
    for ans, cnt in count.items():
        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)
    return rabbits
```


",,
"```python
def numJewelsInStones(jewels, stones):
    count = 0
    for s in stones:
        if s in jewels:
            count += 1
    return count
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root: TreeNode, val: int) -> TreeNode:
    if not root or root.val == val:
        return root
    return searchBST(root.left, val) if root.val > val else searchBST(root.right, val)
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def insertIntoBST(root, val):
    if root is None:
        return TreeNode(val)

    if val < root.val:
        root.left = insertIntoBST(root.left, val)
    else:
        root.right = insertIntoBST(root.right, val)

    return root
```


",,
"```python
def isBipartite(graph: List[List[int]]) -> bool:
    def dfs(node: int, color: int) -> bool:
        if colors[node]:
            return colors[node] == color

        colors[node] = color
        for neighbor in graph[node]:
            if not dfs(neighbor, 3 - color):
                return False

        return True

    n = len(graph)
    colors = [0] * n

    for i in range(n):
        if not colors[i] and not dfs(i, 1):
            return False

    return True
```

",,
"```python
import heapq
from typing import List

def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:
    pq = [(arr[i] / arr[j], i, j) for j in range(len(arr) - 1, 0, -1)]
    heapq.heapify(pq)
    for _ in range(k - 1):
        _, i, j = heapq.heappop(pq)
        if j != i + 1:
            heapq.heappush(pq, (arr[i] / arr[j - 1], i, j - 1))
    return [arr[pq[0][1]], arr[pq[0][2]]]
```

",,
"```python
from collections import deque

def slidingPuzzle(board):
    m, n = 2, 3
    target = ""123450""
    start = """".join(str(num) for row in board for num in row)
    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]
    q = deque([start])
    res = 0
    visited = {start}
    while q:
        for _ in range(len(q)):
            cur = q.popleft()
            if cur == target:
                return res
            zero_idx = cur.index(""0"")
            for dir in dirs[zero_idx]:
                neighbor = list(cur)
                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]
                neighbor = """".join(neighbor)
                if neighbor not in visited:
                    visited.add(neighbor)
                    q.append(neighbor)
        res += 1
    return -1
```

",,
"```python
def rotatedDigits(n: int) -> int:
    count = 0
    for i in range(1, n + 1):
        if isGood(i):
            count += 1
    return count

def isGood(num: int) -> bool:
    changed = False
    while num:
        digit = num % 10
        if digit in (3, 4, 7):
            return False
        if digit in (2, 5, 6, 9):
            changed = True
        num //= 10
    return changed
```

",,
"```python
import heapq

class KthLargest:

    def __init__(self, k, nums):
        self.heap = []
        self.k = k
        for num in nums:
            self.add(num)

    def add(self, val):
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
```

",,
"```python
def is_ideal_permutation(nums):
    for i, num in enumerate(nums):
        if abs(num - i) > 1:
            return False
    return True
```


",,
"```python
def customSortString(order, s):
    priority = {char: idx for idx, char in enumerate(order)}
    return """".join(sorted(s, key=lambda x: priority.get(x, 0)))
```

",,
"```python
def search(nums, target):
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```


",,
"```python
def canTransform(start: str, end: str) -> bool:
    if len(start) != len(end): return False

    i, j = 0, 0
    n = len(start)
    while i < n and j < n:
        while i < n and start[i] == 'X': i += 1
        while j < n and end[j] == 'X': j += 1

        if start[i] != end[j]: return False

        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j): return False

        i += 1; j += 1
    return True
```

",,
"```python
import heapq

def swim(n, grid):
    pq = [(grid[0][0], 0, 0)]
    visited = [[False] * n for _ in range(n)]

    dr = [-1, 0, 1, 0]
    dc = [0, 1, 0, -1]

    while pq:
        curT, curR, curC = heapq.heappop(pq)

        if curR == n - 1 and curC == n - 1:
            return curT

        for d in range(4):
            newRow, newCol = curR + dr[d], curC + dc[d]
            if 0 <= newRow < n and 0 <= newCol < n and not visited[newRow][newCol]:
                visited[newRow][newCol] = True
                heapq.heappush(pq, (max(curT, grid[newRow][newCol]), newRow, newCol))

    return -1
```

",,
"```python
def kthSymbolInGrammar(n, k):
    if n == 1:
        return 0
    if k % 2 == 0:
        return 1 - kthSymbolInGrammar(n - 1, k // 2)
    else:
        return kthSymbolInGrammar(n - 1, (k + 1) // 2)
```

",,
"```python
def can_transform(sx, sy, tx, ty):
    while sx != tx or sy != ty:
        if sx > tx or sy > ty:
            return False
        if sx < tx:
            tx -= ty
        else:
            ty -= sx
    return True
```

",,
"```python
from collections import defaultdict
def numRabbits(answers):
    count = defaultdict(int)
    res = 0
    for a in answers:
        count[a] += 1
        if count[a] == 1:
            res += (a + 1)
        elif count[a] > a + 1:
            count[a] = 1
            res += (a + 1)
    return res
```


",,
"```python
def moves_to_chessboard(board):
    N = len(board)
    row, col = 0, 0
    row_count, col_count = 0, 0

    for i in range(N):
        for j in range(N):
            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:
                return -1

    for i in range(N):
        row ^= board[0][i]
        col ^= board[i][0]
        row_count += 1 if board[0][i] == 1 else 0
        col_count += 1 if board[i][0] == 1 else 0

    if row != 0 and row_count * 2 != N:
        return -1
    if col != 0 and col_count * 2 != N:
        return -1

    if N % 2 == 1:
        if row_count % 2 == 1:
            row_count = N - row_count
        if col_count % 2 == 1:
            col_count = N - col_count
    else:
        row_count = min(row_count, N - row_count)
        col_count = min(col_count, N - col_count)

    return (row_count + col_count) // 2
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def __init__(self):
        self.min_diff = float(""inf"")
        self.prev = None

    def minDiffInBST(self, root: TreeNode) -> int:
        self.in_order_traversal(root)
        return self.min_diff

    def in_order_traversal(self, node: TreeNode) -> None:
        if not node: return
        self.in_order_traversal(node.left)
        if self.prev:
            self.min_diff = min(self.min_diff, node.val - self.prev.val)
        self.prev = node
        self.in_order_traversal(node.right)
```


",,
"```python
def letterCasePermutation(s):
    def backtrack(index):
        if index == len(s):
            result.append("""".join(s))
            return
        backtrack(index + 1)
        if s[index].isalpha():
            s[index] = s[index].swapcase()
            backtrack(index + 1)
            s[index] = s[index].swapcase()

    result = []
    s = list(s)
    backtrack(0)
    return result
```

",,
"```python
from collections import deque

def isBipartite(graph):
    colors = [0] * len(graph)
    for i in range(len(graph)):
        if colors[i] != 0:
            continue
        colors[i] = 1
        queue = deque([i])
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if colors[neighbor] == 0:
                    colors[neighbor] = -colors[node]
                    queue.append(neighbor)
                elif colors[neighbor] == colors[node]:
                    return False
    return True
```


",,
"```python
import heapq

def kthSmallestPrimeFraction(arr, k):
    pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)]

    heapq.heapify(pq)

    for _ in range(k - 1):
        frac, i, j = heapq.heappop(pq)
        j -= 1
        if i < j:
            heapq.heappush(pq, (-arr[i] / arr[j], i, j))

    frac, i, j = heapq.heappop(pq)
    return [arr[i], arr[j]]
```

",,
"```python
import heapq

def findCheapestPrice(n, flights, src, dst, k):
    graph = [[] for _ in range(n)]
    for flight in flights:
        graph[flight[0]].append((flight[1], flight[2]))

    pq = [(0, src, k + 1)]
    while pq:
        price, city, stops = heapq.heappop(pq)

        if city == dst:
            return price

        if stops > 0:
            for nei, prc in graph[city]:
                heapq.heappush(pq, (price + prc, nei, stops - 1))

    return -1
```


",,
"```python
def rotated_digits(n):
    count = 0
    for i in range(1, n + 1):
        is_valid_after_rotation = True
        is_different_after_rotation = False
        num = i
        while num:
            digit = num % 10
            if digit in {3, 4, 7}:
                is_valid_after_rotation = False
                break
            if digit in {2, 5, 6, 9}:
                is_different_after_rotation = True
            num //= 10
        if is_valid_after_rotation and is_different_after_rotation:
            count += 1
    return count
```

",,
"```python
from typing import List

def escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:
    max_dist = abs(target[0]) + abs(target[1])
    for ghost in ghosts:
        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])
        if ghost_dist <= max_dist:
            return False
    return True
```


",,
"```python
def numberOfWays(n):
    MOD = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD

    return dp[n]
```


",,
"```python
def custom_sort_string(order, s):
    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))
```


",,
"```python
from bisect import bisect_left
from collections import defaultdict

def numMatchingSubseq(s, words):
    positions = defaultdict(list)

    for i, c in enumerate(s):
        positions[c].append(i)

    count = 0

    for word in words:
        index = -1
        isSubsequence = True

        for c in word:
            position_list = positions.get(c, [])
            i = bisect_left(position_list, index + 1)
            if (i == len(position_list)):
                isSubsequence = False
                break
            index = position_list[i]

        if isSubsequence:
            count += 1

    return count
```

",,
"```python
def num_zeros(k):
    x = 0
    i = 5
    while k // i >= 1:
        x += k // i
        i *= 5
    return x
```

",,
"```python
def valid_tic_tac_toe(board: List[str]) -> bool:
    x_count = sum(row.count('X') for row in board)
    o_count = sum(row.count('O') for row in board)
    if x_count != o_count and x_count != o_count + 1: return False

    x_win, o_win = False, False
    for i in range(3):
        if board[i][0] == board[i][1] == board[i][2] != ' ':
            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)
        if board[0][i] == board[1][i] == board[2][i] != ' ':
            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)
    if board[0][0] == board[1][1] == board[2][2] != ' ':
        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)
    if board[0][2] == board[1][1] == board[2][0] != ' ':
        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)

    if x_win and o_win: return False
    if x_win and x_count == o_count: return False
    if o_win and x_count > o_count: return False

    return True
```


",,
"```python
def numSubarrayBoundedMax(nums, left, right):
    result, prev, start = 0, 0, -1
    for i, num in enumerate(nums):
        if left <= num <= right:
            prev = i - start
            result += prev
        elif num < left:
            result += prev
        else:
            start = i
            prev = 0
    return result
```


",,
"```python
def is_shifted(s, goal):
    if len(s) != len(goal): return False

    s = s + s
    return goal in s
```

",,
"```python
from typing import List

def allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:
    def DFS(currentNode, path):
        path.append(currentNode)
        if currentNode == len(graph) - 1:
            result.append(path[:])
        else:
            for neighbor in graph[currentNode]:
                DFS(neighbor, path)
        path.pop()

    result = []
    DFS(0, [])
    return result
```

",,
"```python
def best_rotation(nums):
    n = len(nums)
    change = [0] * n

    for i in range(n):
        change[(i - nums[i] + 1 + n) % n] -= 1
        change[(i + 1) % n] += 1

    max_score = 0
    cur_score = change[0]
    for i in range(1, n):
        cur_score += change[i]
        if cur_score > max_score:
            max_score = cur_score
            
    return max_score
```


",,
"```python
from collections import defaultdict, deque

def numBusesToDestination(routes, source, target):
    if source == target:
        return 0

    stop_route_map = defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            stop_route_map[stop].add(i)

    queue = deque([source])
    visited_sources = {source}

    transfers = 0
    while queue:
        size = len(queue)
        for _ in range(size):
            curr = queue.popleft()
            if curr == target:
                return transfers

            for route in stop_route_map[curr]:
                for stop in routes[route]:
                    if stop not in visited_sources:
                        queue.append(stop)
                        visited_sources.add(stop)
                stop_route_map[curr].remove(route)
        transfers += 1
    return -1
```

",,
"```python
class MyHashSet:

    def __init__(self):
        self.storage = [False] * 1000001

    def add(self, key: int):
        self.storage[key] = True

    def remove(self, key: int):
        self.storage[key] = False

    def contains(self, key: int) -> bool:
        return self.storage[key]
```


",,
"```python
class MyHashMap:

    def __init__(self):
        self.data = [-1] * 1000001

    def put(self, key: int, value: int) -> None:
        self.data[key] = value

    def get(self, key: int) -> int:
        return self.data[key]

    def remove(self, key: int) -> None:
        self.data[key] = -1
```


",,
"```python
def racecar(target: int) -> int:
    memo = {}
    def dp(position, speed):
        if abs(position) > 2 * target:
            return target + 1
        if position == target:
            return 0 if speed == 1 else 1
        if (position, speed) in memo:
            return memo[(position, speed)]
        
        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1
        ans = min(ans, dp(position + speed, speed * 2) + 1)
        memo[(position, speed)] = ans
        return ans
    
    return dp(0, 1)
```

",,
"```python
def minSwaps(nums1, nums2):
    n = len(nums1)
    noSwap = [float('inf')] * n
    doSwap = [float('inf')] * n
    noSwap[0] = 0
    doSwap[0] = 1

    for i in range(1, n):
        if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:
            noSwap[i] = noSwap[i - 1]
            doSwap[i] = doSwap[i - 1] + 1
        if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:
            noSwap[i] = min(noSwap[i], doSwap[i - 1])
            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1)

    return min(noSwap[n - 1], doSwap[n - 1])
```

",,
"```python
from typing import List

def eventualSafeNodes(graph: List[List[int]]) -> List[int]:
    n = len(graph)
    color = [0] * n
    ans = []

    def hasCycle(node: int, color: List[int], graph: List[List[int]]) -> bool:
        if color[node] > 0:
            return color[node] == 1
        color[node] = 1
        for neighbor in graph[node]:
            if hasCycle(neighbor, color, graph):
                return True
        color[node] = 2
        return False

    for i in range(n):
        if not hasCycle(i, color, graph):
            ans.append(i)
    return ans
```

",,
"```python
from typing import List

def hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:
    def dfs(x, y):
        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] <= 0:
            return 0
        grid[x][y] = -1
        return 1 + sum(dfs(x + dx, y + dy) for dx, dy in directions)

    m, n = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for x, y in hits:
        grid[x][y] -= 1

    for j in range(n):
        if grid[0][j] == 1:
            dfs(0, j)

    result = []
    for x, y in hits:
        grid[x][y] += 1
        if grid[x][y] != 1:
            result.append(0)
            continue
        for dx, dy in directions:
            if dfs(x + dx, y + dy) != 0:
                result.append(dfs(x, y) - 1)
                break
        else:
            result.append(0)

    return result
```

",,
"```python
def uniqueMorseRepresentations(words):
    morse = ["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
    transformations = set()

    for word in words:
        morseCode = ''.join(morse[ord(c) - ord('a')] for c in word)
        transformations.add(morseCode)

    return len(transformations)
```

",,
"```python
def isPossibleToSplit(nums):
    n = len(nums)
    total_sum = sum(nums)

    if total_sum % n != 0:
        return False

    target_sum = total_sum * (n // 2) // n
    dp = [[False] * (target_sum + 1) for _ in range(n // 2 + 1)]
    dp[0][0] = True

    for num in nums:
        for count in range(n // 2, 0, -1):
            for sum_ in range(target_sum, num - 1, -1):
                dp[count][sum_] = dp[count][sum_] or dp[count - 1][sum_ - num]

        if dp[n // 2][target_sum]:
            return True

    return False
```


",,
"```python
def number_of_lines(widths, s):
    lines = 1
    current_pixel = 0
    for c in s:
        letter_pixels = widths[ord(c) - ord('a')]
        if current_pixel + letter_pixels > 100:
            lines += 1
            current_pixel = 0
        current_pixel += letter_pixels
    return [lines, current_pixel]
```


",,
"```python
def max_increase_keeping_skyline(grid):
    n = len(grid)
    row_max = [0] * n
    col_max = [0] * n
    
    for i in range(n):
        for j in range(n):
            row_max[i] = max(row_max[i], grid[i][j])
            col_max[j] = max(col_max[j], grid[i][j])
    
    total_sum = 0
    for i in range(n):
        for j in range(n):
            total_sum += min(row_max[i], col_max[j]) - grid[i][j]
    
    return total_sum
```

",,
"```python
def maxProfitAssignment(difficulty, profit, worker):
    n = len(difficulty)
    jobs = sorted(zip(difficulty, profit))
    worker.sort()

    max_profit = 0
    total_profit = 0
    job_idx = 0

    for w in worker:
        while job_idx < n and w >= jobs[job_idx][0]:
            max_profit = max(max_profit, jobs[job_idx][1])
            job_idx += 1
        total_profit += max_profit

    return total_profit
```

",,
"```python
def maxAreaOfIsland(grid):
    def dfs(x, y):
        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:
            return 0
        grid[x][y] = 0
        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1

    ans = 0
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                grid[i][j] = 1
                ans = max(ans, dfs(i, j))
                grid[i][j] = 0
    return ans
```

",,
"```python
def xor_game(nums: List[int]) -> bool:
    xor_sum = 0
    for num in nums:
        xor_sum ^= num
    return xor_sum == 0 or len(nums) % 2 == 0
```

",,
"```python
from collections import defaultdict

def subdomainVisits(cpdomains):
    counts = defaultdict(int)
    result = []

    for cpdomain in cpdomains:
        count, domain = cpdomain.split()
        count = int(count)

        for i in range(len(domain)):
            if domain[i] == '.':
                counts[domain[i + 1:]] += count
        counts[domain] += count

    for sub, cnt in counts.items():
        result.append(f""{cnt} {sub}"")
        
    return result
```


",,
"```python
from itertools import combinations

def largestTriangleArea(points):
    return max(0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))
```

",,
"```python
class Solution:
    def largestSumOfAverages(self, nums: List[int], k: int) -> float:
        memo = {}
        
        def max_partition_sum(start: int, k: int) -> float:
            if k == 1:
                return sum(nums[start:]) / (len(nums) - start)
            if (start, k) in memo:
                return memo[start, k]
            
            ans, curr_sum = 0, 0
            for i in range(start, len(nums) - k + 1):
                curr_sum += nums[i]
                ans = max(ans, curr_sum / (i - start + 1) + max_partition_sum(i + 1, k - 1))
            
            memo[start, k] = ans
            return ans
        
        return max_partition_sum(0, k)
```

",,
"```python
def pruneTree(root: TreeNode) -> TreeNode:
    if not root:
        return None
    root.left = pruneTree(root.left)
    root.right = pruneTree(root.right)
    if root.val == 0 and not root.left and not root.right:
        return None
    return root
```

",,
"```python
from collections import defaultdict
from queue import Queue

def numBusesToDestination(routes, source, target):
    if source == target:
        return 0

    stop_to_buses = defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            stop_to_buses[stop].add(i)

    q = Queue()
    visited_buses = set()
    num_buses = 0
    q.put(source)

    while not q.empty():
        size = q.qsize()
        for _ in range(size):
            stop = q.get()
            for bus in stop_to_buses[stop]:
                if bus in visited_buses:
                    continue
                visited_buses.add(bus)
                for next_stop in routes[bus]:
                    if next_stop == target:
                        return num_buses + 1
                    q.put(next_stop)
        num_buses += 1

    return -1
```

",,
"```python
def ambiguousCoordinates(s):
    def generateNumber(s):
        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):
            return []
        if len(s) > 1 and s[0] == '0':
            return [""0."" + s[1:]]
        res = [s]
        if len(s) == 1 or s[-1] == '0':
            return res
        for i in range(1, len(s)):
            res.append(s[:i] + ""."" + s[i:])
        return res

    n = len(s)
    res = []
    
    for i in range(2, n - 1):
        first = generateNumber(s[1:i])
        second = generateNumber(s[i:n - 1])
        
        for f in first:
            for sec in second:
                res.append(""("" + f + "", "" + sec + "")"")
    
    return res
```


",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def numComponents(head: ListNode, nums: List[int]) -> int:
    num_set = set(nums)
    result = 0
    connected = False

    while head:
        if head.val in num_set:
            if not connected:
                connected = True
                result += 1
        else:
            connected = False
        head = head.next

    return result
```


",,
"```python
def racecar(target: int) -> int:
    memo = {}

    def dp(pos: int, speed: int) -> int:
        if pos == target:
            return 0
        if abs(pos) > 2 * target:
            return float('inf')

        key = (pos, speed)
        if key in memo:
            return memo[key]

        op1 = dp(pos + speed, speed * 2) + 1
        op2 = dp(pos, -speed) + 2

        ans = min(op1, op2)
        memo[key] = ans
        return ans

    return dp(0, 1)
```

",,
"```python
def mostCommonWord(paragraph: str, banned: List[str]):
    word_count = {}
    banned_set = {ban.lower() for ban in banned}

    for word in paragraph.lower().split():
        cleaned_word = ''.join(c for c in word if c.isalpha())
        if cleaned_word not in banned_set:
            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1

    return max(word_count, key=word_count.get)
```


",,
"```python
def pushDominoes(dominoes: str) -> str:
    n = len(dominoes)
    forces = [0] * n
    
    force = 0
    for i in range(n):
        if dominoes[i] == 'R':
            force = n
        elif dominoes[i] == 'L':
            force = 0
        else:
            force = max(force - 1, 0)
        forces[i] += force
    
    force = 0
    for i in range(n - 1, -1, -1):
        if dominoes[i] == 'L':
            force = n
        elif dominoes[i] == 'R':
            force = 0
        else:
            force = max(force - 1, 0)
        forces[i] -= force
    
    return """".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])
```


",,
"```python
def minimal_length_encoding(words):
    word_set = set(words)

    for word in words:
        for i in range(1, len(word)):
            word_set.discard(word[i:])

    return sum(len(word) + 1 for word in word_set)
```

",,
"```python
def numMagicSquaresInside(grid):
    count = 0
    for i in range(len(grid) - 2):
        for j in range(len(grid[0]) - 2):
            if grid[i][j] <= 9 and grid[i + 1][j + 1] == 5 and isMagic(grid, i, j):
                count += 1
    return count


def isMagic(grid, x, y):
    temp = [0] * 16
    for i in range(3):
        for j in range(3):
            num = grid[x + i][y + j]
            temp[num] += 1
            if num > 9 or temp[num] > 1:
                return False

    _sum = grid[x][y] + grid[x][y+1] + grid[x][y+2]
    for i in range(3):
        row_sum, col_sum = 0, 0
        for j in range(3):
            row_sum += grid[x + i][y + j]
            col_sum += grid[x + j][y + i]
        if row_sum != _sum or col_sum != _sum:
            return False

    if grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != _sum:
        return False
    if grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != _sum:
        return False

    return True
```


",,
"```python
def shortestToChar(s, c):
    n = len(s)
    result = [n for _ in range(n)]
    pos = -n

    for i in range(n):
        if s[i] == c:
            pos = i
        result[i] = i - pos

    for i in range(pos - 1, -1, -1):
        if s[i] == c:
            pos = i
        result[i] = min(result[i], pos - i)

    return result
```


",,
"```python
def smallest_good_integer(fronts, backs):
    not_good = {fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]}

    result = float('inf')
    for i in range(len(fronts)):
        if fronts[i] not in not_good:
            result = min(result, fronts[i])
        if backs[i] not in not_good:
            result = min(result, backs[i])

    return 0 if result == float('inf') else result
```

",,
"```python
def numFactoredBinaryTrees(arr):
    MOD = 10**9 + 7
    n = len(arr)
    arr.sort()
    dp = {}
    for i, x in enumerate(arr):
        dp[x] = 1
        for y in arr[:i]:
            if x % y == 0 and x // y in dp:
                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD
    return sum(dp.values()) % MOD
```

",,
"```python
def backspaceCompare(s: str, t: str) -> bool:
    i, j = len(s) - 1, len(t) - 1
    while True:
        back = 0
        while i >= 0 and (back > 0 or s[i] == '#'):
            back = back + 1 if s[i] == '#' else back - 1
            i -= 1
        back = 0
        while j >= 0 and (back > 0 or t[j] == '#'):
            back = back + 1 if t[j] == '#' else back - 1
            j -= 1
        if i >= 0 and j >= 0 and s[i] == t[j]:
            i, j = i -1, j - 1
        else:
            return i == -1 and j == -1
```

",,
"```python
def longestMountain(arr):
    n = len(arr)
    res = up = down = 0

    for i in range(1, n):
        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:
            up = down = 0

        up += arr[i - 1] < arr[i]
        down += arr[i - 1] > arr[i]

        if up and down:
            res = max(res, up + down + 1)

    return res
```

",,
"```python
from collections import Counter

def is_possible_divide(hand, group_size):
    card_count = Counter(hand)

    for card in sorted(card_count):
        if card_count[card] > 0:
            count = card_count[card]
            for i in range(1, group_size):
                if card_count[card + i] < count:
                    return False
                card_count[card + i] -= count

    return True
```


",,
"```python
from collections import deque

def shortestPathLength(graph):
    n = len(graph)
    queue = deque([(i, 1 << i, 0) for i in range(n)])
    visited = [[False] * (1 << n) for _ in range(n)]

    for i in range(n):
        visited[i][1 << i] = True

    while queue:
        node, bitmask, length = queue.popleft()

        if bitmask == (1 << n) - 1:
            return length

        for nei in graph[node]:
            next_bitmask = bitmask | (1 << nei)
            if not visited[nei][next_bitmask]:
                visited[nei][next_bitmask] = True
                queue.append((nei, next_bitmask, length + 1))

    return 0
```

",,
"```python
def shiftingLetters(s: str, shifts) -> str:
    for i in range(len(shifts) - 2, -1, -1):
        shifts[i] += shifts[i + 1] % 26

    result = list(s)
    for i in range(len(s)):
        result[i] = chr((ord(result[i]) - ord('a') + shifts[i] % 26) % 26 + ord('a'))
        
    return """".join(result)
```

",,
"```python
def maxDistToClosest(seats):
    n = len(seats)
    maxDist = 0
    lastPerson = -1

    for i in range(n):
        if seats[i] == 1:
            if lastPerson == -1:
                maxDist = i
            else:
                maxDist = max(maxDist, (i - lastPerson) // 2)
            lastPerson = i

    maxDist = max(maxDist, n - 1 - lastPerson)
    return maxDist
```

",,
"```python
def rectangleArea(rectangles):
    mod = 10**9 + 7
    n = len(rectangles)
    X, Y = set(), set()
    for rect in rectangles:
        X.add(rect[0])
        X.add(rect[2])
        Y.add(rect[1])
        Y.add(rect[3])
    sorted_x = sorted(X)
    sorted_y = sorted(Y)
    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]

    for rect in rectangles:
        x1_idx = sorted_x.index(rect[0])
        x2_idx = sorted_x.index(rect[2]) - 1
        y1_idx = sorted_y.index(rect[1])
        y2_idx = sorted_y.index(rect[3]) - 1
        for i in range(x1_idx, x2_idx + 1):
            for j in range(y1_idx, y2_idx + 1):
                cnt[i][j] = 1

    total_area = 0
    for i in range(len(X) - 1):
        for j in range(len(Y) - 1):
            if cnt[i][j]:
                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])
                total_area %= mod

    return total_area
```

",,
"```python
def to_goat_latin(sentence: str) -> str:
    words = sentence.split()
    vowels = set(""AEIOUaeiou"")
    result = []

    for i, word in enumerate(words):
        if word[0] not in vowels:
            word = word[1:] + word[0]
        result.append(word + ""ma"" + ""a"" * (i + 1))

    return ' '.join(result)
```

",,
"```python
def numFriendRequests(ages):
    count = [0] * 121
    total_requests = 0

    for age in ages:
        count[age] += 1

    for a in range(1, 121):
        for b in range(1, 121):
            if a * 0.5 + 7 >= b:
                continue
            if a < b:
                continue
            if a < b * 2:
                total_requests += count[a] * count[b]
                if a == b:
                    total_requests -= count[a]

    return total_requests
```

",,
"```python
def max_profit_assignment(difficulty, profit, worker):
    jobs = sorted(zip(difficulty, profit))
    worker.sort()

    i, max_profit, total_profit = 0, 0, 0
    for ability in worker:
        while i < len(difficulty) and ability >= jobs[i][0]:
            max_profit = max(max_profit, jobs[i][1])
            i += 1
        total_profit += max_profit
    return total_profit
```

",,
"```python
def kSimilarity(s1: str, s2: str) -> int:
    k = 0
    temp = list(s1)

    for i in range(len(temp)):
        if temp[i] != s2[i]:
            j = i + 1
            while temp[j] != s2[i] or s2[j] == temp[j]:
                j += 1
            temp[i], temp[j] = temp[j], temp[i]
            k += 1

    return k
```

",,
"```python
def count_unique_chars(s):
    return len(set(s))

def sum_count_unique_chars(s):
    sum = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            sum += count_unique_chars(s[i:j])
    return sum
```

",,
"```python
def consecutive_numbers_sum(n: int) -> int:
    count = 0
    i = 1
    while i * (i - 1) // 2 < n:
        if (n - i * (i - 1) // 2) % i == 0:
            count += 1
        i += 1
    return count
```


",,
"```python
def largeGroupPositions(s: str):
    result = []
    start = 0
    for i in range(1, len(s)):
        if s[i] != s[start]:
            if i - start >= 3:
                result.append([start, i - 1])
            start = i
    if len(s) - start >= 3:
        result.append([start, len(s) - 1])
    return result
```


",,
"```python
def mask_information(s: str) -> str:
    if '@' in s:
        s = s.lower()
        return s[0] + ""*****"" + s[s.index('@') - 1:]
    else:
        digits = """".join(filter(str.isdigit, s))
        if len(digits) == 10:
            return ""***-***-"" + digits[-4:]
        prefix = ""*""* (len(digits) - 10) + ""-""
        return ""+"" + prefix + ""***-***-"" + digits[-4:]
```

",,
"#

```javascript
class MyCircularDeque {
    constructor(k) {
        this.buffer = new Array(k);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    insertFront(value) {
        if (this.size == this.buffer.length) return false;
        this.front = (this.front - 1 + this.buffer.length) % this.buffer.length;
        this.buffer[this.front] = value;
        this.size++;
        return true;
    }

    insertLast(value) {
        if (this.size == this.buffer.length) return false;
        this.buffer[this.rear] = value;
        this.rear = (this.rear + 1) % this.buffer.length;
        this.size++;
        return true;
    }

    deleteFront() {
        if (this.size == 0) return false;
        this.front = (this.front + 1) % this.buffer.length;
        this.size--;
        return true;
    }

    deleteLast() {
        if (this.size == 0) return false;
        this.rear = (this.rear - 1 + this.buffer.length) % this.buffer.length;
        this.size--;
        return true;
    }

    getFront() {
        if (this.size == 0) return -1;
        return this.buffer[this.front];
    }

    getRear() {
        if (this.size == 0) return -1;
        return this.buffer[(this.rear - 1 + this.buffer.length) % this.buffer.length];
    }

    isEmpty() {
        return this.size == 0;
    }

    isFull() {
        return this.size == this.buffer.length;
    }
}
```

#
",,
"```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.head = 0
        self.tail = -1
        self.size = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.tail = (self.tail + 1) % self.capacity
        self.data[self.tail] = value
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.head]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.tail]

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity
```

",,
"```python
def flipAndInvertImage(image):
    for row in image:
        row.reverse()
        for j in range(len(row)):
            row[j] = 1 - row[j]
    return image
```

",,
"```python
def findReplaceString(s, indices, sources, targets):
    index_mapping = sorted(
        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]
    )
    result = []
    last_idx = 0

    for idx, i in index_mapping:
        result.append(s[last_idx:idx])
        result.append(targets[i])
        last_idx = idx + len(sources[i])

    result.append(s[last_idx:])
    return """".join(result)
```

",,
"```python
from collections import defaultdict

def sumOfDistancesInTree(n, edges):
    tree = defaultdict(set)
    for u, v in edges:
        tree[u].add(v)
        tree[v].add(u)

    count = [1] * n
    res = [0] * n

    def dfs(node, parent):
        for child in tree[node]:
            if child != parent:
                dfs(child, node)
                count[node] += count[child]
                res[node] += res[child] + count[child]

    def dfs2(node, parent):
        for child in tree[node]:
            if child != parent:
                res[child] = res[node] - count[child] + n - count[child]
                dfs2(child, node)

    dfs(0, -1)
    dfs2(0, -1)

    return res
```


",,
"```python
def largestOverlap(img1, img2):
    n = len(img1)
    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]
    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]

    overlaps = {}
    for pt1 in onesImg1:
        for pt2 in onesImg2:
            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]
            key = (dx, dy)
            if key not in overlaps:
                overlaps[key] = 0
            overlaps[key] += 1

    return max(overlaps.values() or [0])
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        def find_deepest(node):
            if not node:
                return None, 0
            left, left_height = find_deepest(node.left)
            right, right_height = find_deepest(node.right)
            if left_height == right_height:
                return node, left_height + 1
            return (left, left_height + 1) if left_height > right_height else (right, right_height + 1)

        return find_deepest(root)[0]
```

",,
"```python
def isRectangleOverlap(rec1, rec2):
    return rec1[2] > rec2[0] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[1] < rec2[3]
```

",,
"```python
def new21Game(n: int, k: int, maxPts: int) -> float:
    if k == 0 or n >= k + maxPts:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = 1
    s, ans = 1, 0

    for i in range(1, n + 1):
        dp[i] = s / maxPts
        if i < k:
            s += dp[i]
        else:
            ans += dp[i]
        if i >= maxPts:
            s -= dp[i - maxPts]

    return ans
```


",,
"```python
def push_dominoes(dominoes: str) -> str:
    prev, cur = None, dominoes
    while prev != cur:
        prev = cur
        cur_lst = list(prev)
        for i in range(len(cur)):
            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':
                cur_lst[i - 1] = 'L'
            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':
                cur_lst[i + 1] = 'R'
        cur = ''.join(cur_lst)
    return cur
```

",,
"```python
def is_similar(a: str, b: str) -> bool:
    diff_count = 0
    for char_a, char_b in zip(a, b):
        if char_a != char_b:
            diff_count += 1
            if diff_count > 2:
                return False
    return True

def count_groups(strs: list[str]) -> int:
    count = 0
    visited = [False] * len(strs)
    for i in range(len(strs)):
        if not visited[i]:
            count += 1
            visited[i] = True
            for j in range(i + 1, len(strs)):
                if is_similar(strs[i], strs[j]):
                    visited[j] = True
    return count
```


",,
"```python
from sortedcontainers import SortedList

def advantage_count(nums1, nums2):
    nums1_sorted = SortedList(nums1)
    result = []
    for num in nums2:
        index = nums1_sorted.bisect_right(num)
        if index == len(nums1_sorted):
            val = nums1_sorted.pop(0)
        else:
            val = nums1_sorted.pop(index)
        result.append(val)
    return result
```

",,
"```python
def can_visit_all_rooms(rooms):
    visited = set()
    stack = [0]

    while stack:
        current_room = stack.pop()

        visited.add(current_room)

        for key in rooms[current_room]:
            if key not in visited:
                stack.append(key)

    return len(visited) == len(rooms)
```

",,
"```python
def splitIntoFibonacci(num):
    ans = []
    def backtrack(index, prev1, prev2):
        if index == len(num):
            return len(ans) >= 3
        curr = 0
        for i in range(index, len(num)):
            if i > index and num[index] == '0':
                break
            curr = curr * 10 + ord(num[i]) - ord('0')
            if curr > 2**31 - 1:
                break
            if len(ans) >= 2:
                if curr < prev1 + prev2:
                    continue
                elif curr > prev1 + prev2:
                    break
            ans.append(curr)
            if backtrack(i + 1, prev2, curr):
                return True
            ans.pop()
        return False
            
    backtrack(0, 0, 0)
    return ans
```

",,
"```python
import random

def match(a, b):
    return sum(a[i] == b[i] for i in range(6))

def find_secret_word(wordlist, master):
    for _ in range(10):
        guess = random.choice(wordlist)
        match_cnt = master.guess(guess)
        if match_cnt == 6:
            return
        wordlist = [word for word in wordlist if match(word, guess) == match_cnt]
```

",,
"```python
def backspace_compare(s, t):
    def process_backspaces(string):
        stack = []
        for c in string:
            if c != '#':
                stack.append(c)
            elif stack:
                stack.pop()
        return stack

    return process_backspaces(s) == process_backspaces(t)
```

",,
"```python
def longest_mountain(arr):
    n = len(arr)
    max_length = 0
    i = 1
    while i < n - 1:
        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:
            left = i - 1
            right = i + 1
            while left > 0 and arr[left - 1] < arr[left]:
                left -= 1
            while right < n - 1 and arr[right] > arr[right + 1]:
                right += 1
            max_length = max(max_length, right - left + 1)
            i = right
        else:
            i += 1
    return max_length
```

",,
"```python
from collections import Counter

def is_n_straight_hand(hand, group_size):
    counts = Counter(hand)

    for card in sorted(counts):
        if counts[card] > 0:
            for i in range(group_size - 1, -1, -1):
                if counts[card + i] < counts[card]:
                    return False
                counts[card + i] -= counts[card]

    return True
```


",,
"```python
from collections import deque, defaultdict

def shortestPathLength(graph):
    n = len(graph)
    q = deque()
    
    for i in range(n):
        q.append((i, 1 << i))
    steps = -1
    visited = {i: set() for i in range(n)}
    
    while q:
        steps += 1
        for _ in range(len(q)):
            currNode, currVisits = q.popleft()
            
            if bin(currVisits).count('1') == n:
                return steps

            for nextNode in graph[currNode]:
                nextVisits = currVisits | (1 << nextNode)

                if nextVisits not in visited[nextNode]:
                    visited[nextNode].add(nextVisits)
                    q.append((nextNode, nextVisits))

    return -1
```


",,
"```python
def shiftingLetters(s: str, shifts: list[int]) -> str:
    n = len(s)
    for i in range(n - 2, -1, -1):
        shifts[i] = (shifts[i] + shifts[i + 1]) % 26
    
    result = []
    for i in range(n):
        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))
    
    return """".join(result)
```

",,
"```python
def max_dist_to_closest(seats):
    max_dist = 0
    last_person = -1
    for i, seat in enumerate(seats):
        if seat == 1:
            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)
            last_person = i
    return max(max_dist, len(seats) - 1 - last_person)
```

",,
"```python
def rectangleArea(rectangles):
    mod = 10**9 + 7
    X = sorted(set(x for rect in rectangles for x in rect[::2]))
    Xdict = {x:i for i,x in enumerate(X)}

    events = []
    for x1,y1,x2,y2 in rectangles:
        events.append((Xdict[x1], 1, y1, y2))
        events.append((Xdict[x2], -1, y1, y2))
    events.sort()

    area = 0
    cnt = [0] * len(X)
    active = 0
    for idx, type, y1, y2 in events:
        area = (area + (X[idx+1] - X[idx]) * active % mod) % mod
        cnt[y1] += type
        cnt[y2] -= type
        active = sum(p for j,p in zip(X, cnt) if p)

    return area
```

",,
"```python
from collections import defaultdict

def loudAndRich(richer, quiet):
    n = len(quiet)
    graph = defaultdict(list)
    for r in richer:
        graph[r[1]].append(r[0])

    answer = [-1] * n

    def dfs(x):
        if answer[x] != -1:
            return answer[x]
        answer[x] = x
        for y in graph[x]:
            cand = dfs(y)
            if quiet[cand] < quiet[answer[x]]:
                answer[x] = cand
        return answer[x]

    for i in range(n):
        dfs(i)

    return answer
```


",,
"```python
def peakIndexInMountainArray(arr):
    low, high = 0, len(arr) - 1
    while low < high:
        mid = low + (high - low) // 2
        if arr[mid] < arr[mid + 1]:
            low = mid + 1
        else:
            high = mid
    return low
```

",,
"```python
def carFleet(target: int, position: List[int], speed: List[int]) -> int:
    cars = sorted(zip(position, speed), reverse=True)
    fleets = 0
    last_arrival = -1

    for pos, sp in cars:
        arrival = (target - pos) / sp
        if arrival > last_arrival:
            fleets += 1
            last_arrival = arrival

    return fleets
```


",,
"```python
def k_similarity(s1, s2):
    k = 0
    a, b = list(s1), list(s2)
    for i in range(len(a)):
        if a[i] != b[i]:
            for j in range(i + 1, len(b)):
                if a[i] == b[j] and a[j] != b[j]:
                    a[i], a[j] = a[j], a[i]
                    k += 1
                    break
    return k
```

",,
"```python
from bisect import bisect_left, insort_left

class ExamRoom:

    def __init__(self, n: int):
        self.students = []
        self.n = n

    def seat(self) -> int:
        if not self.students:
            seat_index = 0
        else:
            distance, seat_index = self.students[0], 0
            
            for i in range(1, len(self.students)):
                d = (self.students[i] - self.students[i - 1]) // 2
                if d > distance:
                    distance = d
                    seat_index = self.students[i - 1] + d
                    
            if self.n - 1 - self.students[-1] > distance:
                seat_index = self.n - 1
                
        insort_left(self.students, seat_index)
        return seat_index

    def leave(self, p: int) -> None:
        index = bisect_left(self.students, p)
        self.students.pop(index)
```


",,
"```python
def scoreOfParentheses(s):
    score, depth = 0, 0
    for i in range(len(s)):
        if s[i] == '(':
            depth += 1
        else:
            depth -= 1
            if s[i - 1] == '(':
                score += 1 << depth
    return score
```

",,
"```python
import heapq

def mincost_to_hire_workers(quality, wage, k):
    workers = sorted((w / q, q) for w, q in zip(wage, quality))
    total_quality = 0
    max_heap = []
    result = float(""inf"")

    for ratio, q in workers:
        heapq.heappush(max_heap, -q)
        total_quality += q

        if len(max_heap) > k:
            total_quality += heapq.heappop(max_heap)

        if len(max_heap) == k:
            result = min(result, total_quality * ratio)

    return result
```

",,
"```python
def mirrorReflection(p, q):
    from math import gcd
    m = p // gcd(p, q)

    if m % 2 == 0:
        return 2
    if (q // gcd(p, q)) % 2 == 0:
        return 0
    return 1
```

",,
"```python
def are_almost_equal(s, goal):
    if s == goal:
        return True
    count = 0
    index1, index2 = -1, -1
    for i in range(len(s)):
        if s[i] != goal[i]:
            count += 1
            if index1 == -1:
                index1 = i
            else:
                index2 = i
            if count > 2:
                return False
    return count == 2 and s[index1] == goal[index2] and s[index2] == goal[index1]
```

",,
"```python
def lemonadeChange(bills):
    five, ten = 0, 0
    for bill in bills:
        if bill == 5:
            five += 1
        elif bill == 10:
            if not five:
                return False
            five -= 1
            ten += 1
        else:
            if ten and five:
                ten -= 1
                five -= 1
            elif five >= 3:
                five -= 3
            else:
                return False
    return True
```

",,
"```python
def matrixScore(grid):
    m, n = len(grid), len(grid[0])
    for i in range(m):
        if grid[i][0] == 0:
            for j in range(n):
                grid[i][j] = 1 - grid[i][j]
    for j in range(1, n):
        count = sum(grid[i][j] for i in range(m))
        if count <= m // 2:
            for i in range(m):
                grid[i][j] = 1 - grid[i][j]
    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))
```

",,
"```python
from collections import deque

def shortest_subarray(nums, k):
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    res = n + 1
    dq = deque()
    for i in range(n + 1):
        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
            res = min(res, i - dq.popleft())
        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:
            dq.pop()
        dq.append(i)

    return res if res <= n else -1
```

",,
"```python
from collections import defaultdict

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def find_nodes_at_distance_k(root, target_val, k):
    if k < 0:
        return []

    parent_map = defaultdict(lambda: None)
    visited = set()
    target_node = initialize_parent_map(root, None, target_val, parent_map)

    result = []
    find_nodes_at_distance_k_helper(target_node, k, visited, parent_map, result)
    return result

def initialize_parent_map(node, parent, target_val, parent_map):
    if not node:
        return None
    if node.val == target_val:
        return node

    parent_map[node] = parent
    left = initialize_parent_map(node.left, node, target_val, parent_map)
    right = initialize_parent_map(node.right, node, target_val, parent_map)
    return left if left else right

def find_nodes_at_distance_k_helper(node, k, visited, parent_map, result):
    if not node or node in visited:
        return

    visited.add(node)
    if k == 0:
        result.append(node.val)
        return

    find_nodes_at_distance_k_helper(node.left, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(node.right, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(parent_map[node], k-1, visited, parent_map, result)
```


",,
"```python
import random

class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        self.blacklist_map = {}
        self.reduced_n = n - len(blacklist)

        for b in blacklist:
            if b < n:
                self.blacklist_map[b] = -1

        for b in blacklist:
            if b >= self.reduced_n:
                continue
            while n - 1 in self.blacklist_map:
                n -= 1
            self.blacklist_map[b] = n - 1
            n -= 1

    def pick(self) -> int:
        random_int = random.randint(0, self.reduced_n - 1)
        return self.blacklist_map.get(random_int, random_int)
```

",,
"```python
from collections import deque

def shortestPathAllKeys(grid):
    m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '@':
                x, y = i, j
            elif 'a' <= grid[i][j] <= 'f':
                k = max(k, ord(grid[i][j]) - ord('a') + 1)

    q = deque([(x, y, 0)])
    visited = {(x, y, mask)}

    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]

    while q:
        qs = len(q)
        for sz in range(qs):
            x, y, mask = q.popleft()

            if mask == (1 << k) - 1:
                return steps

            for dx, dy in dirs:
                nx, ny, nmask = x + dx, y + dy, mask

                if 0 <= nx < m and 0 <= ny < n:
                    c = grid[nx][ny]
                    if 'A' <= c <= 'F' and not nmask & (1 << (ord(c) - ord('A'))):
                        continue
                    if 'a' <= c <= 'f':
                        nmask |= (1 << (ord(c) - ord('a')))

                    if (nx, ny, nmask) in visited:
                        continue

                    visited.add((nx, ny, nmask))
                    q.append((nx, ny, nmask))

        steps += 1

    return -1
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(node):
    if node is None:
        return 0
    else:
        return max(maxDepth(node.left), maxDepth(node.right)) + 1

def subtreeWithAllDeepest(root):
    if root is None:
        return None

    leftDepth = maxDepth(root.left)
    rightDepth = maxDepth(root.right)

    if leftDepth == rightDepth:
        return root

    if leftDepth > rightDepth:
        return subtreeWithAllDeepest(root.left)
    else:
        return subtreeWithAllDeepest(root.right)
```

",,
"```python
def is_prime(n):
    if n <= 1:
        return False
    i = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += 1
    return True

def is_palindrome(n):
    return str(n) == str(n)[::-1]

def prime_palindrome(n):
    while True:
        if is_prime(n) and is_palindrome(n):
            return n
        n += 1
```

",,
"```python
def transpose(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    result = [[0] * rows for _ in range(cols)]
    for i in range(rows):
        for j in range(cols):
            result[j][i] = matrix[i][j]
    return result
```

",,
"```python
def longest_distance(n):
    last = -1
    longest = 0
    i = 0
    while n:
        if n & 1:
            if last >= 0:
                longest = max(longest, i - last)
            last = i
        n >>= 1
        i += 1
    return longest
```

",,
"```python
from itertools import permutations as perm

def reorderedPowerOf2(n):
    for p in set(perm(str(n))):
        if p[0] != '0' and (bin(int(''.join(p))).count('1') == 1):
            return True
    return False
```


",,
"```python
from collections import defaultdict
from sortedcontainers import SortedList

def advantageCount(nums1, nums2):
    d = defaultdict(int)
    sorted_nums1 = SortedList(nums1)
    res = []
    
    for num in nums2:
        i = sorted_nums1.bisect_right(num)
        if i == len(sorted_nums1):
            i = 0
        res.append(sorted_nums1.pop(i))
    return res
```

",,
"```python
import heapq

def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:
    i, stops, curFuel = 0, 0, startFuel
    pq = []
    while curFuel < target:
        while i < len(stations) and stations[i][0] <= curFuel:
            heapq.heappush(pq, -stations[i][1])
            i += 1
        if not pq: return -1
        curFuel += -heapq.heappop(pq)
        stops += 1
    return stops
```


",,
"```python
def rand7(): # Given API
    pass

def rand10():
    result = 41
    while result > 40:
        result = (rand7() - 1) * 7 + rand7()
    return result % 10 + 1
```

",,
"```python
def leafSimilar(root1, root2):
    def getLeaves(node):
        if not node:
            return []
        if not node.left and not node.right:
            return [node.val]
        return getLeaves(node.left) + getLeaves(node.right)

    return getLeaves(root1) == getLeaves(root2)
```

",,
"```python
def lenLongestFibSubseq(arr):
    index = {x: i for i, x in enumerate(arr)}

    longest = dict()
    ans = 0

    for k, z in enumerate(arr):
        for j, y in enumerate(arr[:k]):
            i = index.get(z - y, None)
            if i is not None and i < j:
                longest[j, k] = longest.get((i, j), 1) + 1
                ans = max(ans, longest[j, k] + 1)

    return ans if ans >= 3 else 0
```

",,
"```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        x = y = di = 0
        obstacleSet = set(map(tuple, obstacles))

        ans = 0
        for cmd in commands:
            if cmd == -2:
                di = (di - 1) % 4
            elif cmd == -1:
                di = (di + 1) % 4
            else:
                for k in range(cmd):
                    nx = x + dx[di]
                    ny = y + dy[di]
                    if (nx, ny) not in obstacleSet:
                        x = nx
                        y = ny
                        ans = max(ans, x * x + y * y)

        return ans
```


",,
"```python
def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    while left < right:
        mid = left + (right - left) // 2
        totalHours = sum((pile + mid - 1) // mid for pile in piles)
        if totalHours > h:
            left = mid + 1
        else:
            right = mid
    return left
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def middleNode(head):
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

",,
"```python
def aliceWins(piles):
    n = len(piles)
    dp = [[0] * n for _ in range(n)]
    for gap in range(n):
        for i in range(n - gap):
            j = i + gap
            x = dp[i + 2][j] if i + 2 <= j else 0
            y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0
            z = dp[i][j - 2] if i <= j - 2 else 0
            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z))
    sum_of_piles = sum(piles)
    return dp[0][n - 1] > (sum_of_piles - dp[0][n - 1])
```

",,
"```python
def nthMagicalNumber(n, a, b):
    mod = 1000000007
    lcm = a * b // gcd(a, b)
    left, right = 1, 10**14
    while left < right:
        mid = left + (right - left) // 2
        if (mid // a + mid // b - mid // lcm) < n:
            left = mid + 1
        else:
            right = mid
    return left % mod

def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
```

",,
"```python
def profitableSchemes(n, minProfit, group, profit):
    dp = [[0] * (minProfit + 1) for _ in range(n + 1)]
    mod = 10**9 + 7
    dp[0][0] = 1
    for i in range(len(group)):
        for j in range(n, group[i] - 1, -1):
            for k in range(minProfit, -1, -1):
                dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % mod
    return sum(dp[i][minProfit] for i in range(1, n + 1)) % mod
```

",,
"```python
import random
from bisect import bisect_left

class Solution:

    def __init__(self, w: List[int]):
        self.prefix_sum = []
        for weight in w:
            previous = self.prefix_sum[-1] if self.prefix_sum else 0
            self.prefix_sum.append(previous + weight)

    def pickIndex(self) -> int:
        num = random.random() * self.prefix_sum[-1]
        return bisect_left(self.prefix_sum, num)
```

",,
"```python
import random

class Solution:
    def __init__(self, m, n):
        self.grid = [[0] * n for _ in range(m)]
        self.zero_count = m * n

    def pick(self):
        index = random.randrange(self.zero_count)

        for i, row in enumerate(self.grid):
            for j, cell in enumerate(row):
                if cell == 0:
                    if index == 0:
                        self.grid[i][j] = 1
                        self.zero_count -= 1
                        return (i, j)
                    index -= 1
        return (-1, -1)  # Should not happen
```

",,
"```python
import random
from bisect import bisect_left

class Solution:
    def __init__(self, rects):
        self.rects = rects
        self.areas = []
        self.total_area = 0
        for rect in rects:
            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)
            self.total_area += area
            self.areas.append(self.total_area)

    def pick(self):
        random_area = random.randint(0, self.total_area - 1)
        rect_index = bisect_left(self.areas, random_area + 1)

        x = random.randint(self.rects[rect_index][0], self.rects[rect_index][2])
        y = random.randint(self.rects[rect_index][1], self.rects[rect_index][3])

        return [x, y]
```


",,
"```python
import random
import math

class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self):
        angle = random.random() * 2 * math.pi
        r = math.sqrt(random.random()) * self.radius
        return [self.x_center + r * math.cos(angle), self.y_center + r * math.sin(angle)]
```

",,
"```python
def find_kth_character(s: str, k: int) -> str:
    n = len(s)
    size = 0

    for c in s:
        if c.isdigit():
            size = size * int(c)
        else:
            size += 1

    for i in range(n - 1, -1, -1):
        c = s[i]
        k %= size
        if k == 0 and not c.isdigit():
            return c

        if c.isdigit():
            size //= int(c)
        else:
            size -= 1

    return '-'
```

",,
"```python
def num_rescue_boats(people, limit):
    people.sort()
    left, right = 0, len(people) - 1
    boats = 0
    while left <= right:
        if people[left] + people[right] <= limit:
            left += 1
        right -= 1
        boats += 1
    return boats
```

",,
"```python
from heapq import heappush, heappop

def reachableNodes(edges, maxMoves, n):
    graph = [[] for _ in range(n)]
    for u, v, cnt in edges:
        graph[u].append((v, cnt + 1))
        graph[v].append((u, cnt + 1))

    visited = set()
    pq = [(-maxMoves, 0)]

    while pq:
        moves_left, node = heappop(pq)

        if node in visited:
            continue
        visited.add(node)

        for next_node, moves_needed in graph[node]:
            moves_left_after = moves_left - moves_needed
            if next_node not in visited and moves_left_after > 0:
                heappush(pq, (moves_left_after, next_node))

    return len(visited)
```


",,
"```python
def projectionArea(grid):
    n = len(grid)
    top, front, side = 0, 0, 0
    for i in range(n):
        max_front, max_side = 0, 0
        for j in range(n):
            if grid[i][j] > 0:
                top += 1
            max_front = max(max_front, grid[i][j])
            max_side = max(max_side, grid[j][i])
        front += max_front
        side += max_side
    return top + front + side
```

",,
"```python
def uncommon_from_sentences(s1, s2):
    word_count = {}
    for word in (s1 + "" "" + s2).split():
        word_count[word] = word_count.get(word, 0) + 1

    return [key for key, val in word_count.items() if val == 1]
```

",,
"```python
def spiral_walk(rows, cols, rStart, cStart):
    result = []
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    moves = rows * cols
    r, c, dir = rStart, cStart, 0
    
    while len(result) < moves:
        result.append([r, c])
        r += dr[dir]
        c += dc[dir]
        
        if r < 0 or r >= rows or c < 0 or c >= cols:
            r -= dr[dir]
            c -= dc[dir]
            dir = (dir + 1) % 4
            r += dr[dir]
            c += dc[dir]

    return result
```

",,
"```python
from collections import defaultdict


def possible_bipartition(n, dislikes):
    def dfs(person, group):
        if person in groups:
            return groups[person] == group
        groups[person] = group
        for other in dislike_list[person]:
            if not dfs(other, -group):
                return False
        return True

    groups = {}
    dislike_list = defaultdict(list)
    for p1, p2 in dislikes:
        dislike_list[p1].append(p2)
        dislike_list[p2].append(p1)

    for person in range(1, n + 1):
        if person not in groups and not dfs(person, 1):
            return False

    return True
```


",,
"```python
def min_moves(k, n):
    if k == 1 or n == 0 or n == 1:
        return n
    
    res = float('inf')
    for i in range(1, n + 1):
        temp = max(min_moves(k - 1, i - 1), min_moves(k, n - i))
        res = min(res, temp)
    
    return res + 1
```

",,
"```python
def fair_candy_swap(aliceSizes, bobSizes):
    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)
    delta = (bobTotal - aliceTotal) // 2
    for a in aliceSizes:
        for b in bobSizes:
            if a + delta == b:
                return [a, b]
    return []
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def constructFromPrePost(self, pre, post):
        def buildTree(preStart, preEnd, postStart, postEnd):
            if preStart == preEnd:
                return None

            root = TreeNode(pre[preStart])

            if preStart + 1 == preEnd:
                return root

            leftRoot = pre[preStart + 1]

            leftSize = 0
            for i in range(postStart, postEnd):
                if post[i] == leftRoot:
                    leftSize = i - postStart + 1
                    break

            root.left = buildTree(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize)
            root.right = buildTree(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1)

            return root

        return buildTree(0, len(pre), 0, len(post))
```

",,
"```python
def find_and_replace_patterns(words, pattern):
    result = []
    for word in words:
        if len(word) != len(pattern): continue

        w2p = {}
        p2w = {}
        matches = True
        for cWord, cPattern in zip(word, pattern):
            if cWord not in w2p: w2p[cWord] = cPattern
            if cPattern not in p2w: p2w[cPattern] = cWord

            if w2p[cWord] != cPattern or p2w[cPattern] != cWord:
                matches = False
                break

        if matches: result.append(word)
    return result
```


",,
"```python
def sum_of_widths(nums):
    MOD = 10**9 + 7
    nums.sort()
    c, res = 1, 0
    n = len(nums)

    for i in range(n):
        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD
        c = c * 2 % MOD

    return res
```

",,
"```python
def surfaceArea(grid):
    n = len(grid)
    area = 0

    for i in range(n):
        for j in range(n):
            if grid[i][j]:
                area += 4 * grid[i][j] + 2
                if i > 0:
                    area -= 2 * min(grid[i][j], grid[i - 1][j])
                if j > 0:
                    area -= 2 * min(grid[i][j], grid[i][j - 1])

    return area
```

",,
"```python
def num_special_equivalent_groups(words):
    groups = set()

    for word in words:
        evens = """".join(sorted(word[0::2]))
        odds = """".join(sorted(word[1::2]))

        groups.add(evens + odds)

    return len(groups)
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def all_possible_FBT(n):
    if n % 2 == 0:
        return []
    if n == 1:
        return [TreeNode(0)]

    result = []
    for i in range(1, n, 2):
        left = all_possible_FBT(i)
        right = all_possible_FBT(n - i - 1)
        for l in left:
            for r in right:
                root = TreeNode(0)
                root.left = l
                root.right = r
                result.append(root)
    return result
```

",,
"```python
from collections import defaultdict, deque

class FreqStack:
    def __init__(self):
        self.freq = defaultdict(int)
        self.group = defaultdict(list)

    def push(self, x: int):
        freq = self.freq[x] = self.freq[x] + 1
        self.group[freq].append(x)

    def pop(self) -> int:
        max_freq = max(self.group)
        x = self.group[max_freq].pop()
        self.freq[x] -= 1
        if not self.group[max_freq]:
            del self.group[max_freq]
        return x
```


",,
"```python
def isMonotonic(nums):
    increasing = decreasing = True
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]: decreasing = False
        if nums[i] < nums[i - 1]: increasing = False
    return increasing or decreasing
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def increasingBST(root):
    def inorder(node):
        nonlocal prev
        if not node: return

        inorder(node.left)
        prev.right = node
        prev = node
        node.left = None
        inorder(node.right)

    dummy = TreeNode(0)
    prev = dummy
    inorder(root)
    return dummy.right
```


",,
"```python
def subarrayBitwiseORs(arr: List[int]) -> int:
    result, current, temp = set(), set(), set()
    for num in arr:
        temp = {num}
        for c in current:
            temp.add(num | c)
        current = temp
        result |= current
    return len(result)
```

",,
"```python
def lex_smallest_string(s, k):
    res = s
    for i in range(k):
        tmp = s[i:] + s[:i]
        if tmp < res:
            res = tmp
    return res
```

",,
"```python
class RLEIterator:
    def __init__(self, encoding):
        self.encoding = encoding
        self.index = 0

    def next(self, n):
        while self.index < len(self.encoding):
            if n <= self.encoding[self.index]:
                self.encoding[self.index] -= n
                return self.encoding[self.index + 1]
            n -= self.encoding[self.index]
            self.index += 2
        return -1
```

",,
"```python
class StockSpanner:

    def __init__(self):
        self.prices = []
        self.index_stack = []

    def next(self, price: int) -> int:
        while self.index_stack and self.prices[self.index_stack[-1]] <= price:
            self.index_stack.pop()
        span = len(self.prices) + 1 if not self.index_stack else len(self.prices) - self.index_stack[-1]
        self.index_stack.append(len(self.prices))
        self.prices.append(price)
        return span
```

",,
"```python
from bisect import bisect_right

def num_digits_less_than_n(digits: List[int], n: int) -> int:
    ans = 0
    factor = 1
    n_str = str(n)
    for i in range(len(n_str) - 1, -1, -1):
        ans += bisect_right(digits, int(n_str[i])) * factor
        factor *= len(digits)
    return ans
```

",,
"```python
def find_valid_permutations(s: str) -> int:
    n = len(s)
    MOD = 1000000007
    dp = [0] * (n + 2)
    dp[0] = 1

    for c in s:
        new_dp = [0] * (n + 2)
        if c == 'I':
            for i in range(n):
                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD
        else:
            for i in range(n - 1, -1, -1):
                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD
        dp = new_dp

    return dp[0]
```

",,
"```python
def totalFruit(fruits):
    left, right, max_count = 0, 0, 0
    count = {}

    while right < len(fruits):
        count[fruits[right]] = count.get(fruits[right], 0) + 1
        while len(count) > 2:
            count[fruits[left]] -= 1
            if count[fruits[left]] == 0:
                del count[fruits[left]]
            left += 1
        max_count = max(max_count, right - left + 1)
        right += 1

    return max_count
```

",,
"```python
def move_even_odd(nums):
    even_index = 0
    odd_index = len(nums) - 1

    while even_index < odd_index:
        if nums[even_index] % 2 == 0:
            even_index += 1
        else:
            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]
            odd_index -= 1

    return nums
```

",,
"```python
def isPalindrome(num):
    return str(num) == str(num)[::-1]

def superpalindromesInRange(left: str, right: str) -> int:
    l = int(left)
    r = int(right)
    cnt = 0
    base = 1
    while base * base <= r:
        if isPalindrome(base) and isPalindrome(base * base):
            if base * base >= l:
                cnt += 1
        base += 1
    return cnt
```


",,
"```python
def sum_of_mins(arr):
    mod = 10**9 + 7
    n = len(arr)
    left, right = [0] * n, [0] * n
    st = []

    for i in range(n):
        while st and arr[st[-1]] > arr[i]:
            st.pop()
        left[i] = st[-1] if st else -1
        st.append(i)

    st.clear()
    for i in range(n - 1, -1, -1):
        while st and arr[st[-1]] > arr[i]:
            st.pop()
        right[i] = st[-1] if st else n
        st.append(i)

    ans = 0
    for i in range(n):
        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod
    return ans
```

",,
"```python
def minDifference(nums, k):
    if len(nums) <= 1: return 0
    nums.sort()
    min_diff = nums[-1] - nums[0]
    for i in range(1, len(nums)):
        high = max(nums[i-1] + k, nums[-1] - k)
        low = min(nums[i] - k, nums[0] + k)
        min_diff = min(min_diff, high - low)
    return min_diff
```

",,
"```python
def snakesAndLadders(board):
    n = len(board)
    visited = [False] * (n*n + 1)
    queue = [(1, 0)]  # starting at position 1
    visited[1] = True

    def get_position(pos):
        r = (pos - 1) // n
        c = (pos - 1) % n
        if r % 2 == 1:
            c = n - 1 - c
        r = n - r - 1
        return r, c

    while queue:
        pos, steps = queue.pop(0)
        for jump in range(1, 7):
            next_pos = pos + jump
            if next_pos > n*n:
                break
            r, c = get_position(next_pos)
            if board[r][c] != -1:
                next_pos = board[r][c]
            if next_pos == n*n:
                return steps + 1
            if not visited[next_pos]:
                visited[next_pos] = True
                queue.append((next_pos, steps + 1))

    return -1
```


",,
"```python
def minimum_score(nums, k):
    nums.sort()
    n = len(nums)
    res = nums[n - 1] - nums[0]

    for i in range(n - 1):
        high = max(nums[i] + k, nums[n - 1] - k)
        low = min(nums[i + 1] - k, nums[0] + k)
        res = min(res, high - low)

    return res
```

",,
"```python
from collections import defaultdict
from bisect import bisect

class TopVotedCandidate:

    def __init__(self, persons, times):
        self.leader_map = {}
        self.times = times
        votes = defaultdict(int)
        leader = -1
        for i, t in enumerate(times):
            votes[persons[i]] += 1
            if votes[persons[i]] >= votes[leader]:
                leader = persons[i]
            self.leader_map[t] = leader

    def q(self, t):
        idx = bisect.bisect(self.times, t)
        return self.times[idx - 1]
```

",,
"```python
def sortArray(nums):
    nums.sort()
```

",,
"```python
from collections import deque

def catMouseGame(graph):
    n = len(graph)
    status = [[[0]*3 for _ in range(n)] for _ in range(n)]

    for i in range(1, n):
        status[i][i][1] = 2
        status[i][i][2] = 2
    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])

    while queue:
        pos_m, pos_c, t_type, t_result = queue.popleft()

        for prev in graph[pos_m if t_type == 1 else pos_c]:
            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):
                continue
            if status[prev][pos_c][3 - t_type]:
                continue
            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))
            status[prev][pos_c][3 - t_type] = 3 - t_result

    return status[1][2][1]
```


",,
"```python
from collections import Counter
from math import gcd
from functools import reduce

def hasGroupsSizeX(deck):
    counts = Counter(deck)
    gcd_result = reduce(gcd, counts.values())
    return gcd_result > 1
```

",,
"```python
def partitionDisjoint(nums):
    left_max, global_max, left_length = nums[0], nums[0], 1
    for i in range(1, len(nums)):
        if nums[i] < left_max:
            left_max = global_max
            left_length = i + 1
        else:
            global_max = max(global_max, nums[i])
    return left_length
```

",,
"```python
from collections import Counter

def word_subsets(words1, words2):
    max_chars = Counter()
    for word in words2:
        chars = Counter(word)
        for c, count in chars.items():
            max_chars[c] = max(max_chars[c], count)
    
    result = []
    for word in words1:
        word_chars = Counter(word)
        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)
        if universal:
            result.append(word)
    
    return result
```


",,
"```python
def reverse_string(s):
    return s[::-1]
```


",,
"```python
def canReorderDoubled(arr):
    count = collections.Counter(arr)
    
    for a in sorted(count, key=abs):
        if count[a] > 0:
            target = a * 2
            if count[target] < count[a]:
                return False
            count[target] -= count[a]

    return True
```

",,
"```python
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class CBTInserter:
    def __init__(self, root: TreeNode):
        self.root = root
        self.q = deque([root])
        while True:
            node = self.q[0]
            if not node.left or not node.right:
                break
            self.q.append(node.left)
            self.q.append(node.right)
            self.q.popleft()

    def insert(self, v: int) -> int:
        newNode = TreeNode(v)
        parentNode = self.q[0]
        if not parentNode.left:
            parentNode.left = newNode
        else:
            parentNode.right = newNode
            self.q.append(parentNode.left)
            self.q.append(parentNode.right)
            self.q.popleft()
        return parentNode.val

    def get_root(self) -> TreeNode:
        return self.root
```


",,
"```python
def numMusicPlaylists(n, goal, k):
    MOD = 1000000007
    dp = [[0] * (n + 1) for _ in range(goal + 1)]
    dp[0][0] = 1
    for i in range(1, goal + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD
    return dp[goal][n]
```

",,
"```python
def minAddToMakeValid(s: str) -> int:
    result = balance = 0
    for c in s:
        balance += 1 if c == '(' else -1
        if balance == -1:
            result += 1
            balance += 1
    return result + balance
```

",,
"```python
def sortArrayByParityII(nums):
    j = 1
    for i in range(0, len(nums), 2):
        if nums[i] % 2:
            while nums[j] % 2:
                j += 2
            nums[i], nums[j] = nums[j], nums[i]
    return nums
```

",,
"```python
def threeSumMulti(arr, target):
    MOD = 1000000007
    ans = 0

    arr.sort()
    n = len(arr)

    for i in range(n - 2):
        j, k = i + 1, n - 1
        while j < k:
            s = arr[i] + arr[j] + arr[k]
            if s > target:
                k -= 1
            elif s < target:
                j += 1
            else:
                if arr[j] != arr[k]:
                    left_count = right_count = 1

                    while j < n - 1 and arr[j] == arr[j + 1]:
                        left_count += 1
                        j += 1

                    while k > 0 and arr[k] == arr[k - 1]:
                        right_count += 1
                        k -= 1

                    ans += left_count * right_count
                    ans %= MOD
                    j += 1
                    k -= 1
                else:
                    ans += (k - j + 1) * (k - j) // 2
                    ans %= MOD
                    break

    return ans
```

",,
"```python
from collections import deque

def minMalwareSpread(graph, initial):
    n = len(graph)
    initial.sort()
    
    malware = set(initial)
    
    minNode = initial[0]
    minSpread = n + 1

    for node in initial:
        q = deque(otherNode for otherNode in initial if node != otherNode)
        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]
        
        while q:
            cur = q.popleft()
            for next, isConnected in enumerate(graph[cur]):
                if isConnected and not visited[next] and next not in malware:
                    visited[next] = True
                    q.append(next)
        
        spread = sum(visited)
        
        if spread < minSpread:
            minNode = node
            minSpread = spread
    
    return minNode
```


",,
"```python
def isLongPressedName(name: str, typed: str) -> bool:
    i, j = 0, 0
    while j < len(typed):
        if i < len(name) and name[i] == typed[j]:
            i += 1
        elif j == 0 or typed[j] != typed[j - 1]:
            return False
        j += 1
    return i == len(name)
```

",,
"```python
def minFlipsMonoIncr(s: str) -> int:
    flipCount, oneCount = 0, 0
    for c in s:
        if c == '1':
            oneCount += 1
        else:
            flipCount = min(flipCount + 1, oneCount)
    return flipCount
```

",,
"```python
def find_same_binary_value_parts(arr):
    ones = sum(arr)

    if ones % 3 != 0:
        return [-1, -1]

    target = ones // 3
    if target == 0:
        return [0, len(arr) - 2]

    count = 0
    i = j = -1
    ones = 0
    for idx, n in enumerate(arr):
        if n == 1:
            ones += 1
            if ones == target + 1:
                count += 1
            if count == 1 and i == -1:
                i = idx
            if count == 2 and j == -1:
                j = idx
            if count == 3:
                break

    return [i, j]
```

",,
"```python
from collections import deque
from typing import List

def minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:
    n = len(graph)
    color = [-1] * n
    colors = 0

    for i in range(n):
        if color[i] == -1:
            q = deque([i])
            color[i] = colors

            while q:
                t = q.popleft()
                for j in range(n):
                    if graph[t][j] == 1 and color[j] == -1:
                        q.append(j)
                        color[j] = colors

            colors += 1

    area = [0] * colors
    count = [0] * colors
    initially_infected = set(initial)
    for i in range(n):
        area[color[i]] += 1
        if i in initially_infected:
            count[color[i]] += 1

    res = min(initial)
    min_size = n + 1
    for i in initial:
        if count[color[i]] == 1:
            if area[color[i]] < min_size:
                min_size = area[color[i]]
                res = i
            elif area[color[i]] == min_size and i < res:
                res = i

    return res
```

",,
"```python
def num_unique_emails(emails):
    unique_emails = set()

    for email in emails:
        local_name, domain_name = email.split(""@"")
        local_name = local_name.split(""+"")[0]
        local_name = local_name.replace(""."", """")

        unique_emails.add(local_name + ""@"" + domain_name)

    return len(unique_emails)
```

",,
"```python
def num_subarrays_with_sum(nums, goal):
    from collections import defaultdict
    prefix_sum_count = defaultdict(int)
    prefix_sum_count[0] = 1
    cumulative_sum, result = 0, 0
    
    for num in nums:
        cumulative_sum += num
        result += prefix_sum_count[cumulative_sum - goal]
        prefix_sum_count[cumulative_sum] += 1
    
    return result
```

",,
"```python
def minFallingPathSum(matrix):
    n = len(matrix)
    for i in range(1, n):
        for j in range(n):
            min_val = matrix[i - 1][j]
            if j > 0: min_val = min(min_val, matrix[i - 1][j - 1])
            if j < n - 1: min_val = min(min_val, matrix[i - 1][j + 1])
            matrix[i][j] += min_val
    return min(matrix[-1])
```

",,
"```python
def beautifulArray(n: int) -> List[int]:
    result = [1]
    while len(result) < n:
        temp = []
        for i in result:
            if i * 2 - 1 <= n:
                temp.append(i * 2 - 1)
        for i in result:
            if i * 2 <= n:
                temp.append(i * 2)
        result = temp
    return result
```

",,
"```python
from collections import deque

class RecentCounter:
    def __init__(self):
        self.requests = deque()

    def ping(self, t: int) -> int:
        self.requests.append(t)
        while self.requests[0] < t - 3000:
            self.requests.popleft()
        return len(self.requests)
```

",,
"```python
def powerfulIntegers(x, y, bound):
    max_i = 0 if x == 1 else int(math.log(bound, x))
    max_j = 0 if y == 1 else int(math.log(bound, y))
    result_set = set()
    
    for i in range(max_i + 1):
        for j in range(max_j + 1):
            powerful_num = x ** i + y ** j
            if powerful_num <= bound:
                result_set.add(powerful_num)
                
    return list(result_set)
```

",,
"```python
from collections import deque

def shortestBridge(grid):
    n = len(grid)
    q = deque()

    # Find the first island and mark it
    for i in range(n):
        if any(grid[i]):
            first_row = i
            first_col = grid[first_row].index(1)
            break

    dfs(grid, q, first_row, first_col)

    steps = 0
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while q:
        for _ in range(len(q)):
            x, y = q.popleft()
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n:
                    if grid[nx][ny] == 1:
                        return steps
                    elif grid[nx][ny] == 0:
                        grid[nx][ny] = -1
                        q.append((nx, ny))
        steps += 1
    return -1

def dfs(grid, q, i, j):
    n = len(grid)
    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):
        return
    grid[i][j] = -1
    q.append((i, j))
    
    dfs(grid, q, i - 1, j)
    dfs(grid, q, i + 1, j)
    dfs(grid, q, i, j - 1)
    dfs(grid, q, i, j + 1)
```


",,
"```python
def knightDialer(n: int) -> int:
    if n == 1:
        return 10
    MOD = 10**9 + 7
    moves = [
        [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],
        [], [1, 7, 0], [2, 6], [1, 3], [2, 4]
    ]
    dp = [1] * 10
    for _ in range(2, n + 1):
        new_dp = [0] * 10
        for j in range(10):
            for move in moves[j]:
                new_dp[j] = (new_dp[j] + dp[move]) % MOD
        dp = new_dp
    return sum(dp) % MOD
```

",,
"```python
def moves_to_stamp(stamp: str, target: str) -> list:
    result = []
    is_stamped = [False] * len(target)
    stamp_count = 0
    target = list(target)

    while stamp_count < 10 * len(target):
        found_stamp = False
        for i in range(len(target) - len(stamp) + 1):
            if is_stamped[i]:
                continue
            j = 0
            overlap = 0
            while j < len(stamp) and (target[i + j] == '?' or target[i + j] == stamp[j]):
                if target[i + j] == stamp[j]:
                    overlap += 1
                j += 1
            if j == len(stamp) and overlap > 0:
                for j in range(len(stamp)):
                    target[i + j] = '?'
                result.append(i)
                is_stamped[i] = True
                found_stamp = True
        if not found_stamp:
            break
        
        stamp_count += 1

    for c in target:
        if c != '?':
            return []

    return result[::-1]
```


",,
"```python
def subarraysDivByK(nums, k):
    prefix_sums_mod_k = [0] * k
    prefix_sums_mod_k[0] = 1
    running_sum = 0
    count = 0
    
    for num in nums:
        running_sum += num
        mod = (running_sum % k + k) % k
        count += prefix_sums_mod_k[mod]
        prefix_sums_mod_k[mod] += 1
    
    return count
```

",,
"```python
def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
    if not root:
        return 0
    if root.val < low:
        return self.rangeSumBST(root.right, low, high)
    if root.val > high:
        return self.rangeSumBST(root.left, low, high)
    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)
```

",,
"```python
def min_area_rect(points):
    point_set = {(x, y) for x, y in points}
    min_area = float('inf')

    for p1 in point_set:
        for p2 in point_set:
            if p1[0] != p2[0] and p1[1] != p2[1]:
                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:
                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))

    return min_area if min_area != float('inf') else 0
```


",,
"```python
def distinctSubseqII(s):
    mod = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last = [-1] * 26

    for i in range(1, n + 1):
        dp[i] = (dp[i - 1] * 2) % mod
        if last[ord(s[i - 1]) - ord('a')] != -1:
            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod
        last[ord(s[i - 1]) - ord('a')] = i - 1

    dp[n] = (dp[n] - 1 + mod) % mod
    return dp[n]
```

",,
"```python
def valid_mountain_array(arr):
    n, i, j = len(arr), 0, len(arr) - 1
    while i + 1 < n and arr[i] < arr[i + 1]:
        i += 1
    while j > 0 and arr[j - 1] > arr[j]:
        j -= 1
    return i > 0 and i == j and j < n - 1
```

",,
"```python
def decode_permutation(s: str):
    n = len(s)
    perm = [0] * (n + 1)
    next_zero, next_one = 0, n

    for c in s:
        if c == '0':
            perm[next_zero] = next_one
            next_zero += 1
            next_one -= 1
        else:
            perm[next_one] = next_zero
            next_one -= 1
            next_zero += 1

    perm[next_zero] = next_one
    return perm
```


",,
"```python
from itertools import permutations

def smallestSuperstring(words):
    def get_shared_length(a, b):
        for shared_length in range(min(len(a), len(b)), 0, -1):
            if a[-shared_length:] == b[:shared_length]:
                return shared_length
        return 0

    def merge(a, b, shared_length):
        return a + b[shared_length:]

    def get_total_length(merged_words):
        return sum(len(word) for word in merged_words)

    best = None
    for perm in permutations(words):
        merged_words = list(perm)
        for i in range(len(words) - 1):
            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])
            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)
        if best is None or get_total_length(merged_words) < len(best):
            best = """".join(merged_words)

    return best
```

",,
"```python
def min_deletion_size(strs):
    num_deleted = 0
    for col in range(len(strs[0])):
        for row in range(1, len(strs)):
            if strs[row][col] < strs[row - 1][col]:
                num_deleted += 1
                break
    return num_deleted
```


",,
"```python
def min_moves_unique(nums):
    nums.sort()
    moves = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            diff = nums[i - 1] - nums[i] + 1
            moves += diff
            nums[i] += diff
    return moves
```

",,
"```python
def validateStackSequences(pushed, popped):
    stack = []
    popIndex = 0
    
    for pushValue in pushed:
        stack.append(pushValue)
        while stack and stack[-1] == popped[popIndex]:
            stack.pop()
            popIndex += 1
    
    return not stack
```


",,
"```python
from collections import defaultdict

def removeStones(stones):
    row_groups = defaultdict(int)
    col_groups = defaultdict(int)
    group_count = 0
    
    groups = defaultdict(list)
    
    for x, y in stones:
        if x not in row_groups:
            row_groups[x] = group_count
            group_count += 1
        if y + 10001 not in col_groups: # Offset by max row index
            col_groups[y + 10001] = group_count
            group_count += 1
            
        group_x, group_y = row_groups[x], col_groups[y + 10001]
        groups[group_x].append(group_y)
        groups[group_y].append(group_x)
    
    visited = [False] * group_count
    
    def dfs(groupId):
        if visited[groupId]:
            return 0
        visited[groupId] = True
        size = 1
        for neighbor in groups[groupId]:
            size += dfs(neighbor)
        return size
    
    max_stones = 0
    for groupId in range(group_count):
        max_stones += dfs(groupId) - 1
    
    return max_stones
```

",,
"```python
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    max_score = score = 0
    left, right = 0, len(tokens) - 1

    while left <= right:
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
            max_score = max(max_score, score)
        elif score > 0:
            power += tokens[right]
            right -= 1
            score -= 1
        else:
            break

    return max_score
```

",,
"```python
from itertools import permutations

def largestTimeFromDigits(arr):
    max_time = -1
    for h, i, j, k in permutations(arr):
        hour = h * 10 + i
        minute = j * 10 + k
        time = hour * 60 + minute
        if hour < 24 and minute < 60 and time > max_time:
            max_time = time

    if max_time == -1:
        return """"
    else:
        return ""{:02d}:{:02d}"".format(max_time // 60, max_time % 60)
```

",,
"```python
from collections import deque

def deckRevealedIncreasing(deck):
    n = len(deck)
    index = deque(range(n))
    ans = [0] * n

    deck.sort()
    for card in deck:
        ans[index.popleft()] = card
        if index:
            index.append(index.popleft())

    return ans
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def flipEquiv(root1, root2):
    if not root1 and not root2: return True
    if not root1 or not root2: return False
    if root1.val != root2.val: return False
    return (flipEquiv(root1.left, root2.left) and flipEquiv(root1.right, root2.right)) or \
           (flipEquiv(root1.left, root2.right) and flipEquiv(root1.right, root2.left))
```


",,
"```python
from collections import defaultdict

def largestComponentSize(nums):
    def primes(n):
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return i
        return n

    def dfs(node, visited, graph):
        if node in visited:
            return 0
        visited.add(node)
        size = 1
        for neighbor in graph[node]:
            size += dfs(neighbor, visited, graph)
        return size

    graph = defaultdict(set)
    visited = set()

    for num in nums:
        prime = primes(num)
        graph[prime].add(num)
        if num != prime:
            graph[num].add(prime)

    count = 0
    for num in nums:
        count = max(count, dfs(num, visited, graph))

    return count
```

",,
"```python
def is_alien_sorted(words, order):
    alien_order = {char: i for i, char in enumerate(order)}

    for i in range(1, len(words)):
        for j in range(len(words[i - 1])):
            if j == len(words[i]):
                return False

            if words[i - 1][j] != words[i][j]:
                if alien_order[words[i - 1][j]] > alien_order[words[i][j]]:
                    return False
                break

    return True
```

",,
"```python
def can_reorder_array(arr):
    from collections import Counter
    
    count = Counter(arr)
    arr = sorted(arr)
    for x in arr:
        if count[x] == 0:
            continue
        if count[2 * x] > 0:
            count[x] -= 1
            count[2 * x] -= 1
        else:
            return False
    return True
```

",,
"```python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        m = len(strs[0])
        dp = [1] * m

        for j in range(m):
            for i in range(j):
                flag = all(strs[k][i] <= strs[k][j] for k in range(n - 1))
                dp[j] = max(dp[j], dp[i] + 1) if flag else dp[j]

        return m - max(dp)
```


",,
"```python
def tallestBillboard(rods):
    n = len(rods)
    totalLength = sum(rods)
    dp = [[-1] * (totalLength + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(1, n + 1):
        for j in range(totalLength + 1):
            dp[i][j] = dp[i - 1][j]
            if rods[i - 1] <= j:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1])
            if rods[i - 1] <= totalLength - j:
                dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]])
                
    return dp[n][0] // 2
```


",,
"```python
def prisonAfterNDays(cells, n):
    n = n % 14 if n % 14 != 0 else 14 # Pattern repeats every 14 days

    for _ in range(n):
        temp = [0] * 8
        for i in range(1, 7):
            temp[i] = int(cells[i - 1] == cells[i + 1])
        cells = temp

    return cells
```

",,
"```python
def min_k_bit_flips(nums, k):
    n = len(nums)
    flipped = [0] * n
    flips = ans = 0
    for i in range(n):
        if i >= k:
            flips -= flipped[i - k]
        if (flips + nums[i]) % 2 == 0:
            if i + k > n:
                return -1
            flipped[i] = 1
            flips += 1
            ans += 1
    return ans
```

",,
"```python
from collections import Counter

def numSquarefulPerms(nums):
    def is_square(n):
        return int(n ** 0.5) ** 2 == n

    def dfs(idx):
        if idx == len(nums):
            return 1

        count = 0
        for key in counter.keys():
            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):
                counter[key] -= 1
                nums[idx] = key
                count += dfs(idx + 1)
                counter[key] += 1

        return count

    key_set, counter = set(nums), Counter(nums)
    return dfs(0)
```


",,
"```python
def findJudge(n, trust):
    trust_counts = [0] * (n + 1)
    for a, b in trust:
        trust_counts[a] -= 1
        trust_counts[b] += 1
    for i in range(1, n + 1):
        if trust_counts[i] == n - 1:
            return i
    return -1
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_complete_tree(root: TreeNode) -> bool:
    if not root:
        return True
    
    queue = [root]
    while queue[0]:
        node = queue.pop(0)
        queue.append(node.left)
        queue.append(node.right)
    while queue and not queue[0]:
        queue.pop(0)
    return not queue
```

",,
"```python
def regionsBySlashes(grid):
    n = len(grid)
    graph = [[0] * (n * 3) for _ in range(n * 3)]

    for i in range(n):
        for j in range(n):
            if grid[i][j] == '/':
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1
            if grid[i][j] == '\\':
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1

    regions = 0
    for i in range(n * 3):
        for j in range(n * 3):
            if not graph[i][j]:
                regions += 1
                dfs(graph, i, j)

    return regions

def dfs(graph, i, j):
    n = len(graph)
    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:
        return

    graph[i][j] = 1
    dfs(graph, i - 1, j)
    dfs(graph, i + 1, j)
    dfs(graph, i, j - 1)
    dfs(graph, i, j + 1)
```

",,
"```python
def min_deletion_size(strs):
    rows, cols = len(strs), len(strs[0])
    count = 0
    for c in range(cols):
        for r in range(1, rows):
            if strs[r - 1][c] > strs[r][c]:
                count += 1
                break
    return count
```


",,
"```python
def repeatedNTimes(nums):
    hash_map = {}
    for num in nums:
        if num in hash_map:
            return num
        else:
            hash_map[num] = 1
```


",,
"
```javascript
function maxWidthRamp(nums) {
    const indices = [...Array(nums.length).keys()].sort((i, j) => {
        return nums[i] === nums[j] ? i - j : nums[i] - nums[j];
    });
    
    let maxWidth = 0;
    let minIndex = Infinity;
    for (const index of indices) {
        maxWidth = Math.max(maxWidth, index - minIndex);
        minIndex = Math.min(minIndex, index);
    }
    
    return maxWidth;
}
```


",,
"```python
from collections import defaultdict
from math import sqrt, inf

def minAreaFreeRect(points):
    minArea = inf
    xGroups = defaultdict(set)

    for x, y in points:
        xGroups[x].add(y)

    for x1, ys1 in xGroups.items():
        for x2, ys2 in xGroups.items():
            if x1 == x2:
                continue

            for y1 in ys1:
                for y2 in ys2:
                    if y2 in ys1 and y1 in ys2:
                        area = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) * sqrt((x1 - x2) ** 2 + (y1 - y1) ** 2)
                        minArea = min(minArea, area)

    return minArea if minArea != inf else 0
```


",,
"```python
def least_ops_express_target(x, target):
    if x == target:
        return 0
    if target == 1:
        return 1
    if x > target:
        return min(2 * target - 1, 2 * (x - target))

    k = 0
    p = x
    while p < target:
        k += 1
        p *= x

    ans = float('inf')
    d = 1

    for i in range(k - 1, -1, -1):
        while p >= target + d * (1 - x):
            p -= d
            ans = min(ans, i + int(math.log2(target // d) + 1) + int(d == 1 and -1 or 0))
        d = d * x + 1

    return ans
```


",,
"```python
def is_univalued(root, val=None):
    if not root:
        return True
    if val is None:
        val = root.val
    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)
```

",,
"```python
def spellchecker(wordlist, queries):
    word_map = {word: word for word in wordlist}
    word_map_lower_case = {word.lower(): word for word in wordlist if word.lower() not in word_map_lower_case}
    word_map_vowel_replaced = {replace_vowels(word.lower()): word for word in wordlist if replace_vowels(word.lower()) not in word_map_vowel_replaced}

    result = []
    for query in queries:
        lower_query = query.lower()
        vowel_replaced_query = replace_vowels(lower_query)

        if query in word_map:
            result.append(word_map[query])
        elif lower_query in word_map_lower_case:
            result.append(word_map_lower_case[lower_query])
        elif vowel_replaced_query in word_map_vowel_replaced:
            result.append(word_map_vowel_replaced[vowel_replaced_query])
        else:
            result.append("""")

    return result


def replace_vowels(word):
    return ''.join(['#' if ch in 'aeiou' else ch for ch in word])
```


",,
"```python
def numsSameConsecDiff(n, k):
    result = []
    if n == 1: result.append(0)

    def dfs(current):
        if len(current) == n:
            result.append(int(current))
            return

        last_digit = current[-1]
        if last_digit - k >= 0: dfs(current + str(last_digit - k))
        if k != 0 and last_digit + k <= 9: dfs(current + str(last_digit + k))

    for i in range(1, 10):
        dfs(str(i))

    return result
```

",,
"```python
def min_camera_cover(root):
    ans = [0]
    return (dfs(root, ans) < 1) + ans[0]

def dfs(node, ans):
    if not node:
        return 2
    left = dfs(node.left, ans)
    right = dfs(node.right, ans)
    if left == 0 or right == 0:
        ans[0] += 1
        return 1
    return 2 if left == 1 or right == 1 else 0
```


",,
"```python
def pancakeSort(arr):
    flips = []
    for size in range(len(arr), 1, -1):
        maxIdx = arr.index(max(arr[:size]))
        flips.extend([maxIdx + 1, size])
        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])
        arr[:size] = reversed(arr[:size])
    return flips
```

",,
"```python
def powerful_integers(x, y, bound):
    result = set()
    for i in range(20):
        for j in range(20):
            val = x**i + y**j
            if val <= bound:
                result.add(val)
    return list(result)
```


",,
"```python
def flipRecur(node, voyage, flipped, idx):
    if not node:
        return idx
    if node.val != voyage[idx]:
        flipped[0] = -1
        return idx
    idx += 1
    if (idx < len(voyage) and node.left and
            node.left.val != voyage[idx]):
        flipped.append(node.val)
        idx = flipRecur(node.right, voyage, flipped, idx)
        idx = flipRecur(node.left, voyage, flipped, idx)
    else:
        idx = flipRecur(node.left, voyage, flipped, idx)
        idx = flipRecur(node.right, voyage, flipped, idx)
    return idx


def flipMatchVoyage(root, voyage):
    flipped = []
    flipRecur(root, voyage, flipped, 0)
    if flipped and flipped[0] == -1:
        return [-1]
    return flipped
```


",,
"```python
def isRationalEqual(s: str, t: str) -> bool:
    def evaluate(s: str) -> float:
        i = s.find('(')
        if i != -1:
            base = s[:i]
            rep = s[i + 1:-1]
            return float(base + rep * 20)
        return float(s)

    return abs(evaluate(s) - evaluate(t)) < 1e-12
```

",,
"```python
def fib(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
```

",,
"```python
def kClosest(points, k):
    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)
    return points[:k]
```

",,
"```python
def smallestRepunitDivByK(k: int) -> int:
    if k % 2 == 0 or k % 5 == 0:
        return -1
    n = 0
    for i in range(1, k + 1):
        n = (n * 10 + 1) % k
        if n == 0:
            return i
    return -1
```

",,
"```python
def subarraysDivByK(nums, k):
    counts = {0: 1}
    sum_, result = 0, 0
    
    for num in nums:
        sum_ += num
        mod = (sum_ % k + k) % k
        result += counts.get(mod, 0)
        counts[mod] = counts.get(mod, 0) + 1
    
    return result
```

",,
"```python
def odd_even_jumps(arr):
    n = len(arr)
    can_reach_odd = [False] * n
    can_reach_even = [False] * n
    can_reach_odd[-1] = can_reach_even[-1] = True

    index_map = {}
    index_map[arr[-1]] = n - 1

    good_indices = 1
    for i in range(n - 2, -1, -1):
        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)
        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)

        if odd_jump is not None:
            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]
        if even_jump is not None:
            can_reach_even[i] = can_reach_odd[index_map[even_jump]]

        if can_reach_odd[i]:
            good_indices += 1

        index_map[arr[i]] = i

    return good_indices
```

",,
"```python
def largestPerimeter(nums):
    nums.sort(reverse=True)

    for i in range(len(nums) - 2):
        if nums[i] < nums[i + 1] + nums[i + 2]:
            return nums[i] + nums[i + 1] + nums[i + 2]

    return 0
```

",,
"```python
def sortedSquares(nums):
    return sorted([x ** 2 for x in nums])
```

",,
"```python
def maxTurbulenceSize(arr):
    n = len(arr)
    result = 1
    i = 0

    while i < n - 1:
        if arr[i] == arr[i + 1]:
            i += 1
            continue

        j = i + 1
        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):
            j += 1
        
        result = max(result, j - i + 1)
        i = j

    return result
```


",,
"```python
def distributeCoins(root):
    def dfs(node):
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        moves[0] += abs(left) + abs(right)
        return node.val + left + right - 1

    moves = [0]
    dfs(root)
    return moves[0]
```

",,
"```python
def uniquePathsIII(grid):
    x, y, empty = 0, 0, 1
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                x, y = i, j
            elif grid[i][j] == 0:
                empty += 1
    return dfs(grid, x, y, empty)

def dfs(grid, x, y, empty):
    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:
        return 0
    if grid[x][y] == 2:
        return 1 if empty == -1 else 0
    grid[x][y] = -1
    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)
    grid[x][y] = 0
    return paths
```

",,
"```python
from collections import defaultdict
import bisect

class TimeMap:

    def __init__(self):
        self.data = defaultdict(list)

    def set(self, key, value, timestamp):
        self.data[key].append((timestamp, value))

    def get(self, key, timestamp):
        if key not in self.data: return """"
        index = bisect.bisect(self.data[key], (timestamp + 1,))
        return self.data[key][index-1][1] if index else """"
```

",,
"```python
def count_and_triples(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            for k in range(j + 1, len(nums)):
                if nums[i] & nums[j] & nums[k] != 0:
                    count += 1
    return count
```

",,
"```python
def mincostTickets(days, costs):
  travel_days = set(days)
  dp = [0] * 366

  for i in range(1, 366):
    if i not in travel_days:
      dp[i] = dp[i - 1]
    else:
      dp[i] = min(dp[i - 1] + costs[0],
                  dp[max(0, i - 7)] + costs[1],
                  dp[max(0, i - 30)] + costs[2])

  return dp[365]
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxAncestorDiff(root: TreeNode) -> int:
    def helper(node, mn, mx):
        if node is None:
            return mx - mn

        mx = max(mx, node.val)
        mn = min(mn, node.val)

        left_diff = helper(node.left, mn, mx)
        right_diff = helper(node.right, mn, mx)

        return max(left_diff, right_diff)

    return helper(root, root.val, root.val)
```

",,
"```python
def sumEvenAfterQueries(nums, queries):
    answer = []
    even_sum = sum(num for num in nums if num % 2 == 0)

    for value, index in queries:
        if nums[index] % 2 == 0:
            even_sum -= nums[index]
        nums[index] += value
        if nums[index] % 2 == 0:
            even_sum += nums[index]
        answer.append(even_sum)

    return answer
```


",,
"```python
def interval_intersection(firstList, secondList):
    result = []
    i, j = 0, 0

    while i < len(firstList) and j < len(secondList):
        start = max(firstList[i][0], secondList[j][0])
        end = min(firstList[i][1], secondList[j][1])

        if start <= end:
            result.append([start, end])

        if firstList[i][1] < secondList[j][1]:
            i += 1
        else:
            j += 1

    return result
```

",,
"```python
from collections import defaultdict, deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def verticalTraversal(root):
    if not root:
        return []

    columns = defaultdict(lambda: defaultdict(list))
    q = deque([(root, 0, 0)])

    while q:
        node, row, col = q.popleft()
        columns[col][row].append(node.val)
        columns[col][row].sort()

        if node.left:
            q.append((node.left, row + 1, col - 1))
        if node.right:
            q.append((node.right, row + 1, col + 1))

    return [[val for row in column_data.values() for val in row] for column_data in sorted(columns.values())]
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def smallestFromLeaf(self, root: TreeNode) -> str:
        if not root:
            return ""|""
        s = chr(root.val + 97)
        if not root.left and not root.right:
            return s
        left = self.smallestFromLeaf(root.left)
        right = self.smallestFromLeaf(root.right)
        return min(left, right) + s
```

",,
"```python
def add_to_array_form(num, k):
    for i in range(len(num) - 1, -1, -1):
        k, num[i] = divmod(num[i] + k, 10)
        if k == 0:
            break
    while k:
        k, digit = divmod(k, 10)
        num.insert(0, digit)
    return num
```


",,
"```python
def equationsPossible(equations):
    parent = [i for i in range(26)]

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    for e in equations:
        if e[1] == '=':
            x = ord(e[0]) - ord('a')
            y = ord(e[3]) - ord('a')
            parent[find(x)] = find(y)

    for e in equations:
        if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):
            return False

    return True
```


",,
"```python
def broken_calc(startValue: int, target: int) -> int:
    operations = 0
    while target > startValue:
        target = target // 2 if target % 2 == 0 else target + 1
        operations += 1
    return operations + startValue - target
```

",,
"```python
def good_subarrays(nums, k):
    count = 0
    for i in range(len(nums)):
        frequency = {}
        for j in range(i, len(nums)):
            frequency[nums[j]] = frequency.get(nums[j], 0) + 1
            if len(frequency) > k:
                break
            if len(frequency) == k:
                count += 1
    return count
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isCousins(self, root, x, y):
        def findDepth(node, search_val, depth):
            if not node:
                return -1
            if node.val == search_val:
                return depth
            left_depth = findDepth(node.left, search_val, depth + 1)
            if left_depth != -1:
                return left_depth
            return findDepth(node.right, search_val, depth + 1)

        def findParent(node, search_val):
            if not node or not (node.left or node.right):
                return None
            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):
                return node
            left_parent = findParent(node.left, search_val)
            if left_parent:
                return left_parent
            return findParent(node.right, search_val)

        x_depth = findDepth(root, x, 0)
        y_depth = findDepth(root, y, 0)
        x_parent = findParent(root, x)
        y_parent = findParent(root, y)
        return (x_depth == y_depth) and (x_parent != y_parent)
```

",,
"```python
from collections import deque

def orangesRotting(grid):
    m, n = len(grid), len(grid[0])
    fresh_oranges = sum(row.count(1) for row in grid)
    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])
    
    minutes = 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while rotten and fresh_oranges:
        for _ in range(len(rotten)):
            x, y = rotten.popleft()

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                    grid[nx][ny] = 2
                    fresh_oranges -= 1
                    rotten.append((nx, ny))
        minutes += 1

    return minutes if fresh_oranges == 0 else -1
```


",,
"```python
def min_k_bit_flips(nums, k):
    n, res, flipped = len(nums), 0, 0
    change = [0] * n
    for i in range(n - k + 1):
        flipped ^= change[i]
        if nums[i] == flipped:
            res += 1
            flipped ^= 1
            if i + k < n:
                change[i + k] ^= 1
    for i in range(n - k + 1, n):
        flipped ^= change[i]
        if nums[i] == flipped:
            return -1
    return res
```


",,
"```python
from math import sqrt
from itertools import permutations

def is_squareful(x, int_y):
    s = int(sqrt(x + y))
    return s * s == x + y

def squareful_perms(nums):
    count = 0
    for p in permutations(nums):
        if all(is_squareful(p[i], p[i + 1]) for i in range(len(p) - 1)):
            count += 1
    return count
```


",,
"```python
def find_judge(n, trust):
    trustCounts = [0] * (n + 1)
    for a, b in trust:
        trustCounts[a] -= 1
        trustCounts[b] += 1

    for i in range(1, n + 1):
        if trustCounts[i] == n - 1:
            return i
    return -1
```

",,
"```python
def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
    if root is None or val > root.val:
        newNode = TreeNode(val)
        newNode.left = root
        return newNode
    root.right = self.insertIntoMaxTree(root.right, val)
    return root
```


",,
"```python
def numRookCaptures(board):
    x, y, captures = 0, 0, 0

    for i in range(8):
        for j in range(8):
            if board[i][j] == 'R':
                x, y = i, j
                break
        if board[x][y] == 'R':
            break

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        while 0 <= nx < 8 and 0 <= ny < 8:
            if board[nx][ny] == 'p':
                captures += 1
                break
            elif board[nx][ny] == 'B':
                break
            nx += dx
            ny += dy

    return captures
```


",,
"```python
def mergeStones(stones, k):
    n = len(stones)
    if (n - 1) % (k - 1) != 0:
        return -1
    prefixSum = [0] * (n + 1)
    dp = [[[-1] * (k + 1) for _ in range(n)] for _ in range(n)]

    for i in range(n):
        prefixSum[i + 1] = prefixSum[i] + stones[i]

    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            for m in range(2, k + 1):
                for p in range(i, j + 1 - m + 1, k - 1):
                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7)
            if (j - i) % (k - 1) == 0:
                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7)

    return dp[0][n - 1][1]
```

",,
"```python
def grid_illumination(n, lamps, queries):
    lamp_rows = set()
    lamp_cols = set()
    lamp_left_diag = set()
    lamp_right_diag = set()

    for lamp in lamps:
        row, col = lamp
        lamp_rows.add(row)
        lamp_cols.add(col)
        lamp_left_diag.add(row - col)
        lamp_right_diag.add(row + col)

    ans = []

    for query in queries:
        row, col = query
        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:
            ans.append(1)
        else:
            ans.append(0)
        for i in range(-1, 2):
            for j in range(-1, 2):
                newRow, newCol = row + i, col + j
                lamp_rows.discard(newRow)
                lamp_cols.discard(newCol)
                lamp_left_diag.discard(newRow - newCol)
                lamp_right_diag.discard(newRow + newCol)

    return ans
```


",,
"```python
from collections import Counter

def commonChars(words):
    merged = Counter()
    for word in words:
        word_count = Counter(word)
        if not merged:
            merged = word_count
        else:
            for char in merged:
                merged[char] = min(merged[char], word_count[char])

    result = []
    for char, count in merged.items():
        result.extend([char] * count)
    return result
```

",,
"```python
def longestOnes(nums, k):
    left, right, max_ones, zero_count = 0, 0, 0, 0
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_ones = max(max_ones, right - left + 1)
        right += 1
    return max_ones
```


",,
"```python
import heapq

def maxSumAfterKOperations(nums, k):
    heapq.heapify(nums)
    for _ in range(k):
        current = heapq.heappop(nums)
        heapq.heappush(nums, -current)
    return sum(nums)
```

",,
"```python
def clumsy(n: int) -> int:
    if n <= 2:
        return n
    if n == 3:
        return 6
    result = n * (n - 1) // (n - 2) + (n - 3)
    n -= 4
    while n >= 4:
        result = result - (n * (n - 1) // (n - 2)) + (n - 3)
        n -= 4
    return result - clumsy(n)
```


",,
"```python
def min_rotations(tops, bottoms):
    res = float('inf')

    for target in (tops[0], bottoms[0]):
        top_rot, bot_rot = 0, 0
        for ti, bi in zip(tops, bottoms):
            if ti != target and bi != target:
                top_rot = bot_rot = float('inf')
                break
            top_rot += ti != target
            bot_rot += bi != target

        res = min(res, top_rot, bot_rot)

    return -1 if res == float('inf') else res
```

",,
"```python
def height_checker(heights):
    expected = sorted(heights)
    
    count = 0
    for i in range(len(heights)):
        if heights[i] != expected[i]:
            count += 1
            
    return count
```

",,
"```python
def maxSatisfied(customers, grumpy, minutes):
    total_customers = 0
    max_extra_customers = 0
    extra_customers = 0
    for i in range(len(customers)):
        if grumpy[i] == 0:
            total_customers += customers[i]
        if i < minutes:
            extra_customers += customers[i] * grumpy[i]
        else:
            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])
        max_extra_customers = max(max_extra_customers, extra_customers)
    return total_customers + max_extra_customers
```


",,
"```python
def prevPermOpt1(arr):
    n = len(arr)
    for i in range(n - 2, -1, -1):
        if arr[i] > arr[i + 1]:
            j = i + 1
            while j < n and arr[j] < arr[i]:
                j += 1
            arr[i], arr[j - 1] = arr[j - 1], arr[i]
            break
    return arr
```


",,
"```python
def bitwise_complement(n):
    x = 1
    while n > x:
        x = x * 2 + 1
    return x - n
```

",,
"```python
def num_pairs_divisible_by60(time):
    count = [0] * 60
    pairs = 0

    for t in time:
        mod = t % 60
        pairs += count[(60 - mod) % 60]
        count[mod] += 1

    return pairs
```

",,
"
```javascript
function shipWithinDays(weights, days) {
    let left = Math.max(...weights), right = weights.reduce((a, b) => a + b, 0);
    while (left < right) {
        let mid = left + ((right - left) / 2) | 0;
        let day_count = 1, curr_capacity = 0;
        for (const w of weights) {
            curr_capacity += w;
            if (curr_capacity > mid) {
                day_count++;
                curr_capacity = w;
            }
        }
        if (day_count > days) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

",,
"```python
def num_dup_digits_at_most_n(n):
    count = 0
    for i in range(1, n + 1):
        digits = set()
        num = i
        while num != 0:
            digit = num % 10
            if digit in digits:
                count += 1
                break
            else:
                digits.add(digit)
            num //= 10
    return count
```

",,
"```python
from math import floor, ceil

def find_rounding_error(prices, target):
    n = len(prices)
    decimals = [float(price) - floor(float(price)) for price in prices]
    rounded_sum = sum(floor(float(price)) for price in prices)

    if target < rounded_sum or target > rounded_sum + n:
        return ""-1 ""

    ceil_count = target - rounded_sum
    rounding_error = 0.0

    for d in decimals:
        if ceil_count > 0:
            rounding_error += 1 - d
            ceil_count -= 1
        else:
            rounding_error += d

    return f""{rounding_error:.3f} ""
```


",,
"```python
from collections import defaultdict

def leadsToDestination(n, edges, source, destination):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)

    visited = [0] * n
    return dfs(source, graph, visited, destination)

def dfs(node, graph, visited, destination):
    if node not in graph:
        return node == destination
    if visited[node] != 0:
        return visited[node] == 2

    visited[node] = 1
    for neighbor in graph[node]:
        if not dfs(neighbor, graph, visited, destination):
            return False

    visited[node] = 2
    return True
```

",,
"```python
def findKthPositive(nums, k):
    left, right = 0, len(nums)
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] - mid - 1 < k:
            left = mid + 1
        else:
            right = mid
    return left + k
```

",,
"```python
def lex_smallest_equivalent(s1, s2, base_str):
    parent = {chr(ch): chr(ch) for ch in range(ord('a'), ord('z') + 1)}

    for c1, c2 in zip(s1, s2):
        root1, root2 = c1, c2
        while parent[root1] != root1:
            root1 = parent[root1]
        while parent[root2] != root2:
            root2 = parent[root2]
        if root1 != root2:
            min_root = min(root1, root2)
            parent[root1] = min_root
            parent[root2] = min_root

    return ''.join(parent[ch] for ch in base_str)
```

",,
"```python
def find_longest_repeating_substring(s: str) -> int:
    n = len(s)
    max_substr_length = 0
    for length in range(1, n // 2 + 1):
        max_repeat_count = repeat_count = 0
        for i in range(n - length):
            if s[i:i + length] == s[i + length:i + 2 * length]:
                repeat_count += 1
            else:
                max_repeat_count = max(max_repeat_count, repeat_count)
                repeat_count = 0
        max_substr_length = max(max_substr_length, max_repeat_count * length)
    return max_substr_length
```

",,
"```python
def maxScoreSightseeingPair(values):
    max_score = 0
    max_score_left = values[0] + 0
    for j in range(1, len(values)):
        max_score = max(max_score, max_score_left + values[j] - j)
        max_score_left = max(max_score_left, values[j] + j)
    return max_score
```

",,
"```python
def fixedPoint(arr: List[int]) -> int:
    left, right = 0, len(arr) - 1
    while left < right:
        middle = left + (right - left) // 2
        if arr[middle] < middle:
            left = middle + 1
        else:
            right = middle
    return left if arr[left] == left else -1
```

",,
"```python
def has_all_codes_in_range(s: str, n: int) -> bool:
    substrings = set()
    length = len(bin(n)) - 2
    for i in range(len(s) - length + 1):
        substrings.add(s[i:i + length])
    return len(substrings) == n
```


",,
"```python
from typing import List

def manhattan_distance(worker: List[int], bike: List[int]) -> int:
    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1])

def dfs(workers: List[List[int]], bikes: List[List[int]], used: List[bool], index: int, dist: int, min_dist: List[int]) -> None:
    if index == len(workers):
        min_dist[0] = min(min_dist[0], dist)
        return

    if dist >= min_dist[0]:
        return

    for i in range(len(bikes)):
        if used[i]:
            continue
        used[i] = True
        cur_dist = manhattan_distance(workers[index], bikes[i])
        dfs(workers, bikes, used, index + 1, dist + cur_dist, min_dist)
        used[i] = False

def assign_bikes(workers: List[List[int]], bikes: List[List[int]]) -> int:
    min_dist = [float('inf')]
    used = [False] * len(bikes)
    dfs(workers, bikes, used, 0, 0, min_dist)
    return min_dist[0]
```

",,
"```python
def count_digit(d, low, high):
    count = 0
    for i in range(low, high + 1):
        num = i
        while num > 0:
            if num % 10 == d:
                count += 1
            num //= 10
    return count
```

",,
"```python
def prefixesDivBy5(nums):
    result = []
    current = 0
    for num in nums:
        current = ((current << 1) | num) % 5
        result.append(current == 0)
    return result
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def nextGreaterNodes(head):
    result = []
    stack = []
    while head:
        while stack and stack[-1] < head.val:
            stack[-1] = head.val
            stack.pop()
        result.append(head.val)
        stack.append(len(result) - 1)
        head = head.next

    while stack:
        result[stack.pop()] = 0

    return result
```

",,
"```python
from collections import deque

def addNegabinary(arr1, arr2):
    res = deque()
    carry, i, j = 0, len(arr1) - 1, len(arr2) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0: carry += arr1[i]; i -= 1
        if j >= 0: carry += arr2[j]; j -= 1
        res.appendleft(carry & 1)
        carry = -(carry >> 1)
    while len(res) > 1 and res[0] == 0: res.popleft()
    return list(res)
```


",,
"```python
def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:
    rows, cols = len(matrix), len(matrix[0])
    for row in range(rows):
        for col in range(1, cols):
            matrix[row][col] += matrix[row][col-1]
    
    count = 0
    for col1 in range(cols):
        for col2 in range(col1, cols):
            counter = collections.defaultdict(int)
            counter[0] = 1
            cur_sum = 0
            for row in range(rows):
                cur_sum += matrix[row][col2] - (matrix[row][col1-1] if col1 > 0 else 0)
                count += counter[cur_sum - target]
                counter[cur_sum] += 1

    return count
```

",,
"```python
def remove_outer_parentheses(s: str) -> str:
    result = []
    opened = 0

    for c in s:
        if c == '(':
            if opened > 0:
                result.append(c)
            opened += 1
        elif c == ')':
            if opened > 1:
                result.append(c)
            opened -= 1

    return ''.join(result)
```


",,
"```python
def sumRootToLeaf(root, path_value=0):
    if not root:
        return 0
    path_value = path_value * 2 + root.val
    if not root.left and not root.right:
        return path_value
    return sumRootToLeaf(root.left, path_value) + sumRootToLeaf(root.right, path_value)
```

",,
"```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        if not root:
            return None
        if not root.left and not root.right:
            if root.val < limit:
                return None
            return root
        root.left = self.sufficientSubset(root.left, limit - root.val)
        root.right = self.sufficientSubset(root.right, limit - root.val)
        if not root.left and not root.right:
            return None

        return root
```


",,
"```python
def videoStitching(clips, time):
    dp = [float('inf')] * (time + 1)
    dp[0] = 0
    for i in range(1, time + 1):
        for clip in clips:
            if clip[0] < i and i <= clip[1]:
                dp[i] = min(dp[i], dp[clip[0]] + 1)
    return -1 if dp[time] == float('inf') else dp[time]
```

",,
"```python
def sum_of_digits(nums):
    min_val = min(nums)
    digit_sum = sum(int(digit) for digit in str(min_val))
    return 1 if digit_sum % 2 == 0 else 0
```


",,
"```python
def alice_win(n):
    return n % 2 == 0
```


",,
"```python
def longestArithSeqLength(nums):
    n = len(nums)
    longest = 0
    dp = [{} for _ in range(n)]
    
    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[i][diff] = dp[j].get(diff, 1) + 1
            longest = max(longest, dp[i][diff])
    
    return longest
```

",,
"```python
def confusingNumberII(n):
    def helper(current):
        nonlocal count, validNums
        for num in validNums:
            next_num = current * 10 + num
            if next_num > n:
                break
            if current != 0 or next_num != 0:
                if next_num != rotate(next_num):
                    count += 1
                count = helper(next_num)
        return count

    def rotate(num):
        rotated = 0
        original = num
        while num > 0:
            digit = num % 10
            if digit in (2, 3, 4, 5, 7):
                return original
            revd = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}
            rotated = rotated * 10 + revd[digit]
            num //= 10
        return rotated

    count = 0
    validNums = [0, 1, 6, 8, 9]
    return helper(0)
```

",,
"```python
def duplicateZeros(arr):
    n = len(arr)
    i = 0
    while i < n - 1:
        if arr[i] == 0:
            for j in range(n - 1, i + 1, -1):
                arr[j] = arr[j - 1]
            arr[i + 1] = 0
            i += 1
        i += 1
```

",,
"```python
from typing import List

def largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:
    items = list(zip(values, labels))
    items.sort(key=lambda x: x[0], reverse=True)

    label_count = {}
    ans = 0

    for value, label in items:
        if label not in label_count:
            label_count[label] = 0
        if label_count[label] < useLimit:
            ans += value
            label_count[label] += 1
            numWanted -= 1
            if numWanted == 0:
                break

    return ans
```


",,
"```python
from collections import deque

def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] or grid[n - 1][n - 1]: return -1

    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    q = deque([(0, 0)])
    grid[0][0] = 1

    pathLength = 1

    while q:
        qlen = len(q)
        for _ in range(qlen):
            x, y = q.popleft()

            if x == n - 1 and y == n - 1: return pathLength

            for d in dir:
                newX, newY = x + d[0], y + d[1]

                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    q.append((newX, newY))
                    grid[newX][newY] = 1
        pathLength += 1

    return -1
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def dfs(node):
    if not node:
        return 0, float('inf'), float('-inf')
    left_diff, left_min, left_max = dfs(node.left)
    right_diff, right_min, right_max = dfs(node.right)
    mn = min(node.val, left_min, right_min)
    mx = max(node.val, left_max, right_max)
    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx

def maxAncestorDiff(root):
    diff, _, _ = dfs(root)
    return diff
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def recoverFromPreorder(S: str) -> TreeNode:
    def helper() -> TreeNode:
        nonlocal depth, index
        num_dashes = 0
        while index < len(S) and S[index] == '-':
            num_dashes += 1
            index += 1
        if num_dashes != depth:
            index -= num_dashes
            return None
        val = 0
        while index < len(S) and S[index].isdigit():
            val = val * 10 + int(S[index])
            index += 1
        node = TreeNode(val)
        depth += 1
        node.left = helper()
        node.right = helper()
        depth -= 1
        return node

    depth, index = 0, 0
    return helper()
```

",,
"```python
def allCellsDistOrder(rows, cols, rCenter, cCenter):
    coordinates = [[i, j] for i in range(rows) for j in range(cols)]

    coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))

    return coordinates
```

",,
"```python
def twoCitySchedCost(costs):
    costs.sort(key=lambda x: x[0] - x[1])

    totalCost = 0
    n = len(costs) // 2

    for i in range(n):
        totalCost += costs[i][0] + costs[i + n][1]

    return totalCost
```

",,
"```python
class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        def parse(expr: str, i: int) -> Set[str]:
            result, current = set(), {""""}
            while i < len(expr):
                if expr[i] == '{':
                    update = set()
                    for postfix in parse(expr, i + 1):
                        for prefix in current:
                            update.add(prefix + postfix)
                    current = update
                    i = expr.index('}', i)
                elif expr[i] == '}':
                    break
                elif expr[i] == ',':
                    result |= current
                    current = {""""}
                else:
                    current = {s + expr[i] for s in current}
                i += 1
            return result | current
        
        return sorted(parse(expression, 0))
```

",,
"```python
def max_sum_under_k(nums, k):
    max_sum = -1
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            _sum = nums[i] + nums[j]
            if _sum < k and _sum > max_sum:
                max_sum = _sum
    return max_sum
```

",,
"```python
def num_k_len_substr_no_repeats(s: str, k: int) -> int:
    n = len(s)
    if k > n:
        return 0

    result = 0
    window = set()

    i = 0
    for j in range(n):
        while s[j] in window:
            window.remove(s[i])
            i += 1
        window.add(s[j])
        if j - i + 1 == k:
            result += 1
            window.remove(s[i])
            i += 1

    return result
```

",,
"```python
def earliestAcq(logs, n):
    def find(x):
        if x != parents[x]:
            parents[x] = find(parents[x])
        return parents[x]

    parents = list(range(n))
    logs.sort()

    group_count = n
    for timestamp, x, y in logs:
        root_x, root_y = find(x), find(y)
        if root_x != root_y:
            parents[root_x] = root_y
            group_count -= 1
        if group_count == 1:
            return timestamp
    return -1
```

",,
"```python
def maxScore(grid):
    m, n = len(grid), len(grid[0])

    for i in range(1, n):
        grid[0][i] = min(grid[0][i], grid[0][i - 1])

    for i in range(1, m):
        grid[i][0] = min(grid[i][0], grid[i - 1][0])

        for j in range(1, n):
            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]))

    return grid[m - 1][n - 1]
```



",,
"```python
def distribute_candies(candies, num_people):
    result = [0] * num_people
    i = 0
    count = 1

    while candies > 0:
        result[i % num_people] += min(candies, count)
        candies -= count
        count += 1
        i += 1

    return result
```


",,
"```python
def colorBorder(grid, row, col, color):
    def dfs(grid, row, col, current, color):
        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:
            return

        grid[row][col] = color
        dfs(grid, row - 1, col, current, color)
        dfs(grid, row + 1, col, current, color)
        dfs(grid, row, col - 1, current, color)
        dfs(grid, row, col + 1, current, color)

    current = grid[row][col]
    if current == color:
        return grid

    dfs(grid, row, col, current, color + 1000)

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] > 1000:
                grid[i][j] -= 1000

    return grid
```

",,
"```python
def max_uncrossed_lines(nums1, nums2):
    m, n = len(nums1), len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if nums1[i - 1] == nums2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```


",,
"```python
MAX_STEPS = 200

def isEscapePossible(blocked, source, target):
    blockedSet = set([""{}_{}"".format(block[0], block[1]) for block in blocked])
    visited = set()

    def dfs(x, y, tx, ty, steps):
        pos = ""{}_{}"".format(x, y)
        if x < 0 or x >= 1000000 or y < 0 or y >= 1000000 or steps >= MAX_STEPS or pos in blockedSet or pos in visited:
            return False

        if x == tx and y == ty:
            return True

        visited.add(pos)

        return (dfs(x + 1, y, tx, ty, steps + 1) or dfs(x, y + 1, tx, ty, steps + 1)
                or dfs(x - 1, y, tx, ty, steps + 1) or dfs(x, y - 1, tx, ty, steps + 1))

    return dfs(source[0], source[1], target[0], target[1], 0)
```


",,
"```python
def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')
```

",,
"```python
def corpFlightBookings(bookings, n):
    seats = [0] * n
    for booking in bookings:
        seats[booking[0] - 1] += booking[2]
        if booking[1] < n:
            seats[booking[1]] -= booking[2]
    for i in range(1, n):
        seats[i] += seats[i - 1]
    return seats
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def delNodes(root: TreeNode, to_delete):
    to_delete_set = set(to_delete)
    remaining_trees = []

    def removeNodes(node):
        if node is None:
            return None
        node.left = removeNodes(node.left)
        node.right = removeNodes(node.right)
        if node.val in to_delete_set:
            if node.left:
                remaining_trees.append(node.left)
            if node.right:
                remaining_trees.append(node.right)
            return None
        return node

    if removeNodes(root):
        remaining_trees.append(root)
    return remaining_trees
```


",,
"```python
def minScoreTriangulation(values):
    n = len(values)
    dp = [[0] * n for _ in range(n)]

    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            for k in range(i + 1, j):
                dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j])

    return dp[0][n - 1]
```


",,
"```python
def number_of_days(year, month):
    if month == 2:
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return 29
        return 28
    if month in [4, 6, 9, 11]:
        return 30
    return 31
```

",,
"```python
def is_robot_bounded(instructions: str) -> bool:
    x, y, dir = 0, 0, 0
    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for c in instructions:
        if c == 'G':
            x += moves[dir][0]
            y += moves[dir][1]
        elif c == 'L':
            dir = (dir + 3) % 4
        else:
            dir = (dir + 1) % 4

    return (x == 0 and y == 0) or dir != 0
```

",,
"```python
from collections import defaultdict

def gardenNoAdj(n, paths):
    graph = defaultdict(set)
    for x, y in paths:
        graph[x - 1].add(y - 1)
        graph[y - 1].add(x - 1)
    
    result = [0] * n
    for i in range(n):
        used_flowers = {result[neighbor] for neighbor in graph[i]}
        for flower in range(1, 5):
            if flower not in used_flowers:
                result[i] = flower
                break
    return result
```


",,
"```python
def maxSumAfterPartitioning(arr: list, k: int) -> int:
    n = len(arr)
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        current_max = 0
        for j in range(1, k + 1):
            if i - j < 0:
                break
            current_max = max(current_max, arr[i - j])
            dp[i] = max(dp[i], dp[i - j] + current_max * j)
    return dp[n]
```

",,
"```python
def longest_dup_substring(s):
    n = len(s)
    longest_duplicate = """"
    for length in range(n - 1, 0, -1):
        for i in range(n - length + 1):
            substring = s[i:i + length]
            if s.find(substring, i + 1) != -1:
                longest_duplicate = substring
                return longest_duplicate
    return longest_duplicate
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_lca_util(root):
    if root is None:
        return None, 0

    left_lca, left_depth = find_lca_util(root.left)
    right_lca, right_depth = find_lca_util(root.right)

    if left_depth > right_depth:
        return left_lca, left_depth + 1
    elif left_depth < right_depth:
        return right_lca, right_depth + 1
    else:
        return root, left_depth + 1

def lca_deepest_leaves(root):
    return find_lca_util(root)[0]
```


",,
"```python
def longestWellPerformingInterval(hours):
    sum = 0
    longest = 0
    first_sum_index = {}

    for i, hour in enumerate(hours):
        sum += 1 if hour > 8 else -1
        if sum > 0:
            longest = i + 1
        else:
            if sum - 1 in first_sum_index:
                longest = max(longest, i - first_sum_index[sum - 1])
            if sum not in first_sum_index:
                first_sum_index[sum] = i

    return longest
```


",,
"```python
from collections import defaultdict
from math import log2

def smallestSufficientTeam(req_skills, people):
    skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)}

    n, m = len(people), len(req_skills)
    dp = [float(""inf"")] * (1 << m)
    pre = [0] * (1 << m)
    skill_set = [0] * (1 << m)

    dp[0] = 0

    for i, skills in enumerate(people):
        skill_mask = sum(1 << skill_to_id[skill] for skill in skills)
        for j in range((1 << m) - 1, -1, -1):
            if dp[j | skill_mask] > dp[j] + 1:
                dp[j | skill_mask] = dp[j] + 1
                pre[j | skill_mask] = j
                skill_set[j | skill_mask] = i

    res = []
    mask = (1 << m) - 1
    while mask:
        res.append(skill_set[mask])
        mask = pre[mask]

    return res
```


",,
"```python
def remove_duplicates(s: str) -> str:
    stack = []
    for c in s:
        if stack and stack[-1] == c:
            stack.pop()
        else:
            stack.append(c)
    return """".join(stack)
```

",,
"```python
def longestStrChain(words):
    words.sort(key=lambda x: len(x))
    dp = {}

    max_len = 0
    for word in words:
        for i in range(len(word)):
            pre = word[:i] + word[i + 1:]
            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)
        max_len = max(max_len, dp[word])

    return max_len
```

",,
"```python
import heapq

def lastStoneWeight(stones):
    stones = [-stone for stone in stones]
    heapq.heapify(stones)
    while len(stones) > 1:
        y = -heapq.heappop(stones)
        x = -heapq.heappop(stones)
        if x != y:
            heapq.heappush(stones, -(y - x))
    return -stones[0] if stones else 0
```

",,
"```python
def maxAbsValExpr(arr1, arr2):
    result = 0
    max_sum = [float('-inf')] * 4

    for i in range(len(arr1)):
        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)
        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)
        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)
        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)

    for i in range(len(arr1)):
        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)
        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)
        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)
        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)

    return result
```

",,
"```python
def last_substring(s: str) -> str:
    i, j, k, n = 0, 1, 0, len(s)
    while j + k < n:
        if s[i + k] == s[j + k]:
            k += 1
        elif s[i + k] < s[j + k]:
            i = j
            j += 1
            k = 0
        else:
            j += 1
            k = 0
    return s[i:]
```

",,
"```python
def is_armstrong(n: int) -> bool:
    power_sum = 0
    original = n
    k = len(str(n))
    while n > 0:
        digit = n % 10
        power_sum += digit ** k
        n //= 10
    return power_sum == original
```

",,
"```python
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def minimumCost(n, connections):
    connections.sort(key=lambda x: x[2])

    parent = list(range(n + 1))

    cost = 0
    edges = 0
    for c in connections:
        root_x = find(parent, c[0])
        root_y = find(parent, c[1])

        if root_x != root_y:
            parent[root_y] = root_x
            cost += c[2]
            edges += 1

        if edges == n - 1:
            break

    return cost if edges == n - 1 else -1
```

",,
"```python
def minimum_semesters(n: int, relations: List[List[int]]) -> int:
    in_degree = [0] * (n + 1)
    graph = [[] for _ in range(n + 1)]

    for prev, next in relations:
        graph[prev].append(next)
        in_degree[next] += 1

    q = [i for i in range(1, n + 1) if in_degree[i] == 0]
    semesters = 0

    while q:
        next_q = []
        semesters += 1
        for course in q:
            n -= 1
            for next_course in graph[course]:
                in_degree[next_course] -= 1
                if in_degree[next_course] == 0:
                    next_q.append(next_course)
        q = next_q

    return semesters if n == 0 else -1
```

",,
"```python
def height_checker(heights):
    expected = sorted(heights)
    count = 0
    for i in range(len(heights)):
        if heights[i] != expected[i]:
            count += 1
    return count
```

",,
"```python
def maxSatisfied(customers, grumpy, minutes):
    total, max_increase, window_increase = 0, 0, 0
    i, j = 0, 0
    while i < len(customers):
        if i - j == minutes:
            window_increase -= customers[j] * grumpy[j]
            j += 1
        window_increase += customers[i] * grumpy[i]
        total += customers[i] * (1 - grumpy[i])
        max_increase = max(max_increase, window_increase)
        i += 1
    return total + max_increase
```

",,
"```python
def prev_perm_opt1(arr):
    n = len(arr)
    for i in range(n - 2, -1, -1):
        if arr[i] > arr[i + 1]:
            j = i + 1
            while j < n and arr[j] < arr[i]:
                j += 1
            arr[i], arr[j - 1] = arr[j - 1], arr[i]
            return arr
    return arr
```

",,
"```python
from heapq import heappush, heappop

def rearrange_barcodes(barcodes):
    count = {}
    for barcode in barcodes:
        if barcode not in count:
            count[barcode] = 0
        count[barcode] += 1

    pq = []
    for key, value in count.items():
        heappush(pq, (-value, key))

    idx = 0
    while pq:
        curr = heappop(pq)
        while curr[0] < 0:
            barcodes[idx] = curr[1]
            curr = (curr[0] + 1, curr[1])
            idx += 2
            if idx >= len(barcodes):
                idx = 1
    return barcodes
```

",,
"```python
def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

",,
"```python
def movesToMakeZigzag(nums):
    even_moves, odd_moves = 0, 0
    for i in range(len(nums)):
        left = nums[i - 1] if i > 0 else 1001
        right = nums[i + 1] if i < len(nums) - 1 else 1001
        min_value = min(left, right)
        if nums[i] >= min_value:
            if i % 2 == 0:
                even_moves += nums[i] - min_value + 1
            else:
                odd_moves += nums[i] - min_value + 1
    return min(even_moves, odd_moves)
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def btree_game_winning_move(root: TreeNode, n: int, x: int) -> bool:
    def count_nodes(node: TreeNode) -> int:
        if not node:
            return 0
        return count_nodes(node.left) + count_nodes(node.right) + 1

    def find_node(node: TreeNode, x: int) -> TreeNode:
        if not node:
            return None
        if node.val == x:
            return node
        left_search = find_node(node.left, x)
        if left_search:
            return left_search
        return find_node(node.right, x)

    x_node = find_node(root, x)
    left_nodes = count_nodes(x_node.left)
    right_nodes = count_nodes(x_node.right)
    parent_nodes = n - left_nodes - right_nodes - 1

    return max(max(left_nodes, right_nodes), parent_nodes) > n // 2
```

",,
"```python
def gcd_of_strings(str1: str, str2: str) -> str:
    if str1 + str2 != str2 + str1:
        return ''
    gcd = lambda a, b: a if not b else gcd(b, a % b)
    return str1[:gcd(len(str1), len(str2))]
```


",,
"```python
from collections import defaultdict

def maxEqualRowsAfterFlips(matrix):
    count = defaultdict(int)
    for row in matrix:
        row_str = """".join(str(row[0] ^ val) for val in row)
        count[row_str] += 1
    return max(count.values())
```

",,
"```python
def is_majority_element(nums, target):
    count = 0
    for num in nums:
        if num == target: count += 1
        if count > len(nums) / 2: return True
    return False
```

",,
"```python
def minSwaps(data):
    ones = sum(data)
    cur_ones, max_ones = 0, 0
    for i, d in enumerate(data):
        cur_ones += d
        if i >= ones:
            cur_ones -= data[i - ones]
        max_ones = max(max_ones, cur_ones)
    return ones - max_ones
```


",,
"```python
from typing import List
from collections import defaultdict
from itertools import combinations

class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        n = len(username)
        visits = defaultdict(list)
        
        # user_visits: {user: [(timestamp, website),...]}
        for i in range(n):
            visits[username[i]].append((timestamp[i], website[i]))


        for user in visits:
            visits[user].sort()
        
        patterns = defaultdict(int)
        
        for user in visits:
            websites = [web for _, web in visits[user]]
            patterns_set = set(combinations(websites, 3))

            for pattern in patterns_set:
                patterns[pattern] += 1
                
        patterns = sorted(patterns.items(), key=lambda x: (-x[1], x[0]))
        
        return list(patterns[0][0])
```


",,
"```python
def canConvert(str1, str2):
    if str1 == str2: return True;
    conversion = {}
    for c1, c2 in zip(str1, str2):
        if c1 in conversion and conversion[c1] != c2: return False
        conversion[c1] = c2
    return len(set(str2)) < 26
```


",,
"```python
def is_leap_year(year: int) -> bool:
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

def day_of_year(date: str) -> int:
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])

    if is_leap_year(year):
        days_in_month[1] = 29

    return sum(days_in_month[:month-1]) + day
```


",,
"```python
def numRollsToTarget(n, k, target):
    MOD = 1000000007
    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i, target + 1):
            for d in range(1, k + 1):
                if j - d >= 0:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD
    return dp[n][target]
```

",,
"```python
def find_third_words(text, first, second):
    words = text.split()
    result = []
    
    for i in range(len(words) - 2):
        if words[i] == first and words[i + 1] == second:
            result.append(words[i + 2])
            
    return result
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_insufficient(node, limit, current_sum):
    if not node:
        return True

    current_sum += node.val
    if not node.left and not node.right:
        return current_sum < limit

    left_insufficient = is_insufficient(node.left, limit, current_sum)
    right_insufficient = is_insufficient(node.right, limit, current_sum)

    if left_insufficient:
        node.left = None
    if right_insufficient:
        node.right = None

    return left_insufficient and right_insufficient

def sufficient_subset(root, limit):
    if is_insufficient(root, limit, 0):
        return None
    return root
```


",,
"```python
def num_tile_possibilities(tiles: str) -> int:
    freq = [0] * 26
    for c in tiles:
        freq[ord(c) - ord('A')] += 1

    def dfs(freq):
        result = 0
        for i in range(26):
            if freq[i] > 0:
                freq[i] -= 1
                result += 1 + dfs(freq)
                freq[i] += 1
        return result

    return dfs(freq)
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def maxLevelSum(root):
    if not root: return 0

    q = [root]
    level, max_sum, result_level = 0, float('-inf'), 0
    
    while q:
        qlen, sum = len(q), 0
        level += 1

        for i in range(qlen):
            temp = q.pop(0)
            sum += temp.val

            if temp.left: q.append(temp.left)
            if temp.right: q.append(temp.right)

        if sum > max_sum:
            max_sum = sum
            result_level = level
    
    return result_level
```

",,
"```python
from collections import deque

def maxDistance(grid):
    distance = -1
    water_cells = deque()
    n = len(grid)

    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                water_cells.append((i, j))

    if not water_cells or len(water_cells) == n * n:
        return distance

    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))

    while water_cells:
        size = len(water_cells)
        for _ in range(size):
            x, y = water_cells.popleft()
            for dx, dy in directions:
                newX, newY = x + dx, y + dy
                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    grid[newX][newY] = 1
                    water_cells.append((newX, newY))
        distance += 1
        
    return distance - 1
```


",,
"```python
def lastSubstring(s: str) -> str:
    maxIndex = 0
    curIndex = 1
    while curIndex < len(s):
        i = 0
        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:
            i += 1
        if curIndex + i == len(s):
            break
        if s[maxIndex + i] < s[curIndex + i]:
            maxIndex = curIndex
        curIndex += 1
    return s[maxIndex:]
```

",,
"```python
def calculate_time(keyboard: str, word: str) -> int:
    time = 0
    prev_index = 0
    char_to_index = {char: i for i, char in enumerate(keyboard)}

    for c in word:
        time += abs(char_to_index[c] - prev_index)
        prev_index = char_to_index[c]

    return time
```

",,
"```python
class FileSystem:
    def __init__(self):
        self.path_map = {}

    def create_path(self, path: str, value: int) -> bool:
        if path in self.path_map:
            return False
        parent_path = path[:path.rfind('/')]
        if parent_path and parent_path not in self.path_map:
            return False
        self.path_map[path] = value
        return True

    def get(self, path: str) -> int:
        return self.path_map.get(path, -1)
```

",,
"```python
import heapq

def connectSticks(sticks):
    heapq.heapify(sticks)
    cost = 0
    while len(sticks) > 1:
        first = heapq.heappop(sticks)
        second = heapq.heappop(sticks)
        cost += first + second
        heapq.heappush(sticks, first + second)
    return cost
```

",,
"```python
def duplicateZeros(arr):
    n = len(arr)
    i = 0
    while i < n - 1:
        if arr[i] == 0:
            for j in range(n - 2, i, -1):
                arr[j + 1] = arr[j]
            arr[i + 1] = 0
            i += 2
        else:
            i += 1
```

",,
"```python
from typing import List

def largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:
    items = sorted(zip(values, labels), reverse=True)
    label_count = {}
    result = 0
    
    for value, label in items:
        if numWanted > 0 and label_count.get(label, 0) < useLimit:
            result += value
            label_count[label] = label_count.get(label, 0) + 1
            numWanted -= 1
    
    return result
```

",,
"```python
def shortest_common_supersequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])

    i, j = m, n
    result = []

    while i > 0 and j > 0:
        if str1[i - 1] == str2[j - 1]:
            result.append(str1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            j -= 1
            result.append(str2[j])
        else:
            i -= 1
            result.append(str1[i])

    while i > 0:
        i -= 1
        result.append(str1[i])

    while j > 0:
        j -= 1
        result.append(str2[j])

    return """".join(result[::-1])
```

",,
"```python
from collections import deque

def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:
        return -1
    q = deque([(0, 0)])
    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    grid[0][0] = 1
    steps = 1

    while q:
        size = len(q)
        for _ in range(size):
            x, y = q.popleft()

            if x == n - 1 and y == n - 1:
                return steps

            for dx, dy in dirs:
                newX, newY = x + dx, y + dy

                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    q.append((newX, newY))
                    grid[newX][newY] = 1

        steps += 1

    return -1
```

",,
"```python
class DinnerPlates:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.stacks = []

    def push(self, val: int) -> None:
        for stack in self.stacks:
            if len(stack) < self.capacity:
                stack.append(val)
                return
        self.stacks.append([val])

    def pop(self) -> int:
        while self.stacks and not self.stacks[-1]:
            self.stacks.pop()
        if not self.stacks:
            return -1
        return self.stacks[-1].pop()

    def popAtStack(self, index: int) -> int:
        if index >= len(self.stacks) or not self.stacks[index]:
            return -1
        return self.stacks[index].pop()
```


",,
"```python
def numPrimeArrangements(n: int) -> int:
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_count = sum(1 for i in range(2, n + 1) if is_prime(i))
    composite_count = n - prime_count

    MOD = 10**9 + 7
    res = 1
    for i in range(1, prime_count + 1):
        res = res * i % MOD
    for i in range(1, composite_count + 1):
        res = res * i % MOD

    return res
```

",,
"```python
def dietPlanPerformance(calories, k, lower, upper):
    points = 0
    T = 0

    for i in range(len(calories)):
        T += calories[i]
        if i >= k:
            T -= calories[i-k]
        if i >= k-1:
            if T < lower: points -= 1
            if T > upper: points += 1

    return points
```

",,
"```python
def canMakePaliQueries(s, queries):
    answer = []
    prefixSum = [0] * (len(s) + 1)

    for i in range(len(s)):
        prefixSum[i + 1] = prefixSum[i] ^ (1 << (ord(s[i]) - ord('a')))

    for query in queries:
        left, right, k = query
        diffCount = bin(prefixSum[right + 1] ^ prefixSum[left]).count('1')
        answer.append((diffCount // 2) <= k)

    return answer
```


",,
"```python
def find_num_of_valid_words(words, puzzles):
    result = []
    for puzzle in puzzles:
        count = 0
        puzzle_set = set(puzzle)
        for word in words:
            if puzzle[0] in word:
                if all(c in puzzle_set for c in word):
                    count += 1
        result.append(count)
    return result
```


",,
"```python
def count_letters(s: str) -> int:
    count = 0
    current = 1

    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            current += 1
        else:
            count += (current * (current + 1)) // 2
            current = 1

    count += (current * (current + 1)) // 2
    return count
```

",,
"```python
from collections import defaultdict

def beforeAndAfterPuzzles(phrases):
    first_word_map = defaultdict(set)
    result = set()

    for phrase in phrases:
        first_word = phrase.split(' ')[0]
        first_word_map[first_word].add(phrase)

    for phrase in phrases:
        last_word = phrase.split(' ')[-1]
        if last_word in first_word_map:
            for cur_phrase in first_word_map[last_word]:
                if phrase != cur_phrase:
                    result.add(phrase + cur_phrase[cur_phrase.index(' '):])

    return sorted(list(result))
```

",,
"```python
def shortestDistance(colors, queries):
    result = []
    positions = [[] for _ in range(3)]

    for i, color in enumerate(colors):
        positions[color - 1].append(i)

    for query in queries:
        index_positions = positions[query[1] - 1]

        if not index_positions:
            result.append(-1)
        else:
            dist = float('inf')

            for pos in index_positions:
                dist = min(dist, abs(pos - query[0]))

            result.append(dist)

    return result
```

",,
"```python
def sampleStats(count):
    minVal, maxVal, mode, median, mean = -1, -1, 0, 0, 0
    totalCount, modeCount, curCount = 0, 0, 0
    sum = 0

    for i in range(256):
        if count[i] > 0:
            if minVal == -1:
                minVal = i
            maxVal = i
            sum += i * count[i]
            totalCount += count[i]
            if count[i] > modeCount:
                modeCount = count[i]
                mode = i

    mean = sum / totalCount
    isEven = (totalCount % 2 == 0)
    mid1 = totalCount // 2
    mid2 = mid1 - 1
    if isEven:
        mid2 += 1

    for i in range(256):
        curCount += count[i]
        if isEven and curCount >= mid2:
            median += i
            mid2 = totalCount
            isEven = False

        if curCount >= mid1:
            median += i
            break

    if not isEven:
        median /= 2
    return [minVal, maxVal, mean, median, mode]
```

",,
"```python
def carPooling(trips, capacity):
    stops = [0] * 1001
    for num, start, end in trips:
        stops[start] += num
        stops[end] -= num
    for i in stops:
        capacity -= i
        if capacity < 0:
            return False
    return True
```

",,
"```python
def day_of_the_week(day, month, year):
    from datetime import date
    days = [""Sunday "", ""Monday "", ""Tuesday "", ""Wednesday "", ""Thursday "", ""Friday "", ""Saturday ""]
    return days[date(year, month, day).weekday()]
```

",,
"```python
from threading import Semaphore

class H2O:
    def __init__(self):
        self.hydrogenSemaphore = Semaphore(2)
        self.oxygenSemaphore = Semaphore(1)

    def hydrogen(self, releaseHydrogen):
        self.hydrogenSemaphore.acquire()
        releaseHydrogen()
        self.oxygenSemaphore.release()

    def oxygen(self, releaseOxygen):
        self.oxygenSemaphore.acquire()
        releaseOxygen()
        self.hydrogenSemaphore.release(2)
```

",,
"```python
from threading import Lock

class FooBar:
    def __init__(self, n: int):
        self.n = n
        self.foo_lock = Lock()
        self.bar_lock = Lock()
        self.bar_lock.acquire()

    def foo(self, printFoo) -> None:
        for _ in range(self.n):
            self.foo_lock.acquire()
            printFoo()
            self.bar_lock.release()

    def bar(self, printBar) -> None:
        for _ in range(self.n):
            self.bar_lock.acquire()
            printBar()
            self.foo_lock.release()
```

",,
"```python
def max_number_of_balloons(text: str) -> int:
    letter_count = [0] * 5
    for c in text:
        if c == 'b': letter_count[0] += 1
        if c == 'a': letter_count[1] += 1
        if c == 'l': letter_count[2] += 1
        if c == 'o': letter_count[3] += 1
        if c == 'n': letter_count[4] += 1
    letter_count[2] //= 2
    letter_count[3] //= 2
    return min(letter_count)
```

",,
"```python
def reverseParentheses(s: str) -> str:
    stack = []
    for i, c in enumerate(s):
        if c == '(':
            stack.append(i)
        elif c == ')':
            start, end = stack.pop(), i
            # reversal of the substring
            s = s[:start] + s[start+1:end][::-1] + s[end+1:]
    return ''.join(c for c in s if c.isalpha())
```

",,
"```python
def kConcatenationMaxSum(arr, k):
    mod = 10**9 + 7
    n = len(arr)
    max_sum, max_left, max_right = 0, 0, 0
    total_sum = sum(arr)
    temp_sum = 0

    for i in range(n):
        temp_sum += arr[i]
        max_sum = max(max_sum, temp_sum)
        temp_sum = max(0, temp_sum)
        max_left = max(max_left, temp_sum)

    temp = total_sum
    for i in range(n - 1, -1, -1):
        temp -= arr[i]
        max_right = max(max_right, temp)

    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)
    return ans % mod
```

",,
"```python
from collections import defaultdict

def criticalConnections(n, connections):
    def dfs(node, parent, depth, rank, graph, result):
        rank[node] = depth
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            if rank[neighbor] == -1:
                dfs(neighbor, node, depth + 1, rank, graph, result)
            rank[node] = min(rank[node], rank[neighbor])
            if rank[neighbor] == depth + 1:
                result.append((node, neighbor))

    graph = defaultdict(list)
    for fr, to in connections:
        graph[fr].append(to)
        graph[to].append(fr)

    rank = [-1] * n
    result = []
    dfs(0, -1, 0, rank, graph, result)
    return result
```


",,
"```python
def minHeightShelves(books, shelfWidth):
    n = len(books)
    dp = [1000000] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        width = 0
        height = 0
        j = i
        while j >= 1:
            width += books[j - 1][0]
            height = max(height, books[j - 1][1])
            
            if width <= shelfWidth:
                dp[i] = min(dp[i], dp[j - 1] + height)
            j -= 1
    
    return dp[n]
```

",,
"```python
def parse_bool_expr(expression, pos=None):
    if pos is None:
        pos = [0]
    current = expression[pos[0]]
    pos[0] += 1
    if current == 't': return True
    if current == 'f': return False
    if current == '!':
        pos[0] += 1
        return not parse_bool_expr(expression, pos)
    if current == '&':
        pos[0] += 1
        result = True
        while expression[pos[0]] != ')':
            result &= parse_bool_expr(expression, pos)
            if expression[pos[0]] == ',': pos[0] += 1
    elif current == '|':
        pos[0] += 1
        result = False
        while expression[pos[0]] != ')':
            result |= parse_bool_expr(expression, pos)
            if expression[pos[0]] == ',': pos[0] += 1
    pos[0] += 1
    return result
```

",,
"```python
def smallest_common_element(mat):
    counts = {}
    for row in mat:
        for num in row:
            counts[num] = counts.get(num, 0) + 1
            if counts[num] == len(mat):
                return num
    return -1
```

",,
"```python
import heapq

def min_build_time(blocks, split):
    heapq.heapify(blocks)
    
    while len(blocks) > 1:
        a = heapq.heappop(blocks)
        b = heapq.heappop(blocks)
        heapq.heappush(blocks, b + split)
    
    return blocks[0]
```

",,
"```python
from typing import List

def minimumAbsDifference(arr: List[int]) -> List[List[int]]:
    arr.sort()
    min_diff = min(arr[i] - arr[i - 1] for i in range(1, len(arr)))

    result = []
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] == min_diff:
            result.append([arr[i - 1], arr[i]])

    return result
```

",,
"```python
import math

def nthUglyNumber(n, a, b, c):
    left, right = 1, int(2e9)
    lcm_ab, lcm_ac, lcm_bc = a * b // math.gcd(a, b), a * c // math.gcd(a, c), b * c // math.gcd(b, c)
    lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)

    while left < right:
        mid = left + (right - left) // 2
        count = mid // a + mid // b + mid // c - mid // lcm_ab - mid // lcm_ac - mid // lcm_bc + mid // lcm_abc
        if count < n:
            left = mid + 1
        else:
            right = mid
    return left
```

",,
"```python
from collections import defaultdict

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)

        # Initialize the parents array
        p = list(range(n))

        # Helper function to find the parent of an index
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        # Union-find, grouping connected indices together
        for pair in pairs:
            root1 = find(pair[0])
            root2 = find(pair[1])
            if root1 != root2:
                p[root2] = root1
                
        # Group all the characters together according to their representatives (parent)
        groups = defaultdict(list)
        for i in range(n):
            root = find(i)
            groups[root].append(s[i])

        # Sort each group
        for group in groups.values():
            group.sort(reverse=True)

        # Build the result string
        res = []
        for i in range(n):
            root = find(i)
            res.append(groups[root].pop())

        return """".join(res)
```


",,
"```python
from threading import Condition

class Foo:
    def __init__(self):
        self.order = 1
        self.cv = Condition()

    def first(self):
        with self.cv:
            # printFirst() outputs ""first"". Do not change or remove this line.
            printFirst()
            self.order = 2
            self.cv.notify_all()

    def second(self):
        with self.cv:
            self.cv.wait_for(lambda: self.order == 2)
            # printSecond() outputs ""second"". Do not change or remove this line.
            printSecond()
            self.order = 3
            self.cv.notify_all()

    def third(self):
        with self.cv:
            self.cv.wait_for(lambda: self.order == 3)
            # printThird() outputs ""third"". Do not change or remove this line.
            printThird()
```

",,
"```python
def corp_flight_bookings(bookings, n):
    answer = [0] * n
    for start, end, seats in bookings:
        answer[start - 1] += seats
        if end < n:
            answer[end] -= seats
    for i in range(1, n):
        answer[i] += answer[i - 1]
    return answer
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def delNodes(root, to_delete):
    forest = []
    to_delete_set = set(to_delete)
    helper(root, True, to_delete_set, forest)
    return forest

def helper(node, isRoot, to_delete, forest):
    if not node:
        return None
    deleted = node.val in to_delete
    if isRoot and not deleted:
        forest.append(node)
    node.left = helper(node.left, deleted, to_delete, forest)
    node.right = helper(node.right, deleted, to_delete, forest)
    return None if deleted else node
```


",,
"```python
def split_string(seq: str):
    result = [0] * len(seq)
    count = 0

    for i in range(len(seq)):
        if seq[i] == '(':
            result[i] = count % 2
            count += 1
        else:
            count -= 1
            result[i] = count % 2

    return result
```


",,
"```python
def removeDuplicates(s: str, k: int) -> str:
    stack = []
    for c in s:
        if not stack or stack[-1][0] != c:
            stack.append((c, 1))
        elif stack[-1][1] + 1 != k:
            stack[-1] = (c, stack[-1][1] + 1)
        else:
            stack.pop()
    return ''.join(c * count for c, count in stack)
```


",,
"```python
def trimmed_mean(arr):
    n = len(arr)
    remove = int(n * 0.05)
    arr.sort()
    return sum(arr[remove:n - remove]) / (n - 2 * remove)
```

",,
"```python
def arraysIntersection(arr1, arr2, arr3):
    i, j, k = 0, 0, 0
    result = []
    while i < len(arr1) and j < len(arr2) and k < len(arr3):
        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:
            result.append(arr1[i])
            i, j, k = i + 1, j + 1, k + 1
        else:
            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:
                i += 1
            elif arr2[j] <= arr3[k]:
                j += 1
            else:
                k += 1
    return result
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def twoSumBSTs(root1, root2, target):
    def build_set(node, s):
        if node:
            s.add(node.val)
            build_set(node.left, s)
            build_set(node.right, s)

    def find_pair(node, target, s):
        if node:
            if target - node.val in s:
                return True
            return find_pair(node.left, target, s) or find_pair(node.right, target, s)
        return False

    s = set()
    build_set(root1, s)
    return find_pair(root2, target, s)
```

",,
"```python
def countSteppingNumbers(low, high):
    results = []
    for i in range(low, high+1):
        prev = -1
        j = i
        is_stepping = True
        while j > 0:
            digit = j % 10
            if prev != -1 and abs(prev - digit) != 1:
                is_stepping = False
                break
            prev = digit
            j //= 10
        if is_stepping:
            results.append(i)
    return results
```

",,
"```python
from threading import Lock

class ZeroEvenOdd:
    def __init__(self, n):
        self.n = n
        self.cnt = 1
        self.lock = Lock()

    def zero(self, printNumber):
        for i in range(1, self.n + 1):
            with self.lock:
                while self.cnt % 2 == 0:
                    self.lock.wait()
                printNumber(0)
                self.cnt += 1
                self.lock.notify_all()

    def even(self, printNumber):
        for i in range(2, self.n + 1, 2):
            with self.lock:
                while self.cnt != 2 * i:
                    self.lock.wait()
                printNumber(i)
                self.cnt += 1
                self.lock.notify_all()

    def odd(self, printNumber):
        for i in range(1, self.n + 1, 2):
            with self.lock:
                while self.cnt != 2 * i - 1:
                    self.lock.wait()
                printNumber(i)
                self.cnt += 1
                self.lock.notify_all()
```

",,
"```python
def sort_array(arr1, arr2):
    counts = {}
    result = []

    for num in arr1:
        counts[num] = counts.get(num, 0) + 1

    for num in arr2:
        if num in counts:
            result.extend([num] * counts[num])
            del counts[num]

    for num in sorted(counts.keys()):
        result.extend([num] * counts[num])

    return result
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            if not node:
                return (None, 0)
            left, right = dfs(node.left), dfs(node.right)
            if left[1] > right[1]:
                return (left[0], left[1] + 1)
            elif left[1] < right[1]:
                return (right[0], right[1] + 1)
            else:
                return (node, left[1] + 1)
        
        return dfs(root)[0]
```


",,
"```python
def longest_wpi(hours):
    score = 0
    max_length = 0
    first_occurrence = {}

    for i, h in enumerate(hours):
        score += 1 if h > 8 else -1
        if score > 0:
            max_length = i + 1
        else:
            if score not in first_occurrence:
                first_occurrence[score] = i
            if score - 1 in first_occurrence:
                max_length = max(max_length, i - first_occurrence[score - 1])
    return max_length
```


",,
"```python
from typing import List

def smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:
    skill_to_int = {s: i for i, s in enumerate(req_skills)}
    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]
        
    n = len(req_skills)
    INF = 64
    dp = [INF] * (1 << n)
    dp[0] = 0
    parent = [None] * (1 << n)
        
    for i, person_skills in enumerate(people_skills):
        for completed_skills in range((1 << n) - 1, -1, -1):
            with_person_skills = completed_skills | person_skills
            if dp[with_person_skills] > dp[completed_skills] + 1:
                dp[with_person_skills] = dp[completed_skills] + 1
                parent[with_person_skills] = completed_skills
                
    ans = [0] * dp[-1]
    cur = (1 << n) - 1
    t = dp[-1] - 1
        
    for i in range(len(people) - 1, -1, -1):
        old = parent[cur]
        diff = cur ^ old
        is_essential = (people_skills[i] & diff) > 0
        if is_essential:
            ans[t] = i
            t -= 1
        cur = old
    return ans
```

",,
"```python
def find_special_integer(arr):
    n = len(arr)
    required_count = n // 4
    for i in range(n):
        if arr[i] == arr[i + required_count]:
            return arr[i]
    return -1
```

",,
"```python
def remove_covered_intervals(intervals):
    intervals.sort(key=lambda x: (x[0], -x[1]))
    
    count = 0
    end = 0
    for i in intervals:
        if i[1] > end:
            count += 1
            end = i[1]
    return count
```


",,
"```python
def areConnected(n, threshold, queries):
    answer = [False] * len(queries)
    parent = list(range(n + 1))
    rank = [0] * (n + 1)

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def unite(x, y):
        rootx = find(x)
        rooty = find(y)
        if rootx != rooty:
            if rank[rootx] > rank[rooty]:
                rootx, rooty = rooty, rootx
            parent[rootx] = rooty
            if rank[rootx] == rank[rooty]:
                rank[rooty] += 1

    for i in range(threshold + 1, n + 1):
        for j in range(i * 2, n + 1, i):
            unite(i, j)

    for i, query in enumerate(queries):
        answer[i] = find(query[0]) == find(query[1])

    return answer
```

",,
"```python
def minFallingPathSum(grid):
    n = len(grid)
    for i in range(1, n):
        for j in range(n):
            minVal = float('inf')
            for k in range(n):
                if k == j:
                    continue
                minVal = min(minVal, grid[i - 1][k])
            grid[i][j] += minVal
    return min(grid[n - 1])
```

",,
"```python
from collections import defaultdict

def num_equiv_domino_pairs(dominoes):
    freq = defaultdict(int)
    result = 0
    for domino in dominoes:
        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])
        result += freq[key]
        freq[key] += 1
    return result
```

",,
"```python
def mctFromLeafValues(arr: List[int]) -> int:
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    maxs = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(i, n):
            maxs[i][j] = max(arr[i:j+1])

    for len_ in range(1, n):
        for i in range(n - len_):
            j = i + len_
            dp[i][j] = float('inf')
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j])

    return dp[0][n - 1]
```

",,
"```python
from collections import defaultdict, deque

def shortestAlternatingPaths(n, redEdges, blueEdges):
    adj_list = defaultdict(lambda: defaultdict(set))
    
    for u, v in redEdges:
        adj_list[u][0].add(v)
        
    for u, v in blueEdges:
        adj_list[u][1].add(v)
        
    dist = [[-1] * 2 for _ in range(n)]
    dist[0] = [0, 0]
    
    q = deque([(0,0), (0,1)])

    while q:
        node, color = q.popleft()
        next_color = color ^ 1
        
        for neighbor in adj_list[node][next_color]:
            if dist[neighbor][next_color] == -1:
                dist[neighbor][next_color] = dist[node][color] + 1
                q.append((neighbor, next_color))
                
    result = []
    for a, b in dist:
        result.append(min(a, b) if a != -1 and b != -1 else max(a, b))
        
    return result
```


",,
"```python
def max_value(arr1, arr2):
    n = len(arr1)
    max1 = max2 = max3 = max4 = float('-inf')
    min1 = min2 = min3 = min4 = float('inf')

    for i in range(n):
        max1 = max(max1, arr1[i] - arr2[i] + i)
        max2 = max(max2, arr1[i] + arr2[i] + i)
        max3 = max(max3, -arr1[i] + arr2[i] + i)
        max4 = max(max4, -arr1[i] - arr2[i] + i)

        min1 = min(min1, arr1[i] - arr2[i] + i)
        min2 = min(min2, arr1[i] + arr2[i] + i)
        min3 = min(min3, -arr1[i] + arr2[i] + i)
        min4 = min(min4, -arr1[i] - arr2[i] + i)

    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)
```


",,
"```python
def replaceElements(arr):
    n = len(arr)
    maxElement = -1
    for i in range(n - 1, -1, -1):
        temp = arr[i]
        arr[i] = maxElement
        maxElement = max(maxElement, temp)
    return arr
```

",,
"```python
def findBestValue(arr, target):
    left = 0
    right = max(arr)
    result = -1
    min_diff = float('inf')

    while left <= right:
        mid = left + (right - left) // 2
        total_sum = sum(min(x, mid) for x in arr)
        if total_sum == target:
            return mid
        elif total_sum > target:
            right = mid - 1
        else:
            left = mid + 1

        if abs(target - total_sum) < min_diff or (
                abs(target - total_sum) == min_diff and mid < result):
            min_diff = abs(target - total_sum)
            result = mid

    return result
```

",,
"```python
from typing import List

def removeSubfolders(folder: List[str]) -> List[str]:
    result = []
    folder.sort()
    prefix = ""/""
    
    for path in folder:
        if not path.startswith(prefix):
            result.append(path)
            prefix = path + ""/""
    return result
```

",,
"```python
def getMaxSumAndCount(board):
    mod = 1000000007
    n = len(board)
    dp = [[(0, 0) for _ in range(n)] for _ in range(n)]
    dp[n - 1][n - 1] = (0, 1)

    for i in range(n - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if board[i][j] == 'X' or (i == n - 1 and j == n - 1):
                continue
            currVal = 0 if board[i][j] == 'E' else int(board[i][j])
            up = dp[i - 1][j] if i > 0 else (-1, 0)
            left = dp[i][j - 1] if j > 0 else (-1, 0)
            diag = dp[i - 1][j - 1] if i > 0 and j > 0 else (-1, 0)

            maxTuple = max(up, left, diag)
            if maxTuple[0] == -1:
                continue

            dp[i][j] = (maxTuple[0] + currVal, dp[i][j][1])

            if up == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + up[1]) % mod)
            if left == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + left[1]) % mod)
            if diag == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + diag[1]) % mod)

    return dp[0][0]
```


",,
"```python
from bisect import bisect_left

def jobScheduling(startTime, endTime, profit):
    jobs = sorted(zip(endTime, startTime, profit))
    dp = [jobs[0][2]]
    
    def latestNonConflict(index):
        startTimeToFind = jobs[index][1]
        index = bisect_left([job[0] for job in jobs], startTimeToFind)
        if index:
            return index - 1
        return -1

    for i in range(1, len(jobs)):
        L = latestNonConflict(i)
        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))

    return dp[-1]
```

",,
"```python
def tribonacci(n: int) -> int:
    if n == 0: return 0
    if n == 1 or n == 2: return 1
    a, b, c = 0, 1, 1
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b + c
    return c
```

",,
"```python
def findSolution(customfunction: 'CustomFunction', z: int) -> List[List[int]]:
    results = []
    for x in range(1, 1001):
        for y in range(1, 1001):
            if customfunction.f(x, y) == z:
                results.append([x, y])
            elif customfunction.f(x, y) > z:
                break
    return results
```

",,
"```python
def alphabet_board_path(target: str) -> str:
    startX, startY = 0, 0
    result = []

    for t in target:
        targetX, targetY = divmod(ord(t) - ord('a'), 5)
        while startX > targetX:
            result.append('U')
            startX -= 1
        while startY > targetY:
            result.append('L')
            startY -= 1
        while startX < targetX:
            result.append('D')
            startX += 1
        while startY < targetY:
            result.append('R')
            startY += 1
        result.append('!')

    return ''.join(result)
```


",,
"```python
def largest1BorderedSquare(grid):
    m, n = len(grid), len(grid[0])
    horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]

    max_square_size = 0

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1
                vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1

                min_size = min(horizontal[i][j], vertical[i][j])
                while min_size > max_square_size:
                    if (horizontal[i - min_size + 1][j] >= min_size and
                        vertical[i][j - min_size + 1] >= min_size):
                        max_square_size = min_size
                    min_size -= 1

    return max_square_size * max_square_size
```

",,
"```python
from functools import lru_cache

def stoneGameII(piles):
    n = len(piles)
    for i in range(n - 2, -1, -1):
        piles[i] += piles[i + 1]

    @lru_cache(None)
    def search(idx, M):
        if idx + 2 * M >= n:
            return piles[idx]
        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))

    return search(0, 1)
```

",,
"```python
def sumEvenGrandparent(root, parent=None, grandparent=None):
    if not root:
        return 0
    sum = 0
    if grandparent and grandparent.val % 2 == 0:
        sum += root.val
    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)
    return sum
```

",,
"```python
def num_distinct_repeated_substrings(s):
    seen = set()
    for length in range(len(s) // 2, 0, -1):
        for i in range(len(s) - 2 * length + 1):
            substr = s[i:i + length]
            if substr in s[i + length:]:
                seen.add(substr)
    return len(seen)
```


",,
"```python
from collections import deque, defaultdict

def tree_diameter(edges):
    tree = defaultdict(list)
    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])

    queue = deque([(0, 0)])
    furthest, max_distance = 0, 0
    while queue:
        node, distance = queue.popleft()
        if distance > max_distance:
            max_distance = distance
            furthest = node
        for neighbor in tree[node]:
            tree[neighbor].remove(node)
            queue.append((neighbor, distance + 1))

    queue.append((furthest, 0))
    max_distance = 0
    while queue:
        node, distance = queue.popleft()
        if distance > max_distance:
            max_distance = distance
        for neighbor in tree[node]:
            tree[neighbor].remove(node)
            queue.append((neighbor, distance + 1))

    return max_distance
```

",,
"```python
def minimumMoves(arr):
    def minRemovals(i, j):
        if i > j:
            return 0
        if i == j:
            return 1
        if dp[i][j] != -1:
            return dp[i][j]

        ans = minRemovals(i + 1, j) + 1
        for k in range(i + 1, j + 1):
            if arr[i] == arr[k]:
                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))
        dp[i][j] = ans
        return ans

    dp = [[-1] * len(arr) for _ in range(len(arr))]
    return minRemovals(0, len(arr) - 1)
```

",,
"```python
def moves_to_make_zigzag(nums):
    moves1, moves2 = 0, 0
    for i in range(len(nums)):
        left = nums[i - 1] if i > 0 else float('inf')
        right = nums[i + 1] if i + 1 < len(nums) else float('inf')
        diff1 = nums[i] - min(left, right) + 1
        diff2 = nums[i] - min(left, right) + 1
        if i % 2 == 0:
            moves1 += max(0, diff1)
        else:
            moves2 += max(0, diff2)
    return min(moves1, moves2)
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def can_win(root, x):
    if not root:
        return False
    if root.val == x:
        left_nodes = 1 + can_win(root.left, x) if root.left else 0
        right_nodes = 1 + can_win(root.right, x) if root.right else 0
        return left_nodes % 2 != 0 or right_nodes % 2 != 0
    return can_win(root.left, x) or can_win(root.right, x)
```

",,
"```python
from math import gcd
from functools import reduce

def isGoodArray(nums):
    return reduce(gcd, nums) == 1
```

",,
"```python
def break_palindrome(palindrome: str) -> str:
    n = len(palindrome)
    if n < 2:
        return """"
    
    palindrome = list(palindrome)
    for i in range(n // 2):
        if palindrome[i] != 'a':
            palindrome[i] = 'a'
            return """".join(palindrome)
    
    palindrome[-1] = 'b'
    return """".join(palindrome)
```

",,
"```python
from heapq import heappush, heappop

def diagonalSort(mat):
    m, n = len(mat), len(mat[0])
    for i in range(m):
        pq = []
        row, col = i, 0
        while row < m and col < n:
            heappush(pq, mat[row][col])
            row += 1
            col += 1
        row, col = i, 0
        while row < m and col < n:
            mat[row][col] = heappop(pq)
            row += 1
            col += 1
        
    for i in range(1, n):
        pq = []
        row, col = 0, i
        while row < m and col < n:
            heappush(pq, mat[row][col])
            row += 1
            col += 1
        row, col = 0, i
        while row < m and col < n:
            mat[row][col] = heappop(pq)
            row += 1
            col += 1
    return mat
```


",,
"```python
def closedIsland(grid):
    def dfs(grid, i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):
            return False

        if grid[i][j] == 1:
            return True

        grid[i][j] = 1

        up = dfs(grid, i - 1, j)
        down = dfs(grid, i + 1, j)
        left = dfs(grid, i, j - 1)
        right = dfs(grid, i, j + 1)

        return up and down and left and right

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 0 and dfs(grid, i, j):
                count += 1

    return count
```


",,
"```python
def maxValueAfterReverse(nums):
    total, diff = 0, 0
    min2, max2 = float('inf'), float('-inf')
    for i in range(len(nums) - 1):
        total += abs(nums[i] - nums[i + 1])
        min2 = min(min2, max(nums[i], nums[i + 1]))
        max2 = max(max2, min(nums[i], nums[i + 1]))
        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))
        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))
    return total + max(diff, 2 * (max2 - min2))
```

",,
"```python
def arrayRankTransform(arr):
    sorted_arr = sorted(arr)
    rank_map = {}
    rank = 1

    for num in sorted_arr:
        if num not in rank_map:
            rank_map[num] = rank
            rank += 1

    return [rank_map[num] for num in arr]
```

",,
"```python
from collections import deque
from itertools import chain

def matrix_rank_transform(matrix):
    def neighbours(r, c):
        for i in range(m):
            if i != r:
                yield i, c
        for i in range(n):
            if i != c:
                yield r, i

    m, n = len(matrix), len(matrix[0])
    rank = [[0] * n for _ in range(m)]
    sorted_row = [0] * m
    sorted_col = [0] * n

    for bound in range(200001):
        q = deque((r, c) for r in range(m) for c in range(n) if matrix[r][c] == bound and rank[r][c] == 0)
        if not q:
            break
        while q:
            r, c = rc = q.popleft()
            potential_rank = sorted_row[r] + 1
            for row, col in neighbours(r, c):
                if matrix[row][col] <= matrix[r][c]:
                    potential_rank = max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c]))
            if potential_rank == sorted_col[c] + 1:
                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank
            else:
                q.append(rc)
    return rank
```

",,
"```python
from typing import List


def generateSentences(synonyms: List[List[str]], text: str) -> List[str]:
    synonym_map = {}

    for s, t in synonyms:
        if s not in synonym_map:
            synonym_map[s] = {s}
        if t not in synonym_map:
            synonym_map[t] = {t}
        synonym_map[s].add(t)
        synonym_map[t].add(s)

    words = text.split()
    results = []

    def helper(index: int, cur_sentence: List[str]) -> None:
        if index == len(words):
            results.append("" "".join(cur_sentence))
            return
        for w in synonym_map.get(words[index], {words[index]}):
            cur_sentence.append(w)
            helper(index + 1, cur_sentence)
            cur_sentence.pop()

    helper(0, [])

    return sorted(results)
```


",,
"```python
def numberOfWays(numPeople: int) -> int:
    MOD = 1000000007
    dp = [0] * (numPeople // 2 + 1)
    dp[0] = 1
    for i in range(1, numPeople // 2 + 1):
        for j in range(1, i + 1):
            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD
    return dp[numPeople // 2]
```


",,
"```python
def dayOfYear(date: str) -> int:
    year, month, day = map(int, date.split('-'))

    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        daysInMonth[2] = 29

    dayOfYear = sum(daysInMonth[:month]) + day
    return dayOfYear
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class FindElements:
    def __init__(self, root: TreeNode):
        self.values = set()
        self.recoverTree(root, 0)

    def find(self, target: int) -> bool:
        return target in self.values

    def recoverTree(self, node: TreeNode, val: int):
        if node is None:
            return

        node.val = val
        self.values.add(val)

        self.recoverTree(node.left, val * 2 + 1)
        self.recoverTree(node.right, val * 2 + 2)
```

",,
"```python
from collections import defaultdict
from random import randint

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.positions = defaultdict(list)
        for i, num in enumerate(arr):
            self.positions[num].append(i)

    def query(self, left: int, right: int, threshold: int) -> int:
        for _ in range(20):
            randomIndex = randint(left, right)
            num = self.arr[randomIndex]
            lb = self.lower_bound(self.positions[num], left)
            ub = self.upper_bound(self.positions[num], right)
            if ub - lb >= threshold:
                return num
        return -1

    def lower_bound(self, nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid
        return l

    def upper_bound(self, nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) // 2
            if nums[mid] <= target:
                l = mid + 1
            else:
                r = mid
        return l
```

",,
"```python
def numRollsToTarget(n, k, target):
    MOD = 10**9 + 7
    dp = [[0] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    
    for i in range(1, n + 1):
        for j in range(1, target + 1):
            for l in range(1, k + 1):
                if j >= l:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD
    return dp[n][target]
```

",,
"```python
def printLinkedListInReverse(head: 'ImmutableListNode') -> None:
    if head is not None:
        printLinkedListInReverse(head.getNext())
        head.printValue()
```

",,
"```python
def minTimeToVisitAllPoints(points):
    time = 0
    for i in range(1, len(points)):
        dx = abs(points[i][0] - points[i - 1][0])
        dy = abs(points[i][1] - points[i - 1][1])
        time += max(dx, dy)
    return time
```

",,
"```python
def remove_zero_sum_sublists(head):
    dummy = ListNode(0)
    dummy.next = head
    current = dummy

    while current:
        sum = 0
        while head:
            sum += head.val
            if sum == 0:
                current.next = head.next
            head = head.next
        current = current.next
        if current:
            head = current.next

    return dummy.next
```


",,
"```python
def suggestedProducts(products, searchWord):
    result = []
    products.sort()
    
    for i in range(len(searchWord)):
        suggestions = []
        for product in products:
            if len(product) > i and product[i] == searchWord[i]:
                suggestions.append(product)
                if len(suggestions) == 3:
                    break
        result.append(suggestions)
    
    return result
```


",,
"```python
from functools import lru_cache

mod = 10**9 + 7

def numOfWays(steps: int, arrLen: int) -> int:
    @lru_cache(None)
    def dp(s, p):
        if p < 0 or p >= arrLen or p > steps - p:
            return 0
        if s == 0:
            return p == 0
        return (dp(s - 1, p - 1) + dp(s - 1, p) + dp(s - 1, p + 1)) % mod

    return dp(steps, 0)
```


",,
"```python
def to_hexspeak(num: str) -> str:
    n = int(num)
    hex_str = []
    while n:
        rem = n % 16
        if rem == 1: hex_str.insert(0, 'I')
        elif rem == 0: hex_str.insert(0, 'O')
        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))
        else: return 'ERROR'
        n //= 16
    return ''.join(hex_str)
```

",,
"```python
def invalid_transactions(transactions):
    trans_map = {}
    
    for trans in transactions:
        temp = trans.split("","")
        trans_map.setdefault(temp[0], []).append(temp)
    
    ans = []

    for trans in transactions:
        temp = trans.split("","")

        if int(temp[2]) > 1000:
            ans.append(trans)
            continue

        for other in trans_map[temp[0]]:
            if other[3] != temp[3] and abs(int(other[1]) - int(temp[1])) <= 60:
                ans.append(trans)
                break

    return ans
```


",,
"```python
def countSmallerFrequencies(words, queries):
    freqWords = [word.count(min(word)) for word in words]
    
    ans = []
    for query in queries:
        freqQuery = query.count(min(query))
        ans.append(sum(f > freqQuery for f in freqWords))
        
    return ans
```

",,
"```python
from datetime import datetime

def countDaysBetweenDates(date1, date2):
    d1 = datetime.strptime(date1, ""%Y-%m-%d"")
    d2 = datetime.strptime(date2, ""%Y-%m-%d"")
    return abs((d2 - d1).days)
```

",,
"```python
def validateBinaryTreeNodes(n, leftChild, rightChild):
    parent = [-1] * n
    for i in range(n):
        if leftChild[i] != -1:
            if parent[leftChild[i]] != -1:
                return False
            parent[leftChild[i]] = i
        if rightChild[i] != -1:
            if parent[rightChild[i]] != -1:
                return False
            parent[rightChild[i]] = i
    
    root = -1
    for i in range(n):
        if parent[i] == -1:
            if root != -1:
                return False
            root = i

    return root != -1
```

",,
"```python
def closest_factors(num):
    factor1 = int((num + 2) ** 0.5)
    while True:
        factor2 = (num + 2) // factor1
        if factor1 * factor2 == num + 2:
            return factor1, factor2
        factor2 = (num + 1) // factor1
        if factor1 * factor2 == num + 1:
            return factor1, factor2
        factor1 -= 1
```

",,
"```python
def largest_multiple_of_three(digits):
    count = [0] * 3
    num_sum = sum(digits)
    
    for d in digits:
        count[d % 3] += 1

    if num_sum % 3 == 1:
        if count[1] >= 1:
            count[1] -= 1
        else:
            count[2] -= 2
    elif num_sum % 3 == 2:
        if count[2] >= 1:
            count[2] -= 1
        else:
            count[1] -= 2

    res = """"
    for i in range(10):
        res += str(i) * count[i % 3]
    
    if res and res[-1] == ""0"":
        return ""0""
    return res[::-1]
```

",,
"```python
def palindromePartition(s: str, k: int) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for len in range(2, n + 1):
        for i in range(n - len + 1):
            j = i + len - 1
            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j])

    memo = [float('inf')] * n
    for i in range(n):
        if dp[0][i] == 0:
            memo[i] = 0
        else:
            for j in range(i):
                memo[i] = min(memo[i], memo[j] + dp[j + 1][i])

    return memo[-1] + k
```



",,
"```python
def can_make_pali_queries(s, queries):
    result = []
    for left, right, k in queries:
        count = [0] * 26
        for i in range(left, right + 1):
            count[ord(s[i]) - ord('a')] += 1
        odd_count = sum(c % 2 for c in count)
        result.append(odd_count // 2 <= k)
    return result
```

",,
"```python
from collections import defaultdict

def groupThePeople(groupSizes):
    groups = defaultdict(list)
    result = []

    for i, size in enumerate(groupSizes):
        groups[size].append(i)
        if len(groups[size]) == size:
            result.append(groups[size])
            groups[size] = []

    return result
```

",,
"```python
def format_date(date):
    months = {
        ""Jan"": ""01"",
        ""Feb"": ""02"",
        ""Mar"": ""03"",
        ""Apr"": ""04"",
        ""May"": ""05"",
        ""Jun"": ""06"",
        ""Jul"": ""07"",
        ""Aug"": ""08"",
        ""Sep"": ""09"",
        ""Oct"": ""10"",
        ""Nov"": ""11"",
        ""Dec"": ""12"",
    }

    day, month, year = date.split()
    return f""{year}-{months[month]}-{day}""
```

",,
"```python
def sum_of_divisors_with_four_divisors(nums):
    total_sum = 0

    for num in nums:
        div_count = 0
        div_sum = 0

        for i in range(1, int(num ** 0.5) + 1):
            if num % i == 0:
                div_sum += i
                div_count += 1

                if num // i != i:
                    div_sum += num // i
                    div_count += 1

            if div_count > 4:
                break

        if div_count == 4:
            total_sum += div_sum

    return total_sum
```

",,
"```python
def max_sum_subsequence(nums: List[int], k: int) -> int:
    n = len(nums)
    dp = [0] * n
    result = 0

    for i in range(n):
        dp[i] = nums[i]
        for j in range(max(0, i - k), i):
            dp[i] = max(dp[i], dp[j] + nums[i])
        result = max(result, dp[i])

    return result
```

",,
"```python
def shortest_distance(distance, start, destination):
    total_distance = sum(distance)
    clockwise_distance = sum(distance[start:destination])
    
    return min(clockwise_distance, total_distance - clockwise_distance)
```

",,
"```python
def maximum_sum(arr):
    n = len(arr)
    sum_without_deletion = [0] * n
    sum_with_deletion = [0] * n
    sum_without_deletion[0] = arr[0]
    sum_with_deletion[0] = 0
    max_sum = arr[0]

    for i in range(1, n):
        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i])
        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1])
        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]))
    return max_sum
```

",,
"```python
def day_of_the_week(day, month, year):
    days = [""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""]
    if month < 3:
        month += 12
        year -= 1
    k = year % 100
    j = year // 100
    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7
    return days[day_of_week]
```

",,
"```python
def min_operations(arr1, arr2):
    n = len(arr1)
    dp = [float('inf')] * n
    for a in arr2:
        new_dp = [float('inf')] * n
        p = 0
        for i in range(n):
            if a < arr1[i]:
                new_dp[i] = p
            if i > 0 and dp[i - 1] < p:
                p = dp[i - 1]
            if arr1[i] > arr1[i + 1]:
                return -1
        dp = new_dp
    return dp[-1]
```

",,
"```python
def sequential_digits(low, high):
    result = []
    for i in range(1, 10):
        number = i
        for j in range(i + 1, 10):
            number = number * 10 + j
            if low <= number <= high:
                result.append(number)
    return sorted(result)
```

",,
"```python
def maxSideLength(mat: List[List[int]], threshold: int) -> int:
    m, n = len(mat), len(mat[0])
    preSum = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]

    maxSide = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            for k in range(1, min(m, n) + 1):
                endX, endY = i + k - 1, j + k - 1
                if endX <= m and endY <= n:
                    sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1]
                    if sum <= threshold:
                        maxSide = max(maxSide, k)
                else:
                    break
    return maxSide
```


",,
"```python
from collections import deque

def shortestPath(grid, k):
    m, n = len(grid), len(grid[0])
    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]
    q = deque([(0, 0, 0, k)])
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    steps = 0

    while q:
        for _ in range(len(q)):
            x, y, steps, k_remaining = q.popleft()
            if x == m - 1 and y == n - 1:
                return steps
            for dx, dy in moves:
                new_x, new_y, = x + dx, y + dy
                if 0 <= new_x < m and 0 <= new_y < n:
                    new_k_remaining = k_remaining - grid[new_x][new_y]
                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:
                        visited[new_x][new_y][new_k_remaining] = True
                        q.append((new_x, new_y, steps + 1, new_k_remaining))
        steps += 1

    return -1
```

",,
"```python
def min_perimeter(neededApples):
    layer = 0
    apples = 0

    while apples < neededApples:
        layer += 1
        apples += 12 * layer

    return 8 * layer
```

",,
"```python
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        self.dp = [[0] * 20 for _ in range(n)]
        for i in range(n):
            self.dp[i][0] = parent[i]
        for k in range(1, 20):
            for i in range(n):
                if self.dp[i][k - 1] != -1:
                    self.dp[i][k] = self.dp[self.dp[i][k - 1]][k - 1]
                else:
                    self.dp[i][k] = -1

    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(20):
            if k & (1 << i):
                node = self.dp[node][i]
                if node == -1:
                    return -1
        return node
```

",,
"```python
def maxNumberOfBalloons(text):
    freqs = [0] * 26
    for c in text:
        freqs[ord(c) - ord('a')] += 1
    subs = [freqs[ord('b') - ord('a')], freqs[ord('a') - ord('a')], freqs[ord('l') - ord('a')] // 2, freqs[ord('o') - ord('a')] // 2, freqs[ord('n') - ord('a')]]
    return min(subs)
```


",,
"```python
def reverseParentheses(s: str) -> str:
    st = []
    result = []

    for c in s:
        if c != ')':
            st.append(c)
        else:
            temp = []
            while st and st[-1] != '(':
                temp.append(st.pop())
            if st: st.pop()  # Remove '('
            st.extend(temp)

    result = """".join(st)
    return result
```


",,
"```python
def kConcatenationMaxSum(arr, k):
    M = 10**9 + 7
    s = sum(arr)
    max_sum = max_ending_here = 0
    for i in range(len(arr) * min(2, k)):
        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])
        max_sum = max(max_sum, max_ending_here)
    return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M
```

",,
"```python
from collections import defaultdict

def criticalConnections(n, connections):
    graph = defaultdict(list)
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)

    ans = []
    low, disc = [-1] * n, [-1] * n
    time = [0]

    def dfs(u, parent):
        low[u] = disc[u] = time[0]
        time[0] += 1
        for v in graph[u]:
            if v == parent:
                continue
            if disc[v] == -1:
                dfs(v, u)
                low[u] = min(low[u], low[v])
                if low[v] > disc[u]:
                    ans.append([u, v])
            else:
                low[u] = min(low[u], disc[v])

    dfs(0, -1)
    return ans
```

",,
"```python
from typing import List

MOD = 10**9 + 7

def pathsWithMaxScore(board: List[str]) -> List[int]:
    n = len(board)
    dp = [[0] * n for _ in range(n)]
    cnt = [[0] * n for _ in range(n)]

    board[0] = list(board[0])
    board[0][0] = '0'
    board[n-1] = list(board[n-1])
    board[n-1][n-1] = '0'
    cnt[n-1][n-1] = 1

    for i in range(n-1, -1, -1):
        for j in range(n-1, -1, -1):
            if board[i][j] != 'X':
                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]
                for x, y in neighbors:
                    if x >= 0 and y >= 0:
                        if dp[i][j] < dp[x][y] + int(board[i][j]):
                            dp[i][j] = dp[x][y] + int(board[i][j])
                            cnt[i][j] = cnt[x][y]
                        elif dp[i][j] == dp[x][y] + int(board[i][j]):
                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD

    return [dp[0][0], cnt[0][0]]
```


",,
"```python
def make_fancy_string(s: str) -> str:
    result = [s[0]]
    count = 1

    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            count = 1
        if count < 3:
            result.append(s[i])

    return ''.join(result)
```


",,
"```python
from heapq import heappush, heappop

def longestHappyString(a, b, c):
    res = """"
    pq = []
    if a: heappush(pq, (-a, 'a'))
    if b: heappush(pq, (-b, 'b'))
    if c: heappush(pq, (-c, 'c'))

    while pq:
        curr = heappop(pq)
        if len(res) >= 2 and res[-1] == curr[1] and res[-2] == curr[1]:
            if not pq: break
            next = heappop(pq)
            res += next[1]
            if next[0] < -1: heappush(pq, (next[0] + 1, next[1]))
            heappush(pq, curr)
        else:
            res += curr[1]
            if curr[0] < -1: heappush(pq, (curr[0] + 1, curr[1]))

    return res
```


",,
"```python
def people_can_see(heights):
    n = len(heights)
    ans = [0] * n
    st = []

    for i in range(n - 1, -1, -1):
        while st and heights[st[-1]] < heights[i]:
            idx = st.pop()
            ans[i] += 1
            ans[i] += ans[idx]
        st.append(i)

    return ans
```


",,
"```python
def minimumAbsDifference(arr):
    arr.sort()
    min_difference = float('inf')
    result = []

    for i in range(1, len(arr)):
        difference = arr[i] - arr[i - 1]
        if difference < min_difference:
            min_difference = difference
            result = [[arr[i - 1], arr[i]]]
        elif difference == min_difference:
            result.append([arr[i - 1], arr[i]])

    return result
```

",,
"```python
def nthUglyNumber(n, a, b, c):
    from math import gcd

    ab = a * b // gcd(a, b)
    ac = a * c // gcd(a, c)
    bc = b * c // gcd(b, c)
    abc = a * bc // gcd(a, bc)

    left, right = 0, 2 * 10**9
    while left < right:
        mid = left + (right - left) // 2
        cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc
        if cnt < n:
            left = mid + 1
        else:
            right = mid

    return left
```

",,
"```python
from collections import defaultdict, deque

def sortItems(n, m, group, beforeItems):
    def topological_sort(outdegree, edges):
        res = []
        q = deque([i for i in range(len(outdegree)) if outdegree[i] == 0])
        while q:
            u = q.pop()
            res.append(u)
            for v in edges[u]:
                outdegree[v] -= 1
                if outdegree[v] == 0:
                    q.append(v)
        return res

    # Calculate outdegrees and dependencies for groups and items
    group_outdegree = [0] * m
    group_edges = defaultdict(list)

    item_outdegree = [0] * n
    item_edges = defaultdict(list)

    for i in range(n):
        for dep in beforeItems[i]:
            a, b = group[i], group[dep]
            if a != -1 and a != b and not (group_edges[b] and group_edges[b][-1] == a):
                group_edges[b].append(a)
                group_outdegree[a] += 1
            if a != b:
                item_edges[dep].append(i)
                item_outdegree[i] += 1

    group_order = topological_sort(group_outdegree, group_edges)
    if len(group_order) < m:
        return []

    item_order = topological_sort(item_outdegree, item_edges)
    if len(item_order) < n:
        return []

    # Combine orders
    res = [0] * n
    idx = 0
    for gi in group_order:
        for item_idx in item_order:
            if group[item_idx] == gi:
                res[idx] = item_idx
                idx += 1

    return res
```


",,
"```python
def water_plants(plants, capacity):
    steps = 0
    water_left = 0

    for i, plant in enumerate(plants):
        if water_left < plant:
            steps += 2 * i + 1  # Refill the watering can
            water_left = capacity
        water_left -= plant
        steps += 1  # Move to the next plant

    return steps
```


",,
"```python
def largestMagicSquare(grid):
    m, n = len(grid), len(grid[0])
    row = [[0] * (n + 1) for _ in range(m)]
    col = [[0] * n for _ in range(m + 1)]

    for i in range(m):
        for j in range(n):
            row[i][j + 1] = row[i][j] + grid[i][j]
            col[i + 1][j] = col[i][j] + grid[i][j]

    for k in reversed(range(2, min(m, n) + 1)):
        for i in range(m - k + 1):
            for j in range(n - k + 1):
                _sum = row[i][j + k] - row[i][j]
                ok = all(row[i + t][j + k] - row[i + t][j] == _sum for t in range(1, k)) and all(
                    col[i + k][j + t] - col[i][j + t] == _sum for t in range(1, k))

                if not ok: continue
                
                diag1 = sum(grid[i + t][j + t] for t in range(k))
                diag2 = sum(grid[i + t][j + k - 1 - t] for t in range(k))
                
                if diag1 == _sum and diag2 == _sum: return k

    return 1
```


",,
"```python
def extract_artifacts(n, artifacts, dig):
    artifact_cells = {}
    artifact_count = {}

    for i, (r1, c1, r2, c2) in enumerate(artifacts):
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                cell = r * n + c
                if cell not in artifact_cells:
                    artifact_cells[cell] = set()
                artifact_cells[cell].add(i)
                artifact_count[i] = artifact_count.get(i, 0) + 1

    ans = 0
    for r, c in dig:
        cell = r * n + c
        if cell in artifact_cells:
            for artifact_id in artifact_cells[cell]:
                artifact_count[artifact_id] -= 1
                if artifact_count[artifact_id] == 0:
                    ans += 1
            del artifact_cells[cell]

    return ans
```

",,
"```python
MOD = 10**9 + 7

def add_rooms(idx, children, memo):
    if not children[idx]:
        return 1
    if memo[idx] != -1:
        return memo[idx]

    res = 1
    cnt = 0
    for child in children[idx]:
        cnt += 1
        res = (res * add_rooms(child, children, memo)) % MOD
    
    for i in range(2, cnt + 1):
        res = (res * i) % MOD
    
    memo[idx] = res
    return res

def num_of_ways(prev_room):
    n = len(prev_room)
    children = [[] for _ in range(n)]
    for i in range(1, n):
        children[prev_room[i]].append(i)

    memo = [-1] * n
    return add_rooms(0, children, memo)
```

",,
"```python
def matrix_block_sum(mat, k):
    m, n = len(mat), len(mat[0])
    answer = [[0 for _ in range(n)] for _ in range(m)]

    for i in range(m):
        for j in range(n):
            for r in range(max(0, i - k), min(m, i + k + 1)):
                for c in range(max(0, j - k), min(n, j + k + 1)):
                    answer[i][j] += mat[r][c]
                    
    return answer
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sumEvenGrandparent(root, parent=None, grandparent=None):
    if root is None:
        return 0
    sum = root.val if grandparent and grandparent.val % 2 == 0 else 0
    return sum + sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)
```

",,
"```python
def no_zero_integers(n: int):
    for a in range(1, n):
        if '0' not in str(a) and '0' not in str(n - a):
            return [a, n - a]
    return [0, 0]  # never gets here
```

",,
"```python
def minFlips(a: int, b: int, c: int) -> int:
    count = 0
    for i in range(32):
        bitA = (a >> i) & 1
        bitB = (b >> i) & 1
        bitC = (c >> i) & 1
        if bitC == 0:
            count += bitA + bitB
        else:
            count += 1 - (bitA | bitB)
    return count
```

",,
"```python
def unique_occurrences(arr):
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    
    unique_counts = set()
    for count in counts.values():
        if count in unique_counts:
            return False
        unique_counts.add(count)
    
    return True
```

",,
"```python
def removeDuplicates(s: str, k: int) -> str:
    stack = []
    for c in s:
        if stack and stack[-1][0] == c:
            stack[-1][1] += 1
            if stack[-1][1] == k:
                stack.pop()
        else:
            stack.append([c, 1])
    return ''.join(c * n for c, n in stack)
```

",,
"```python
def maximum69Number(num: int) -> int:
    num_str = list(str(num))
    for i in range(len(num_str)):
        if num_str[i] == '6':
            num_str[i] = '9'
            break
    return int(''.join(num_str))
```

",,
"```python
def findBall(grid):
    m, n = len(grid), len(grid[0])
    result = [-1] * n

    for i in range(n):
        x, y = 0, i

        while x < m:
            nx, ny = x + 1, y + grid[x][y]
            if ny < 0 or ny >= n or grid[x][ny] != grid[x][y]:
                break
            x, y = nx, ny

        if x == m:
            result[i] = y

    return result
```


",,
"```python
from heapq import heappush, heappop

def maxProbability(n, edges, succProb, start, end):
    graph = [[] for _ in range(n)]
    for i in range(len(edges)):
        a, b = edges[i]
        graph[a].append((b, succProb[i]))
        graph[b].append((a, succProb[i]))

    max_prob = [0] * n
    max_prob[start] = 1

    pq = [(-1, start)]
    
    while pq:
        prob, node = heappop(pq)

        if node == end:
            return -prob

        if -prob < max_prob[node]:
            continue

        for neighbor, edge_prob in graph[node]:
            new_prob = -prob * edge_prob
            if new_prob > max_prob[neighbor]:
                max_prob[neighbor] = new_prob
                heappush(pq, (-new_prob, neighbor))

    return 0
```


",,
"```python
def sum_of_floored_pairs(nums):
    mod = 10**9 + 7
    max_val = max(nums)
    count = [0] * (max_val + 1)
    pref_sum = [0] * (max_val + 1)

    for num in nums:
        count[num] += 1

    for i in range(1, max_val + 1):
        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod

    res = 0
    for x in range(1, max_val + 1):
        nx = x
        k = 1
        while nx <= max_val:
            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod
            k += 1
            nx += x
    return res
```

",,
"```python
def breakPalindrome(palindrome: str) -> str:
    length = len(palindrome)
    if length == 1:
        return """"
    
    chars = list(palindrome)
    for i in range(length // 2):
        if chars[i] != 'a':
            chars[i] = 'a'
            return """".join(chars)
    
    chars[length - 1] = 'b'
    return """".join(chars)
```

",,
"```python
def minCostToMoveChips(position):
    evenCount, oddCount = 0, 0
    for i in position:
        if i % 2 == 0:
            evenCount += 1
        else:
            oddCount += 1
    return min(evenCount, oddCount)
```

",,
"```python
def longestSubsequence(arr, difference):
    dp = {}
    maxLength = 0
    for num in arr:
        dp[num] = dp.get(num - difference, 0) + 1
        maxLength = max(maxLength, dp[num])
    return maxLength
```


",,
"```python
def getMaximumGold(grid):
    m, n, max_gold = len(grid), len(grid[0]), 0

    def getMaximumGoldHelper(x, y):
        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:
            return 0

        original_gold = grid[x][y]
        grid[x][y] = 0

        max_gold = 0
        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))

        grid[x][y] = original_gold
        return max_gold + original_gold

    for i in range(m):
        for j in range(n):
            if grid[i][j] != 0:
                max_gold = max(max_gold, getMaximumGoldHelper(i, j))

    return max_gold
```


",,
"```python
def countStrings(n):
    mod = 10**9 + 7
    a, b = 1, 1
    for _ in range(n):
        a = (a * 2) % mod
        b = (b * 3) % mod
    return (b - a + mod) % mod
```


",,
"```python
def sort_based_on_mapping(mapping, nums):
    def mapped_value(num):
        return int(''.join(str(mapping[int(d)]) for d in str(num)))
    
    return sorted(nums, key=mapped_value)
```

",,
"```python
def findTheCity(n, edges, distanceThreshold):
    distance = [[1e5] * n for _ in range(n)]

    for edge in edges:
        distance[edge[0]][edge[1]] = edge[2]
        distance[edge[1]][edge[0]] = edge[2]

    for i in range(n):
        distance[i][i] = 0

    for k in range(n):
        for i in range(n):
            for j in range(n):
                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])

    res, minReachable = 0, n
    for i in range(n):
        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)
        if reachable <= minReachable:
            minReachable = reachable
            res = i
    return res
```


",,
"```python
def max_candies(candies, k):
    left, right = 1, max(candies)
    
    while left <= right:
        mid = left + (right - left) // 2
        count = sum(candy // mid for candy in candies)
        if count >= k:
            left = mid + 1
        else:
            right = mid - 1
    return right
```

",,
"```python
from typing import List

def kWeakestRows(mat: List[List[int]], k: int) -> List[int]:
    soldiers_count = [(sum(row), idx) for idx, row in enumerate(mat)]
    soldiers_count.sort()
    return [x[1] for x in soldiers_count[:k]]
```

",,
"```python
from collections import Counter
import heapq

def minSetSize(arr):
    freq_map = Counter(arr)
    max_heap = [-cnt for cnt in freq_map.values()]
    heapq.heapify(max_heap)
    half = len(arr) // 2
    cnt = 0
    size = 0
    while size < half:
        size -= heapq.heappop(max_heap)
        cnt += 1
    return cnt
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sum_subtrees(self, root, sums):
        if not root: return 0
        s = root.val + self.sum_subtrees(root.left, sums) + self.sum_subtrees(root.right, sums)
        sums.append(s)
        return s

    def maxProduct(self, root):
        sums = []
        total = self.sum_subtrees(root, sums)
        max_product = max(s * (total - s) for s in sums)
        return max_product % 1000000007
```

",,
"```python
import threading

class DiningPhilosophers:
    def __init__(self):
        self.forks = [threading.Lock() for _ in range(5)]
        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]

    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:
        left_fork = philosopher
        right_fork = (philosopher + 1) % 5

        with self.forks[left_fork]:
            with self.not_busy[left_fork]:
                while not self.forks[right_fork].acquire(blocking=False):
                    self.not_busy[left_fork].wait()
            pickLeftFork()

            with self.forks[right_fork]:
                pickRightFork()
                eat()
                putRightFork()
                self.forks[right_fork].release()
                with self.not_busy[right_fork]:
                    self.not_busy[right_fork].notify_all()

            putLeftFork()
            self.not_busy[left_fork].notify_all()
```

",,
"```python
def queensAttacktheKing(queens, king):
    result = []
    for x in range(-1, 2):
        for y in range(-1, 2):
            if x == 0 and y == 0:
                continue
            posX, posY = king[0] + x, king[1] + y
            while 0 <= posX < 8 and 0 <= posY < 8:
                for queen in queens:
                    if posX == queen[0] and posY == queen[1]:
                        result.append([queen[0], queen[1]])
                        break
                posX += x
                posY += y
    return result
```

",,
"```python
def dieSimulator(n, rollMax):
    MOD = 10**9 + 7
    dp = [[0] * (n + 1) for _ in range(6)]
    sum_dp = [0] * (n + 1)

    for i in range(6):
        dp[i][1] = 1
    sum_dp[1] = 6

    for j in range(2, n + 1):
        cur_sum = 0
        for i in range(6):
            dp[i][j] = sum_dp[j - 1]
            if j - rollMax[i] - 1 >= 0:
                dp[i][j] = (dp[i][j] - sum_dp[j - rollMax[i] - 1] + MOD) % MOD
                if j - rollMax[i] - 1 >= 1:
                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD
            cur_sum = (cur_sum + dp[i][j]) % MOD
        sum_dp[j] = cur_sum

    return sum_dp[n]
```

",,
"```python
def maxEqualFreq(nums):
    count, freq = {}, {}
    max_len, max_freq = 0, 0
    for i, num in enumerate(nums):
        count[num] = count.get(num, 0) + 1
        freq[count[num] - 1] = freq.get(count[num] - 1, 0) - 1
        freq[count[num]] = freq.get(count[num], 0) + 1

        max_freq = max(max_freq, count[num])
        if max_freq * (i + 1) == i or max_freq * (freq.get(max_freq - 1, 0) + 1) + (max_freq - 1) * freq.get(max_freq - 1, 0) == i:
            max_len = i + 1
    return max_len
```


",,
"```python
from collections import defaultdict

def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0

    value_indices = defaultdict(list)
    
    for i, value in enumerate(arr):
        value_indices[value].append(i)

    q = [0]
    visited = [False] * n
    visited[0] = True
    steps = 0

    while q:
        size = len(q)
        for _ in range(size):
            index = q.pop(0)
            
            if index == n - 1:
                return steps
            
            if index > 0 and not visited[index - 1]:
                q.append(index - 1)
                visited[index - 1] = True
                
            if index < n - 1 and not visited[index + 1]:
                q.append(index + 1)
                visited[index + 1] = True

            for neighbor in value_indices[arr[index]]:
                if not visited[neighbor]:
                    q.append(neighbor)
                    visited[neighbor] = True
            
            value_indices[arr[index]] = []

        steps += 1

    return -1
```

",,
"```python
def maxValueInStack(nums, k):
    n = len(nums)
    if k >= n:
        return -1

    max_val = float('-inf')
    for i in range(k+1):
        max_val = max(max_val, nums[i])
    return max_val
```

",,
"```python
def minSteps(s, t):
    s_Count = [0] * 26
    t_Count = [0] * 26
    for c in s: s_Count[ord(c) - ord('a')] += 1
    for c in t: t_Count[ord(c) - ord('a')] += 1
    res = 0
    for i in range(26):
        res += abs(s_Count[i] - t_Count[i])
    return res // 2
```

",,
"```python
from collections import defaultdict
from typing import List

class TweetCounts:

    def __init__(self):
        self.data = defaultdict(dict)

    def recordTweet(self, tweetName: str, time: int) -> None:
        if time not in self.data[tweetName]:
            self.data[tweetName][time] = 1
        else:
            self.data[tweetName][time] += 1

    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:
        step = 60 if freq == ""minute"" else 3600 if freq == ""hour"" else 86400
        chunks = [0] * ((endTime - startTime) // step + 1)

        if tweetName in self.data:
            for time, count in self.data[tweetName].items():
                chunk_index = (time - startTime) // step
                if 0 <= chunk_index < len(chunks):
                    chunks[chunk_index] += count

        return chunks
```

",,
"```python
from typing import List

def checkStraightLine(coordinates: List[List[int]]) -> bool:
    dx = coordinates[1][0] - coordinates[0][0]
    dy = coordinates[1][1] - coordinates[0][1]

    for x, y in coordinates[2:]:
        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):
            return False

    return True
```

",,
"```python
def balanced_string(s):
    n = len(s)
    freq_map = {}
    for c in s:
        freq_map[c] = freq_map.get(c, 0) + 1
    
    i = 0
    result = n
    for j in range(n):
        freq_map[s[j]] -= 1
        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in ""QWER""):
            result = min(result, j - i + 1)
            freq_map[s[i]] += 1
            i += 1
    
    return result
```

",,
"```python
from functools import lru_cache

class Job:
    def __init__(self, start, end, profit):
        self.start = start
        self.end = end
        self.profit = profit

def find_next_job(jobs, i):
    for j in range(i + 1, len(jobs)):
        if jobs[j].start >= jobs[i].end:
            return j
    return -1

@lru_cache(None)
def max_profit_helper(jobs, i):
    if i == -1:
        return 0

    next_job = find_next_job(jobs, i)
    incl_curr_job = jobs[i].profit + max_profit_helper(jobs, next_job)
    excl_curr_job = max_profit_helper(jobs, i - 1)
    
    return max(incl_curr_job, excl_curr_job)

def max_profit(startTime, endTime, profit):
    n = len(startTime)
    jobs = [Job(startTime[i], endTime[i], profit[i]) for i in range(n)]

    jobs.sort(key=lambda job: job.end)
    
    return max_profit_helper(tuple(jobs), n - 1)
```

",,
"```python
import heapq

def maxEvents(events: List[List[int]]) -> int:
    events.sort(key=lambda x: x[0])
    min_heap = []
    event_count, day = 0, 0

    for event in events:
        while min_heap and min_heap[0] < event[0]:
            heapq.heappop(min_heap)
        heapq.heappush(min_heap, event[1])
        event_count += 1
        day += 1

    return event_count
```


",,
"```python
from sortedcontainers import SortedSet

def winners_and_losers(matches):
    winners, losers = SortedSet(), SortedSet()

    for winner, loser in matches:
        winners.add(winner)
        losers.add(loser)

    return [list(winners), list(losers)]
```

",,
"```python
def min_moves_to_palindrome(s: str) -> int:
    moves = 0
    s = list(s)
    left, right = 0, len(s) - 1

    while left < right:
        if s[left] != s[right]:
            temp_right = right

            while s[left] != s[temp_right]:
                temp_right -= 1
            s.insert(right, s.pop(temp_right))
            moves += right - temp_right
        left += 1
        right -= 1

    return moves
```

",,
"```python
class Cashier:

    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):
        self.n = n
        self.discount = discount
        self.customer_count = 0
        self.prices_map = {products[i]: prices[i] for i in range(len(products))}

    def getBill(self, product: List[int], amount: List[int]) -> float:
        self.customer_count += 1
        total = sum(self.prices_map[product[i]] * amount[i] for i in range(len(product)))
        if self.customer_count % self.n == 0:
            total *= (100 - self.discount) / 100
        return total
```

",,
"```python
def find_pairs(z):
    pairs = []
    
    def f(x, y):
        return x + y
    
    for x in range(1, z+1):
        for y in range(1, z+1):
            if f(x, y) == z:
                pairs.append((x, y))
    return pairs
```

",,
"```python
def circular_permutation(n, start):
    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]
    return result
```


",,
"```python
def maxLength(arr):
    dp = ['']
    maxLen = 0

    for s in arr:
        if len(set(s)) < len(s): continue
        for i in range(len(dp) - 1, -1, -1):
            tmp = dp[i] + s
            if len(set(tmp)) == len(tmp):
                dp.append(tmp)
                maxLen = max(maxLen, len(tmp))
                
    return maxLen
```

",,
"```python
def tilingRectangle(n, m):
    if n > m:
        n, m = m, n
    if n == 1:
        return m
    if n == m:
        return 1

    res = float('inf')
    for a in range(1, n // 2 + 1):
        res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m))

    for b in range(1, m // 2 + 1):
        res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b))

    return res
```


",,
"```python
def findClosestDivisors(num):
    for i in range(int((num + 2) ** 0.5), 0, -1):
        if (num + 1) % i == 0:
            return [i, (num + 1) // i]
        if (num + 2) % i == 0:
            return [i, (num + 2) // i]
    return []
```

",,
"```python
from collections import defaultdict

def largest_multiple_of_three(digits):
    digits.sort(reverse=True)
    sum_digits = sum(digits)

    if sum_digits % 3 == 0:
        return '0' if digits[-1] == 0 else ''.join(map(str, digits))

    mod = defaultdict(list)
    for digit in digits:
        mod[digit % 3].append(digit)

    if sum_digits % 3 == 1:
        if mod[1]:
            mod[1].pop()
        else:
            mod[2].pop(), mod[2].pop()
    else:
        if mod[2]:
            mod[2].pop()
        else:
            mod[1].pop(), mod[1].pop()

    result = """".join(str(digit) for value in mod.values() for digit in value)
    result = """".join(sorted(result, reverse=True))

    return '0' if not result or result[0] == '0' else result
```


",,
"```python
def smallerNumbersThanCurrent(nums):
    result = []
    for i in range(len(nums)):
        count = 0
        for j in range(len(nums)):
            if i != j and nums[j] < nums[i]:
                count += 1
        result.append(count)
    return result
```

",,
"```python
def rankTeams(votes):
    n, m = len(votes), len(votes[0])
    count = [[0] * m for _ in range(26)]
    res = votes[0]

    for vote in votes:
        for j, team in enumerate(vote):
            count[ord(team) - ord('A')][j] += 1

    return ''.join(sorted(res, key=lambda x: (-count[ord(x) - ord('A')][:m], x)))
```


",,
"```python
def maxHeight(cuboids):
    cuboids = [sorted(cuboid) for cuboid in cuboids]
    cuboids.sort()

    n = len(cuboids)
    dp = [0] * n
    ans = 0

    for i, cuboid in enumerate(cuboids):
        dp[i] = cuboid[2]
        for j in range(i):
            if all(cuboids[j][k] <= cuboid[k] for k in range(3)):
                dp[i] = max(dp[i], dp[j] + cuboid[2])

        ans = max(ans, dp[i])

    return ans
```


",,
"```python
from collections import deque

def minCost(grid):
    m, n = len(grid), len(grid[0])
    cost = 0

    visited = [[1000000] * n for _ in range(m)]
    q = deque([(0, 0)])
    visited[0][0] = 0

    while q:
        y, x = q.popleft()
        if y == m - 1 and x == n - 1:
            cost = visited[y][x]
            break

        dx = [1, 0, -1, 0]
        dy = [0, 1, 0, -1]

        for dir in range(4):
            newY, newX = y + dy[dir], x + dx[dir]
            if 0 <= newY < m and 0 <= newX < n:
                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)
                if newCost < visited[newY][newX]:
                    visited[newY][newX] = newCost
                    q.append((newY, newX))

    return cost
```

",,
"```python
def numberOfSubarrays(nums, k):
    n = len(nums)
    result = count = 0
    odd_count = [0] * (n + 1)

    odd_count[0] = 1
    for num in nums:
        count += num % 2
        if count >= k:
            result += odd_count[count - k]
        odd_count[count] += 1

    return result
```

",,
"```python
def min_remove_to_make_valid(s: str) -> str:
    stk = []
    result = list(s)

    for i, ch in enumerate(s):
        if ch == '(':
            stk.append(i)
        elif ch == ')':
            if stk:
                stk.pop()
            else:
                result[i] = ''

    for i in stk:
        result[i] = ''

    return ''.join(result)
```


",,
"```python
from math import gcd
from functools import reduce

def is_good_array(nums):
    gcd_value = reduce(gcd, nums)
    return gcd_value == 1
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxSumBST(self, root: TreeNode) -> int:
        max_sum = [0]

        def dfs(node):
            if not node:
                return 1, 0, float(""inf""), float(""-inf"")

            l = dfs(node.left)
            r = dfs(node.right)

            if not l[0] or not r[0] or node.val <= l[3] or node.val >= r[2]:
                return 0, 0, 0, 0

            curr_sum = node.val + l[1] + r[1]
            max_sum[0] = max(max_sum[0], curr_sum)

            return 1, curr_sum, min(node.val, l[2]), max(node.val, r[3])

        dfs(root)
        return max_sum[0]
```


",,
"```python
def generateTheString(n: int) -> str:
    result = 'a' * n
    if n % 2 == 0:
        result = result[:-1] + 'b'
    return result
```

",,
"```python
def find_kth_palindrome(k, int_length):
    mid = (int_length + 1) // 2
    limit = 10 ** mid - 1

    i = 0
    while i <= limit:
        num = str(i)
        rev = num[::-1]
        if int_length % 2 != 0:
            rev = rev[1:]
        palindrome = int(num + rev)
        if palindrome > 0:
            k -= 1
        if k == 0:
            return palindrome
        i += 1
    return -1

def palindrome_queries(queries, int_length):
    return [find_kth_palindrome(query, int_length) for query in queries]
```


",,
"```python
def numOfMinutes(n, headID, manager, informTime):
    subordinates = [[] for _ in range(n)]
    for i in range(n):
        if manager[i] != -1:
            subordinates[manager[i]].append(i)
    return dfs(headID, subordinates, informTime)

def dfs(employee, subordinates, informTime):
    if informTime[employee] == 0:
        return 0
    max_time = 0
    for i in subordinates[employee]:
        max_time = max(max_time, dfs(i, subordinates, informTime))
    return max_time + informTime[employee]
```


",,
"```python
from collections import defaultdict

def dfs(node, parent, t, target, graph, prob, ans):
    if t == 0:
        if node == target:
            ans[0] += prob
        return

    has_child = False
    for neighbor in graph[node]:
        if neighbor != parent:
            has_child = True
            dfs(neighbor, node, t - 1, target, graph, prob / (len(graph[node]) - (1 if node != 1 else 0)), ans)

    if not has_child and node == target:
        ans[0] += prob

def frogPosition(n, edges, t, target):
    graph = defaultdict(list)
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    ans = [0.0]
    dfs(1, -1, t, target, graph, 1.0, ans)
    return ans[0]
```


",,
"```python
def reconstructMatrix(upper, lower, colsum):
    result = [[0] * len(colsum) for _ in range(2)]
    
    for i in range(len(colsum)):
        if colsum[i] == 2:
            result[0][i] = 1
            result[1][i] = 1
            upper -= 1
            lower -= 1
        elif colsum[i] == 1:
            if upper > lower:
                result[0][i] = 1
                upper -= 1
            else:
                result[1][i] = 1
                lower -= 1
        
        if upper < 0 or lower < 0:
            return []
    
    if upper > 0 or lower > 0:
        return []
    
    return result
```

",,
"```python
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(grid, x, y):
    n, m = len(grid), len(grid[0])
    grid[x][y] = 1
    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:
            dfs(grid, nx, ny)

def closedIsland(grid):
    n, m = len(grid), len(grid[0])
    for i in range(n):
        for j in range(m):
            if i == 0 or i == n - 1 or j == 0 or j == m - 1:
                if grid[i][j] == 0:
                    dfs(grid, i, j)
    res = 0
    for i in range(1, n - 1):
        for j in range(1, m - 1):
            if grid[i][j] == 0:
                dfs(grid, i, j)
                res += 1
    return res
```


",,
"```python
def get_max_score(word, score):
    return sum(score[ord(c) - ord('a')] for c in word)

def get_max_score_helper(words, score, letters, i):
    if i == len(words):
        return 0
    letters_copy = letters.copy()
    for c in words[i]:
        if letters_copy[c] == 0:
            return get_max_score_helper(words, score, letters, i + 1)
        letters_copy[c] -= 1
    return max(get_max_score(words[i], score) + get_max_score_helper(words, score, letters_copy, i + 1),
               get_max_score_helper(words, score, letters, i + 1))

def max_score_words(words, letters, score):
    letters_count = {}
    for letter in letters:
        letters_count[letter] = letters_count.get(letter, 0) + 1
    return get_max_score_helper(words, score, letters_count, 0)
```
",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        sortedNodes = []
        self.inorderTraversal(root, sortedNodes)
        return self.sortedArrayToBST(sortedNodes, 0, len(sortedNodes) - 1)

    def inorderTraversal(self, node: TreeNode, sortedNodes: list):
        if node is None: return
        self.inorderTraversal(node.left, sortedNodes)
        sortedNodes.append(node)
        self.inorderTraversal(node.right, sortedNodes)

    def sortedArrayToBST(self, sortedNodes: list, start: int, end: int) -> TreeNode:
        if start > end: return None
        mid = start + (end - start) // 2
        newNode = sortedNodes[mid]
        newNode.left = self.sortedArrayToBST(sortedNodes, start, mid - 1)
        newNode.right = self.sortedArrayToBST(sortedNodes, mid + 1, end)
        return newNode
```


",,
"```python
import heapq
from typing import List

def max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:
    engineers = sorted(zip(efficiency, speed), reverse=True)
    min_heap = []
    speed_sum = 0
    max_performance = 0

    for e, s in engineers:
        speed_sum += s
        heapq.heappush(min_heap, s)

        if len(min_heap) > k:
            speed_sum -= heapq.heappop(min_heap)

        max_performance = max(max_performance, speed_sum * e)

    return max_performance % (10**9 + 7)
```

",,
"```python
def findTheDistanceValue(arr1, arr2, d):
    distance = 0
    for a in arr1:
        found = True
        for b in arr2:
            if abs(a - b) <= d:
                found = False
                break
        if found:
            distance += 1
    return distance
```

",,
"```python
def shiftGrid(grid, k):
    m, n = len(grid), len(grid[0])
    k %= (m * n)
    res = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            idx = (i * n + j + k) % (m * n)
            res[idx // n][idx % n] = grid[i][j]
    return res
```


",,
"```python
def maxSumDivThree(nums):
    dp = [0, 0, 0]
    for num in nums:
        temp = dp[:]
        for s in temp:
            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)
    return dp[0]
```

",,
"```python
def sum_of_four_divisors(nums):
    total_sum = 0
    for num in nums:
        count = 0
        div_sum = 0
        i = 1
        while i * i <= num:
            if num % i == 0:
                count += 1 if i * i == num else 2
                div_sum += i + (num // i)
                if count > 4:
                    break
            i += 1
        if count == 4:
            total_sum += div_sum
    return total_sum
```

",,
"```python
def hasValidPath(grid):
    m, n = len(grid), len(grid[0])

    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]
    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]

    visited = [[False] * n for _ in range(m)]

    def dfs(i, j):
        if i == m - 1 and j == n - 1:
            return True

        visited[i][j] = True
        for dir in allowed[grid[i][j]]:
            x, y = i + directions[dir][0], j + directions[dir][1]
            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:
                if dfs(x, y):
                    return True
        return False

    return dfs(0, 0)
```

",,
"```python
def find_lucky(arr):
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    max_lucky = -1
    for num, count in freq.items():
        if num == count:
            max_lucky = max(max_lucky, num)
    return max_lucky
```

",,
"```python
def minTimeToVisitAllPoints(points: List[List[int]]) -> int:
    time = 0
    for i in range(1, len(points)):
        dx = abs(points[i][0] - points[i-1][0])
        dy = abs(points[i][1] - points[i-1][1])
        time += max(dx, dy)
    return time
```


",,
"```python
class UndergroundSystem:

    def __init__(self):
        self.check_in_info = dict()
        self.journey_data = dict()

    def check_in(self, id: int, station_name: str, t: int) -> None:
        self.check_in_info[id] = (station_name, t)

    def check_out(self, id: int, station_name: str, t: int) -> None:
        start_station, start_time = self.check_in_info[id]
        route = (start_station, station_name)
        duration = t - start_time
        if route not in self.journey_data:
            self.journey_data[route] = (0, 0)
        prev_duration, count = self.journey_data[route]
        self.journey_data[route] = (prev_duration + duration, count + 1)

    def get_average_time(self, start_station: str, end_station: str) -> float:
        route = (start_station, end_station)
        duration, count = self.journey_data[route]
        return duration / count
```

",,
"```python
from bisect import bisect_left

def suggestedProducts(products, searchWord):
    products.sort()
    result = []
    current_prefix = """"
    
    for letter in searchWord:
        current_prefix += letter
        index = bisect_left(products, current_prefix)
        suggestions = []
        
        for i in range(3):
            if index < len(products) and products[index].startswith(current_prefix):
                suggestions.append(products[index])
                index += 1
            else:
                break
        
        result.append(suggestions)
    
    return result
```

",,
"```python
def countLargestGroup(n: int) -> int:
    groups = [0] * 37
    largest_group_size = 0
    count_largest_groups = 0

    for i in range(1, n + 1):
        sum_of_digits = sum(map(int, str(i)))
        groups[sum_of_digits] += 1
        if groups[sum_of_digits] > largest_group_size:
            largest_group_size = groups[sum_of_digits]
            count_largest_groups = 1
        elif groups[sum_of_digits] == largest_group_size:
            count_largest_groups += 1

    return count_largest_groups
```

",,
"```python
def tictactoe(moves):
    grid = [[0] * 3 for _ in range(3)]
    player = 1
    for move in moves:
        r, c = move
        grid[r][c] = player
        if (all(grid[i][c] == player for i in range(3)) or
            all(grid[r][i] == player for i in range(3)) or
            (r == c and all(grid[i][i] == player for i in range(3))) or
            (r + c == 2 and all(grid[i][2 - i] == player for i in range(3)))):
            return 'A' if player == 1 else 'B'
        player = 3 - player
    
    return 'Draw' if len(moves) == 9 else 'Pending'
```


",,
"```python
def checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2):
    xClosest = max(x1, min(xCenter, x2))
    yClosest = max(y1, min(yCenter, y2))
    return (xCenter - xClosest) ** 2 + (yCenter - yClosest) ** 2 <= radius ** 2
```

",,
"```python
def countSquares(matrix: List[List[int]]) -> int:
    m, n, ans = len(matrix), len(matrix[0]), 0
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0:
                dp[i][j] = matrix[i][j]
            elif matrix[i][j]:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
            ans += dp[i][j]
    return ans
```

",,
"```python
def min_changes_to_divide_string(s, k):
    n = len(s)
    if n % k != 0:
        return -1
    chunk_count = n // k
    res = 0
    for i in range(k):
        counts = [0] * 26
        for j in range(i, n, k):
            counts[ord(s[j]) - ord('a')] += 1
        max_count = max(counts)
        res += chunk_count - max_count
    return res
```

",,
"```python
def num_steps(s: str) -> int:
    steps = 0
    carry = 0
    
    for c in reversed(s[1:]):
        bit = int(c)
        if bit and carry:
            carry = 1
            steps += 2
        elif bit or carry:
            carry ^= 1
            steps += 2
        else:
            steps += 1
            
    return steps + carry
```

",,
"```python
import heapq

def longest_diverse_string(a: int, b: int, c: int) -> str:
    result = """"
    pq = [(-a, 'a'), (-b, 'b'), (-c, 'c')]
    heapq.heapify(pq)
    
    while pq:
        first = heapq.heappop(pq)
        if not result or result[-1] != first[1]:
            result += first[1]
            first = (first[0] + 1, first[1])
            if first[0] < 0:
                heapq.heappush(pq, first)
        elif pq:
            second = heapq.heappop(pq)
            result += second[1]
            second = (second[0] + 1, second[1])
            if second[0] < 0:
                heapq.heappush(pq, second)
            if first[0] < 0:
                heapq.heappush(pq, first)
        else:
            break
            
    return result
```

",,
"```python
def stoneGameIII(stoneValue):
    n = len(stoneValue)
    dp = [float(""-inf"")] * (n + 1)
    dp[n] = 0
    
    for i in range(n - 1, -1, -1):
        curr = 0
        for j in range(3):
            if i + j < n:
                curr += stoneValue[i + j]
                dp[i] = max(dp[i], curr - dp[i + j + 1])
                
    return ""Tie "" if dp[0] == 0 else ""Alice "" if dp[0] > 0 else ""Bob ""
```


",,
"```python
import math

def smallest_divisor(nums, threshold):
    left, right = 1, 10**6
    while left < right:
        mid = (left + right) // 2
        total = sum(math.ceil(n / mid) for n in nums)
        if total > threshold:
            left = mid + 1
        else:
            right = mid
    return left
```

",,
"```python
from collections import deque

def minNumberOfFlips(mat):
    m, n = len(mat), len(mat[0])
    steps = 0
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]

    def encode(i, j):
        return i * n + j

    while True:
        flipped = 0
        que = deque()

        for i in range(m):
            for j in range(n):
                if mat[i][j] == 1:
                    que.append(encode(i, j))

        while que:
            cur = que.popleft()
            cur_i, cur_j = divmod(cur, n)

            for dx, dy in dirs:
                ni, nj = cur_i + dx, cur_j + dy
                if 0 <= ni < m and 0 <= nj < n:
                    mat[ni][nj] ^= 1
                    flipped += 1

        if flipped == 0:
            break
        steps += flipped

    for row in mat:
        if any(cell == 1 for cell in row):
            return -1

    return steps
```

",,
"```python
def entity_parser(text: str) -> str:
    entities = {
        ""&quot;"": ""\"""",
        ""&apos;"": ""'"",
        ""&amp;"": ""&"",
        ""&gt;"": "">"",
        ""&lt;"": ""<"",
        ""&frasl;"": ""/"",
    }
    
    result = []
    current_entity = []
    in_entity = False
    
    for c in text:
        if in_entity:
            current_entity.append(c)
            if c == ';':
                entity = ''.join(current_entity)
                if entity in entities:
                    result.append(entities[entity])
                else:
                    result.extend(current_entity)
                in_entity = False
                current_entity.clear()
        else:
            if c == '&':
                in_entity = True
                current_entity.append(c)
            else:
                result.append(c)

    return ''.join(result)
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getDecimalValue(head: ListNode) -> int:
    num = 0
    while head:
        num = (num << 1) | head.val
        head = head.next
    return num
```

",,
"```python
def maxSideLength(mat, threshold):
    m, n = len(mat), len(mat[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ans = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]
            k = ans + 1
            if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold:
                ans += 1

    return ans
```

",,
"```python
from collections import deque

def shortestPath(grid, k):
    m, n = len(grid), len(grid[0])
    queue = deque([(0, 0, 0, k)])
    visited = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)]

    while queue:
        x, y, step, remaining_k = queue.popleft()

        if x == m - 1 and y == n - 1:
            return step
        if visited[x][y][remaining_k]:
            continue
        visited[x][y][remaining_k] = True

        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx < m and 0 <= ny < n:
                if grid[nx][ny] == 1 and remaining_k > 0:
                    queue.append((nx, ny, step + 1, remaining_k - 1))
                elif grid[nx][ny] == 0:
                    queue.append((nx, ny, step + 1, remaining_k))

    return -1
```

",,
"```python
class Solution:
    def generate_strings(self, n: int, current: str, strings: list) -> None:
        if n == 0:
            strings.append(current)
            return
        for c in ""abc"":
            if not current or current[-1] != c:
                self.generate_strings(n - 1, current + c, strings)

    def getHappyString(self, n: int, k: int) -> str:
        strings = []
        self.generate_strings(n, """", strings)
        return strings[k - 1] if k <= len(strings) else """"
```

",,
"```python
def numDecodings(s: str, k: int) -> int:
    n = len(s)
    dp = [0] * (n + 1)
    dp[n] = 1
    MOD = 1000000007

    for i in range(n - 1, -1, -1):
        num = 0
        for j in range(i, n):
            num = num * 10 + int(s[j])
            if num >= 1 and num <= k:
                dp[i] = (dp[i] + dp[j + 1]) % MOD
            if num > k:
                break

    return dp[0]
```

",,
"```python
from collections import deque

def reformat(s: str) -> str:
    letters, digits = deque(), deque()

    for c in s:
        if c.isalpha():
            letters.append(c)
        else:
            digits.append(c)

    if abs(len(letters) - len(digits)) > 1:
        return """"

    result = []
    use_letter = len(letters) > len(digits)

    while letters or digits:
        if use_letter:
            result.append(letters.popleft())
        else:
            result.append(digits.popleft())
        use_letter = not use_letter

    return ''.join(result)
```

",,
"```python
from collections import defaultdict
from typing import List

def displayTable(orders: List[List[str]]) -> List[List[str]]:
    tables = defaultdict(lambda: defaultdict(int))
    foodSet = set()

    for order in orders:
        tableNumber = int(order[1])
        foodItem = order[2]
        tables[tableNumber][foodItem] += 1
        foodSet.add(foodItem)

    foodList = sorted(foodSet)
    result = [[""Table""] + foodList]

    for tableNumber, table in sorted(tables.items()):
        row = [str(tableNumber)]
        row.extend(str(table[foodItem]) for foodItem in foodList)
        result.append(row)

    return result
```

",,
"```python
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    counter = [0] * 5
    frogs = max_frogs = 0
    for ch in croakOfFrogs:
        idx = 'croak'.index(ch)
        counter[idx] += 1
        if idx == 0:
            max_frogs = max(max_frogs, frogs + 1)
            frogs += 1
        else:
            counter[idx - 1] -= 1
            if counter[idx - 1] < 0:
                return -1
            if idx == 4:
                frogs -= 1
    return max_frogs if all(count == counter[0] for count in counter) else -1
```

",,
"```python
def waysToBuildArray(n, m, k):
    mod = 10**9 + 7
    dp = [[0] * (k+1) for _ in range(n+1)]
    dp[0][0] = 1
    for i in range(1, n+1):
        for j in range(k+1):
            for x in range(1, m+1):
                if j < i * (x-1):
                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod
    return dp[n][k]
```

",,
"```python
from collections import Counter

def is_possible_divide(nums: List[int], k: int) -> bool:
    counts = Counter(nums)
    
    for key in sorted(counts):
        if counts[key] > 0:
            for i in range(k-1, -1, -1):
                if counts[key+i] < counts[key]:
                    return False
                counts[key+i] -= counts[key]
    
    return True
```

",,
"```python
def max_substring_occurrences(s: str, k: int) -> int:
    freq = {}
    res = 0
    for c in s:
        freq[c] = freq.get(c, 0) + 1
        if len(freq) <= k:
            res = max(res, freq[c])
    return 0 if len(freq) > k else res
```


",,
"```python
from collections import deque

def maxCandies(status, candies, keys, containedBoxes, initialBoxes):
    max_candies = 0
    visited = set()
    to_process = deque(initialBoxes)

    while to_process:
        box = to_process.popleft()

        if box in visited:
            continue

        visited.add(box)

        if status[box]:
            max_candies += candies[box]
            for key in keys[box]:
                status[key] = 1
                if key in visited:
                    to_process.append(key)
            for contained in containedBoxes[box]:
                to_process.append(contained)
        else:
            to_process.append(box)

    return max_candies
```

",,
"```python
def maxSum(nums, k):
    n = len(nums)
    dp = [0] * (n + 1)
    pq = []
    sum_ = 0

    for i in range(n):
        if i >= k:
            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq
        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap
        dp[i + 1] = max(dp[i], nums[i] - pq[0])
        sum_ = max(sum_, dp[i + 1])

    return sum_
```

",,
"```python
def sum_zero(n):
    res = []
    for i in range(1, (n // 2) + 1):
        res.append(i)
        res.append(-i)
    if n % 2 != 0:
        res.append(0)
    return res
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder(root):
    output = []
    stack = []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        output.append(current.val)
        current = current.right

    return output

def getAllElements(root1, root2):
    tree1 = inorder(root1)
    tree2 = inorder(root2)
    result = []
    i, j = 0, 0

    while i < len(tree1) or j < len(tree2):
        if i < len(tree1) and (j >= len(tree2) or tree1[i] <= tree2[j]):
            result.append(tree1[i])
            i += 1
        else:
            result.append(tree2[j])
            j += 1

    return result
```

",,
"```python
def canReach(arr: List[int], start: int) -> bool:
    if 0 <= start < len(arr) and arr[start] >= 0:
        if arr[start] == 0:
            return True
        
        jump = arr[start]
        arr[start] = -arr[start]
        return canReach(arr, start + jump) or canReach(arr, start - jump)
    return False
```

",,
"```python
def is_solvable(words, result):
    return sum(words.values()) % 10 == result % 10
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidSequence(root, arr, index=0):
    if not root or index >= len(arr) or arr[index] != root.val:
        return False
    if not root.left and not root.right:
        return index == len(arr) - 1
    return isValidSequence(root.left, arr, index + 1) or isValidSequence(root.right, arr, index + 1)
```

",,
"```python
from collections import defaultdict

def find_ancestors(node, adj_list, visited, ans):
    if visited[node]:
        return
    visited[node] = True
    for ancestor in adj_list[node]:
        ans.append(ancestor)
        find_ancestors(ancestor, adj_list, visited, ans)

def find_ancestors_in_dag(n, edges):
    adj_list = defaultdict(list)
    for edge in edges:
        adj_list[edge[1]].append(edge[0])
    ans = []
    for i in range(n):
        visited = [False] * n
        ancestors = []
        find_ancestors(i, adj_list, visited, ancestors)
        ans.append(sorted(ancestors))
    return ans
```


",,
"```python
def max_diff(num):
    a, b = -1, -1
    num_str = str(num)
    for c in num_str:
        if a == -1 and c != '9':
            a = int(c)
        if b == -1 and c > '1':
            b = int(c)
        if a != -1 and b != -1:
            break
            
    result = 0
    for c in num_str:
        if int(c) == a:
            result = result * 10 + 9
        elif int(c) == b:
            result = result * 10 + (1 if c == num_str[0] else 0)
        else:
            result = result * 10 + int(c)
    return result - num
```


",,
"```python
class Encrypter:
    def __init__(self, keys, values, dictionary):
        self.encrypt_map = dict(zip(keys, values))
        self.decrypt_map = dict(zip(values, keys))
        self.dictionary = set(dictionary)
    
    def encrypt(self, original):
        result = []
        for c in original:
            if c not in self.encrypt_map:
                return """"
            result.append(self.encrypt_map[c])
        return """".join(result)

    def decrypt(self, encrypted):
        result = []
        for i in range(0, len(encrypted), 2):
            temp = encrypted[i:i+2]
            if temp not in self.decrypt_map:
                return """"
            result.append(self.decrypt_map[temp])
        
        decrypted = """".join(result)
        if decrypted not in self.dictionary:
            return """"
        return decrypted
```

",,
"```python
def freqAlphabets(s):
    result = []
    i = 0
    while i < len(s):
        if i + 2 < len(s) and s[i + 2] == '#':
            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))
            i += 3
        else:
            result.append(chr(ord('a') + int(s[i]) - 1))
            i += 1
    return ''.join(result)
```

",,
"```python
from collections import deque
from collections import defaultdict

def watched_videos_by_friends(watched_videos, friends, id, level):
    visited = set()
    q = deque([(id, 0)])
    video_freq = defaultdict(int)

    while q:
        current_id, current_level = q.popleft()

        if current_level == level:
            for video in watched_videos[current_id]:
                video_freq[video] += 1
        elif current_level < level:
            for friend_id in friends[current_id]:
                if friend_id not in visited:
                    visited.add(friend_id)
                    q.append((friend_id, current_level + 1))

    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))

    return result
```

",,
"```python
def min_steps_to_make_palindrome(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n - 2, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]
```

",,
"```python
from collections import deque
def longestSubarray(nums, limit):
    max_deque = deque()
    min_deque = deque()
    left, right, longest = 0, 0, 0
    
    while right < len(nums):
        while max_deque and nums[right] > max_deque[-1]: max_deque.pop()
        while min_deque and nums[right] < min_deque[-1]: min_deque.pop()
        
        max_deque.append(nums[right])
        min_deque.append(nums[right])
        
        while max_deque[0] - min_deque[0] > limit:
            if max_deque[0] == nums[left]: max_deque.popleft()
            if min_deque[0] == nums[left]: min_deque.popleft()
            left += 1
        
        longest = max(longest, right - left + 1)
        right += 1
    
    return longest
```

",,
"```python
import heapq

def kthSmallest(mat, k):
    m, n = len(mat), len(mat[0])
    minHeap = [(mat[0][0], 0, 0)]

    visited = set([(0, 0)])
    count = 0

    while minHeap:
        cur = heapq.heappop(minHeap)
        sum, row, col = cur

        count += 1
        if count == k:
            return sum

        if row + 1 < m and (row + 1, col) not in visited:
            visited.add((row + 1, col))
            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row + 1][col], row + 1, col))
        
        if col + 1 < n and (row, col + 1) not in visited:
            visited.add((row, col + 1))
            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row][col + 1], row, col + 1))

    return -1
```

",,
"```python
def build_array(target, n):
    result = []
    current = 1
    for num in target:
        while current < num:
            result.append(""Push "")
            result.append(""Pop "")
            current += 1
        result.append(""Push "")
        current += 1
    return result
```

",,
"```python
def make_connected(n, connections):
    adj_list = [[] for _ in range(n)]
    visited = [False] * n
    components = 0
    extra_edges = 0

    for a, b in connections:
        adj_list[a].append(b)
        adj_list[b].append(a)

    for i in range(n):
        if not visited[i]:
            components += 1
            stack = [i]

            while stack:
                current = stack.pop()

                if not visited[current]:
                    visited[current] = True

                    for neighbor in adj_list[current]:
                        if not visited[neighbor]:
                            stack.append(neighbor)
                        else:
                            extra_edges += 1

    extra_needed = components - 1

    if extra_edges >= extra_needed:
        return extra_needed

    return -1
```


",,
"```python
def minimum_distance(word: str) -> int:
    def dp(first: int, second: int, pos: int) -> int:
        if pos == len(word): return 0
        
        ans = float('inf')
        for i in [first, second]:
            if i != -1:
                dx = abs(ord(word[pos]) - ord(word[i])) % 6
                dy = abs(ord(word[pos]) - ord(word[i])) // 6
                ans = min(ans, min(dx, dy) * 2 + max(dx, dy))
        ans += dp(first, second, pos + 1)

        if first == -1 or second == -1:
            ans = min(ans, dp(pos if first == -1 else first, ord(word[pos]), pos + 1))

        return ans
    
    return dp(-1, -1, 0)
```


",,
"```python
def number_of_steps(num):
    steps = 0
    while num:
        steps += 1 if num % 2 == 0 else 2
        num >>= 1
    return steps - 1
```

",,
"```python
def angleClock(hour: int, minutes: int) -> float:
    minute_angle = 6 * minutes
    hour_angle = 30 * hour + 0.5 * minutes
    angle = abs(hour_angle - minute_angle)
    return min(angle, 360 - angle)
```

",,
"```python
def minJumps(arr):
    n = len(arr)
    maxReach = arr[0]
    step = arr[0]
    jumps = 1

    if n == 1:
        return 0

    for i in range(1, n):
        if i == n - 1:
            return jumps

        maxReach = max(maxReach, i + arr[i])

        step -= 1

        if step == 0:
            jumps += 1
            step = maxReach - i

    return -1
```

",,
"```python
def maximum69Number(num: int) -> int:
    num_str = list(str(num))
    for i, c in enumerate(num_str):
        if c == '6':
            num_str[i] = '9'
            break
    return int(''.join(num_str))
```

",,
"```python
def largestNumber(cost, target):
    dp = ["""" for _ in range(target + 1)]
    dp[0] = """"

    for i in range(9):
        for j in range(cost[i], target + 1):
            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \
               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):
                dp[j] = dp[j - cost[i]] + str(i + 1)

    return dp[target] if dp[target] else ""0""
```

",,
"```python
def removeLeafNodes(root, target):
    if not root:
        return None
    root.left = removeLeafNodes(root.left, target)
    root.right = removeLeafNodes(root.right, target)
    if not root.left and not root.right and root.val == target:
        return None
    return root
```


",,
"```python
def min_taps(n, ranges):
    intervals = [0] * (n + 1)
    for i in range(n + 1):
        left = max(0, i - ranges[i])
        right = min(n, i + ranges[i])
        intervals[left] = max(intervals[left], right - left)

    position, total_taps, max_reach = 0, 0, 0
    while position < n:
        max_reach = max(max_reach, position + intervals[position])
        if max_reach == position:
            return -1
        position = max_reach
        total_taps += 1

    return total_taps
```

",,
"```python
from typing import List

def peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:
    result = []
    companySets = [set(companies) for companies in favoriteCompanies]

    for i, companies in enumerate(companySets):
        isSubset = False
        for j, otherCompanies in enumerate(companySets):
            if i != j and companies.issubset(otherCompanies):
                isSubset = True
                break
        if not isSubset:
            result.append(i)

    return result
```

",,
"```python
def numPoints(darts, r):
    n = len(darts)
    result = 1
    
    for i in range(n):
        for j in range(n):
            cnt = 0
            for k in range(n):
                dx = darts[i][0] - darts[k][0]
                dy = darts[i][1] - darts[k][1]
                if (dx * dx + dy * dy) ** 0.5 <= r:
                    cnt += 1
                    
            if cnt > result:
                result = cnt
                
    return result
```

",,
"```python
def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):
    def custom_compare(a, b):
        if a[1] == b[1]:
            return b[0] - a[0]
        return b[1] - a[1]

    filtered_restaurants = [
        r for r in restaurants
        if (vegan_friendly == 0 or r[2] == vegan_friendly) and r[3] <= max_price and r[4] <= max_distance
    ]

    filtered_restaurants.sort(key=lambda r: (r[1], r[0]), reverse=True)

    return [r[0] for r in filtered_restaurants]
```

",,
"```python
def findTheCity(n, edges, distanceThreshold):
    INF = float(""inf"")
    dist = [[INF] * n for _ in range(n)]

    for i in range(n):
        dist[i][i] = 0

    for fr, to, w in edges:
        dist[fr][to] = dist[to][fr] = w

    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    res, minReachable = -1, n + 1
    for i in range(n):
        cnt = sum(1 for d in dist[i] if d <= distanceThreshold)
        if cnt <= minReachable:
            minReachable = cnt
            res = i

    return res
```


",,
"```python
def minDifficulty(jobDifficulty, d):
    n = len(jobDifficulty)
    if n < d: return -1
    dp = [[float(""inf"")] * n for _ in range(d)]

    dp[0][0] = jobDifficulty[0]
    for i in range(1, n):
        dp[0][i] = max(dp[0][i-1], jobDifficulty[i])

    for i in range(1, d):
        for j in range(i, n):
            maxD = jobDifficulty[j]
            for k in range(j, i - 1, -1):
                maxD = max(maxD, jobDifficulty[k])
                dp[i][j] = min(dp[i][j], dp[i-1][k-1] + maxD)

    return dp[d-1][n-1]
```


",,
"```python
def sortByBits(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))
```


",,
"```python
def numberOfSubstrings(s: str) -> int:
    res, i, count = 0, 0, [0, 0, 0]
    
    for j, ch in enumerate(s):
        count[ord(ch) - ord('a')] += 1
        
        while count[0] > 0 and count[1] > 0 and count[2] > 0:
            count[ord(s[i]) - ord('a')] -= 1
            i += 1
            
        res += i
    
    return res
```

",,
"```python
def countOrders(n: int) -> int:
    MOD = 10**9 + 7
    ans = 1
    for i in range(1, n + 1):
        ans = ans * (2 * i - 1) * i % MOD
    return ans
```

",,
"```python
def checkIfPrerequisite(numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    adj_matrix = [[False] * numCourses for _ in range(numCourses)]
    for pre in prerequisites:
        adj_matrix[pre[0]][pre[1]] = True

    for k in range(numCourses):
        for i in range(numCourses):
            for j in range(numCourses):
                adj_matrix[i][j] = adj_matrix[i][j] or (adj_matrix[i][k] and adj_matrix[k][j])

    return [adj_matrix[query[0]][query[1]] for query in queries]
```


",,
"```python
from typing import List
import heapq

def kWeakestRows(mat: List[List[int]], k: int) -> List[int]:
    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]
    heapq.heapify(soldier_rows)
    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]
```


",,
"```python
from collections import Counter

def minSetSize(arr):
    count = Counter(arr)
    freq = list(count.values())
    freq.sort(reverse=True)

    removed, setSize = 0, 0
    for f in freq:
        removed += f
        setSize += 1
        if removed * 2 >= len(arr):
            return setSize

    return 0
```


",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return 0
            return node.val + dfs(node.left) + dfs(node.right)

        def dfs2(node, half):
            nonlocal result

            if not node:
                return 0
            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)
            result = max(result, (total - cur_sum) * cur_sum)
            return cur_sum

        total = dfs(root)
        result = 0
        dfs2(root, total / 2)
        return result % (10**9 + 7)
```

",,
"```python
def maxJumps(arr, d):
    n = len(arr)
    dp = [1] * n

    def helper(idx):
        if dp[idx] > 1:
            return dp[idx]
        maximum = 1
        for i in range(1, d + 1):
            if idx + i < n and arr[idx] <= arr[idx + i]:
                break
            if idx + i < n:
                maximum = max(maximum, 1 + helper(idx + i))

            if idx - i >= 0 and arr[idx] <= arr[idx - i]:
                break
            if idx - i >= 0:
                maximum = max(maximum, 1 + helper(idx - i))
        
        dp[idx] = maximum
        return maximum

    for i in range(n):
        helper(i)

    return max(dp)
```


",,
"```python
from math import factorial

def count_combinations(balls, combinations, curr_ball):
    total_combinations = 1
    for i in range(curr_ball):
        total_combinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]))

    return total_combinations

def dfs(balls, combinations, curr_ball):
    if curr_ball == len(balls):
        if combinations[-1] == combinations[0]:
            return count_combinations(balls, combinations, curr_ball)
        else:
            return 0

    result = 0
    for i in range(balls[curr_ball] + 1):
        combinations.append(i)
        result += dfs(balls, combinations, curr_ball + 1)
        combinations.pop()

    return result

def get_probability(balls):
    sum_balls = sum(balls)

    total_combinations = 1
    for ball in balls:
        total_combinations *= factorial(ball)

    combinations = []
    return dfs(balls, combinations, 0) / total_combinations
```

",,
"```python
def min_steps(s, t):
    count_s = [0] * 26
    count_t = [0] * 26
    steps = 0
    
    for c in s:
        count_s[ord(c) - ord('a')] += 1
    for c in t:
        count_t[ord(c) - ord('a')] += 1
    
    for i in range(26):
        steps += abs(count_s[i] - count_t[i])
    
    return steps // 2
```

",,
"```python
from collections import defaultdict
from typing import List

class TweetCounts:

    def __init__(self):
        self.tweet_records = defaultdict(lambda: defaultdict(int))

    def recordTweet(self, tweetName: str, time: int) -> None:
        self.tweet_records[tweetName][time] += 1

    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:
        if freq == ""minute"":
            interval = 60
        elif freq == ""hour"":
            interval = 3600
        else:
            interval = 86400

        result = [0] * ((endTime - startTime) // interval + 1)
        for time, count in self.tweet_records[tweetName].items():
            if startTime <= time <= endTime:
                result[(time - startTime) // interval] += count

        return result
```


",,
"```python
def maxStudents(seats):
    m, n = len(seats), len(seats[0])
    valid_rows = [0] * m
    max_valid = (1 << n) - 1
    for i in range(m):
        state = 0
        for j in range(n):
            state |= (seats[i][j] == '.') << j
        valid_rows[i] = state

    memo = [[-1] * (1 << n) for _ in range(m)]
    return dfs(0, 0, valid_rows, m, n, max_valid, memo)

def dfs(row_index, prev_state, valid_rows, m, n, max_valid, memo):
    if row_index == m:
        return 0

    if memo[row_index][prev_state] != -1:
        return memo[row_index][prev_state]

    max_students = 0
    for cur_state in range(max_valid + 1):
        if (cur_state & valid_rows[row_index]) != cur_state:
            continue
        if cur_state & (cur_state << 1):
            continue
        if cur_state & (prev_state << 1) or prev_state & (cur_state << 1):
            continue

        max_students = max(max_students, dfs(row_index + 1, cur_state, valid_rows, m, n, max_valid, memo) + bin(cur_state).count('1'))

    memo[row_index][prev_state] = max_students
    return max_students
```

",,
"```python
from collections import OrderedDict

def sortString(s: str) -> str:
    freq_map = OrderedDict(sorted({c: s.count(c) for c in set(s)}.items()))
    result = []

    while freq_map:
        for key in list(freq_map.keys()):
            result.append(key)
            freq_map[key] -= 1

            if freq_map[key] == 0:
                del freq_map[key]

        for key in list(reversed(freq_map.keys())):
            result.append(key)
            freq_map[key] -= 1

            if freq_map[key] == 0:
                del freq_map[key]

    return """".join(result)
```

",,
"```python
def findTheLongestSubstring(s: str) -> int:
    pos = {-1: 0}
    ans = cur = 0
    for i, c in enumerate(s):
        cur ^= 1 << (""aeiou"".find(c) + 1) >> 1
        if cur not in pos:
            pos[cur] = i + 1
        ans = max(ans, i + 1 - pos[cur])
    return ans
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def longestZigZag(root: TreeNode) -> int:
    maxLen = [0]
    
    def longestZigZagUtil(root, left):
        if not root:
            return -1

        leftZig = longestZigZagUtil(root.left, True)
        rightZig = longestZigZagUtil(root.right, False)

        maxLen[0] = max(maxLen[0], max(leftZig, rightZig) + 1)
        return rightZig + 1 if left else leftZig + 1

    longestZigZagUtil(root, True)
    longestZigZagUtil(root, False)
    return maxLen[0]
```


",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def maxSumBST(root):
    def helper(node):
        if not node:
            return float('inf'), float('-inf'), 0, True

        left_min, left_max, left_sum, is_left_bst = helper(node.left)
        right_min, right_max, right_sum, is_right_bst = helper(node.right)

        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:
            sum_ = node.val + left_sum + right_sum
            max_sum[0] = max(max_sum[0], sum_)
            return min(node.val, left_min), max(node.val, right_max), sum_, True

        return 0, 0, 0, False

    max_sum = [0]
    helper(root)
    return max_sum[0]
```

",,
"```python
def countNegatives(grid):
    m, n, count, i, j = len(grid), len(grid[0]), 0, 0, len(grid[0]) - 1
    while i < m and j >= 0:
        if grid[i][j] < 0:
            count += j + 1
            i += 1
        else:
            j -= 1
    return count
```

",,
"```python
class ProductOfNumbers:
    def __init__(self):
        self.products = [1]

    def add(self, num: int) -> None:
        if num == 0:
            self.products = [1]
        else:
            self.products.append(self.products[-1] * num)

    def getProduct(self, k: int) -> int:
        if k >= len(self.products):
            return 0
        else:
            return self.products[-1] // self.products[-k - 1]
```


",,
"```python
def max_events(events):
    events.sort(key=lambda x: x[1])

    count = 0
    last_day = -1

    for event in events:
        if event[0] > last_day:
            count += 1
            last_day = event[1]

    return count
```

",,
"```python
def runningSum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums
```

",,
"```python
from collections import Counter
import heapq

def findLeastNumOfUniqueInts(arr, k):
    count = Counter(arr)
    pq = list(count.values())
    heapq.heapify(pq)
    while k > 0:
        k -= heapq.heappop(pq)
    return len(pq) if k == 0 else len(pq) + 1
```

",,
"```python
def smallerNumbersThanCurrent(nums):
    result = [0] * len(nums)
    for i in range(len(nums)):
        for j in range(len(nums)):
            if nums[j] < nums[i]:
                result[i] += 1
    return result
```

",,
"```python
def rank_teams(votes):
    teams = len(votes[0])
    ranks = [[0] * teams for _ in range(26)]

    for vote in votes:
        for i in range(teams):
            ranks[ord(vote[i]) - ord('A')][i] += 1

    result = list(votes[0])
    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))
    return ''.join(result)
```


",,
"```python
from collections import deque

def minCost(grid):
    def dfs(r, c, d):
        if 0 <= r < m and 0 <= c < n and d < cost[r][c]:
            cost[r][c] = d
            q.append((r, c))

    m, n = len(grid), len(grid[0])
    cost = [[1e6] * n for _ in range(m)]

    q = deque()
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    dfs(0, 0, 0)

    while q:
        r, c = q.popleft()
        for i, (dr, dc) in enumerate(directions):
            dfs(r + dr, c + dc, cost[r][c] + (grid[r][c] != i + 1))

    return cost[-1][-1]
```

",,
"```python
def findTheDistanceValue(arr1, arr2, d):
    count = 0
    for i in arr1:
        valid = True
        for j in arr2:
            if abs(i - j) <= d:
                valid = False
                break
        if valid:
            count += 1
    return count
```

",,
"```python
def maxNumberOfFamilies(n, reservedSeats):
    rows = {}
    for seat in reservedSeats:
        rows[seat[0]] = rows.get(seat[0], 0) | (1 << (seat[1] - 1))
    
    max_groups = (n - len(rows)) * 2
    for row_mask in rows.values():
        seats = ~(row_mask | (row_mask >> 1) | (row_mask >> 2) | (row_mask >> 3)) & 0x3FF
        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0
        
    return max_groups
```

",,
"```python
def get_power(x):
    steps = 0
    while x != 1:
        if x % 2 == 0:
            x //= 2
        else:
            x = 3 * x + 1
        steps += 1
    return steps

def sort_by_power(lo, hi, k):
    nums = [(get_power(i), i) for i in range(lo, hi + 1)]
    nums.sort()
    return nums[k - 1][1]
```

",,
"```python
def max_size_slices(slices):
    def max_sum(slices, start, end, n, memo):
        if n == 0:
            return 0
        if end - start + 1 < n * 2:
            return float('-inf')
        if memo[start][n] != -1:
            return memo[start][n]

        pick = max_sum(slices, start + 2, end, n - 1, memo) + slices[start]
        not_pick = max_sum(slices, start + 1, end, n, memo)

        memo[start][n] = max(pick, not_pick)
        return memo[start][n]

    n = len(slices) // 3
    memo1 = [[-1] * (n + 1) for _ in range(len(slices))]
    memo2 = [[-1] * (n + 1) for _ in range(len(slices))]

    return max(max_sum(slices, 0, len(slices) - 1, n, memo1),
               max_sum(slices, 1, len(slices), n, memo2))
```


",,
"```python
def generate_the_string(n: int) -> str:
    if n % 2 == 0:
        return 'a' * (n - 1) + 'b'
    else:
        return 'a' * n
```

",,
"```python
def count_prefix_aligned(flips):
    count = 0
    for i in range(len(flips)):
        if flips[i] == i + 1:
            count += 1
    return count
```

",,
"```python
from collections import deque

def numOfMinutes(n, headID, manager, informTime):
    subordinates = {i: [] for i in range(n)}
    for i in range(n):
        if manager[i] != -1:
            subordinates[manager[i]].append(i)

    queue = deque([(headID, 0)])
    totalTime = 0

    while queue:
        current, time = queue.popleft()
        totalTime = max(totalTime, time)
        for sub in subordinates[current]:
            queue.append((sub, time + informTime[current]))

    return totalTime
```


",,
"```python
from collections import defaultdict

def frogPosition(n, edges, t, target):
    graph = defaultdict(list)
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    return dfs(1, -1, t, target, graph)

def dfs(node, parent, t, target, graph):
    if t == 0:
        return 1.0 if node == target else 0.0
    probability = 0.0
    for neighbor in graph[node]:
        if neighbor != parent:
            probability += dfs(neighbor, node, t - 1, target, graph)
    return probability / (len(graph[node]) - (0 if parent == -1 else 1))
```


",,
"```python
from collections import deque

def minNumberOfSemesters(n, relations, k):
    indegree = [0] * (n + 1)
    graph = [[] for _ in range(n + 1)]

    for prev_course, next_course in relations:
        graph[prev_course].append(next_course)
        indegree[next_course] += 1

    semesters = 0
    while n > 0:
        zero_indegree = deque()
        for i in range(1, len(indegree)):
            if indegree[i] == 0:
                zero_indegree.append(i)
                indegree[i] = -1

        courses = 0
        while zero_indegree and courses < k:
            curr_course = zero_indegree.popleft()
            n -= 1

            for next_course in graph[curr_course]:
                indegree[next_course] -= 1
            courses += 1
        semesters += 1
    return semesters
```

",,
"```python
def lucky_numbers(matrix):
    m, n = len(matrix), len(matrix[0])
    lucky_numbers = []

    for i in range(m):
        min_row = min(matrix[i])
        min_row_idx = matrix[i].index(min_row)
        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))

        if is_lucky:
            lucky_numbers.append(min_row)

    return lucky_numbers
```

",,
"```python
def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
    if original is None:
        return None
    if original is target:
        return cloned

    left = self.getTargetCopy(original.left, cloned.left, target)
    return left if left else self.getTargetCopy(original.right, cloned.right, target)
```

",,
"```python
import heapq

def max_performance(n, k, speed, efficiency):
    engineers = sorted(zip(efficiency, speed), reverse=True)

    result = 0
    sum_speed = 0
    min_heap = []
    for e, s in engineers:
        if len(min_heap) >= k:
            sum_speed -= heapq.heappop(min_heap)

        heapq.heappush(min_heap, s)
        sum_speed += s
        result = max(result, e * sum_speed)

    return result % (10**9 + 7)
```

",,
"```python
def countLargestGroup(n: int) -> int:
    freq = [0] * 37
    max_group_size = 0
    max_group_count = 0
    
    for i in range(1, n + 1):
        _sum = sum(map(int, str(i)))
        freq[_sum] += 1
        max_group_size = max(max_group_size, freq[_sum])
    
    for count in freq:
        if count == max_group_size:
            max_group_count += 1

    return max_group_count
```


",,
"```python
def can_construct(s, k):
    char_counts = [0] * 26

    for c in s:
        char_counts[ord(c) - ord('a')] += 1

    odd_count = sum(count % 2 for count in char_counts)

    return odd_count <= k <= len(s)
```


",,
"```python
def max_satisfaction(satisfaction):
    satisfaction.sort(reverse=True)
    ans = total = sum = 0
    for i in satisfaction:
        total += i
        if total > 0:
            sum += total
            ans = max(ans, sum)
    return ans
```

",,
"```python
def numSubmat(mat: List[List[int]]) -> int:
    m, n = len(mat), len(mat[0])
    dp = [[0] * n for _ in range(m)]
    ans = 0
    
    for i in range(m):
        for j in range(n):
            if mat[i][j]:
                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1
                width = dp[i][j]
                for k in range(i, -1, -1):
                    width = min(width, dp[k][j])
                    ans += width
    
    return ans
```

",,
"```python
def createTargetArray(nums, index):
    target = []
    for i in range(len(nums)):
        target.insert(index[i], nums[i])
    return target
```

",,
"```python
class Solution:
    def findRoot(self, nodes: List['Node']) -> 'Node':
        value_sum = 0
        
        for node in nodes:
            value_sum += node.val
            
            for child in node.children:
                value_sum -= child.val
        
        for node in nodes:
            if node.val == value_sum:
                return node
                
        return None
```


",,
"```python
def hasValidPath(grid):
    m, n = len(grid), len(grid[0])
    visited = [[False for _ in range(n)] for _ in range(m)]

    return dfs(grid, 0, 0, m, n, visited)

def dfs(grid, x, y, m, n, visited):
    if x < 0 or y < 0 or x >= m or y >= n or visited[x][y]:
        return False
    if x == m - 1 and y == n - 1:
        return True
    
    visited[x][y] = True

    next_x = [-1, 0, 1, 0]
    next_y = [0, 1, 0, -1]

    for i in range(4):
        dx = x + next_x[i]
        dy = y + next_y[i]

        if dfs(grid, dx, dy, m, n, visited):
            return True

    return False
```

",,
"```python
def longestHappyPrefix(s):
    n = len(s)
    lps = [0] * n
    length = 0
    i = 1
    while i < n:
        if s[i] == s[length]:
            length += 1
            lps[i] = length
            i += 1
        elif length != 0:
            length = lps[length - 1]
        else:
            lps[i] = 0
            i += 1
    return s[:lps[-1]]
```

",,
"```python
def minDifference(nums):
    n = len(nums)
    if n <= 4: return 0
    nums.sort()
    res = float('inf')
    for i in range(4):
        res = min(res, nums[n - 4 + i] - nums[i])
    return res
```

",,
"```python
def find_lucky(arr):
    freq = {}

    for n in arr:
        if n in freq:
            freq[n] += 1
        else:
            freq[n] = 1

    lucky = -1
    for key, value in freq.items():
        if key == value:
            lucky = max(lucky, key)

    return lucky
```

",,
"```python
class UndergroundSystem:
    def __init__(self):
        self.check_in_data = {}
        self.travel_data = {}

    def checkIn(self, id: int, stationName: str, t: int) -> None:
        self.check_in_data[id] = (stationName, t)

    def checkOut(self, id: int, stationName: str, t: int) -> None:
        start_station, start_time = self.check_in_data[id]
        route = (start_station, stationName)
        if route not in self.travel_data:
            self.travel_data[route] = [0, 0]
        self.travel_data[route][0] += t - start_time
        self.travel_data[route][1] += 1

    def getAverageTime(self, startStation: str, endStation: str) -> float:
        route = (startStation, endStation)
        total_time, num_trips = self.travel_data[route]
        return total_time / num_trips
```

",,
"```python
MOD = 10**9 + 7

def countGoodStrings(s1, s2, evil):
    n = len(s1)
    m = len(evil)
    dp = [[0] * m for _ in range(n + 1)]

    # Preprocess the KMP prefix function for the evil string
    lps = [0] * m
    len_ = 0
    i = 1
    while i < m:
        if evil[i] == evil[len_]:
            len_ += 1
            lps[i] = len_
            i += 1
        elif len_:
            len_ = lps[len_ - 1]
        else:
            i += 1

    dp[0][0] = 1
    for i in range(n):
        for j in range(m):
            for k in range(2):
                for c in range(ord('a'), ord(s2[i] if k else 'z') + 1):
                    e = j
                    while e and (chr(c) != evil[e]):
                        e = lps[e - 1]

                    if chr(c) != evil[e]:
                        e += 1

                    if e != m:
                        dp[i + 1][k | (c < ord(s2[i]))] += dp[i][k]
                        dp[i + 1][k | (c < ord(s2[i]))] %= MOD

    return (dp[n][1] - dp[n][0] + MOD) % MOD
```


",,
"```python
def min_start_value(nums):
    min_sum, sum = 0, 0
    for num in nums:
        sum += num
        min_sum = min(min_sum, sum)
    return 1 - min_sum
```

",,
"```python
def find_min_fibonacci_numbers(k):
    if k == 0:
        return 0
    a, b = 0, 1
    while b <= k:
        a, b = b, a + b
    return 1 + find_min_fibonacci_numbers(k - a)
```

",,
"```python
def get_happy_string(n, k):
    def dfs(s, prev):
        if len(s) == n:
            happy_strings.append(s)
            return
        for c in 'abc':
            if c != prev:
                dfs(s + c, c)

    happy_strings = []
    dfs("""", ' ')
    return happy_strings[k - 1] if k <= len(happy_strings) else """"
```

",,
"```python
def numWaterBottles(numBottles: int, numExchange: int) -> int:
    totalBottles = numBottles
    while numBottles >= numExchange:
        newBottles = numBottles // numExchange
        totalBottles += newBottles
        numBottles = newBottles + numBottles % numExchange
    return totalBottles
```

",,
"```python
def min_subsequence(nums):
    nums.sort(reverse=True)
    total_sum, current_sum = sum(nums), 0
    result = []
    for num in nums:
        current_sum += num
        result.append(num)
        if current_sum > total_sum - current_sum:
            break
    return result
```

",,
"```python
def num_steps(s: str) -> int:
    steps = 0
    carry = 0

    for i in range(len(s) - 1, 0, -1):
        current = int(s[i]) + carry
        if current == 1:
            steps += 2
            carry = 1
        else:
            steps += carry
            carry = current

    return steps + carry
```

",,
"```python
def closestToTarget(arr: List[int], target: int) -> int:
    min_diff = float('inf')
    prefix = set()

    for n in arr:
        next_prefix = set()
        for p in prefix:
            next_prefix.add(p & n)
        next_prefix.add(n)

        for p in next_prefix:
            min_diff = min(min_diff, abs(p - target))
        prefix = next_prefix
    return min_diff
```

",,
"```python
def stoneGameIII(stoneValue):
    n = len(stoneValue)
    dp = [0] * (n + 1)
    dp[n - 1] = stoneValue[n - 1]
    for i in range(n - 2, -1, -1):
        dp[i] = stoneValue[i] - dp[i + 1]
        for j in range(1, 3):
            if i + j < n:
                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1])
    if dp[0] > 0: return ""Alice""
    if dp[0] < 0: return ""Bob""
    return ""Tie""
```

",,
"```python
def count_odds(low, high):
    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)
```

",,
"```python
def stringMatching(words):
    result = []
    for word1 in words:
        for word2 in words:
            if word1 != word2 and word1 in word2:
                result.append(word1)
                break
    return result
```

",,
"```python
def process_queries(queries, m):
    nums = list(range(1, m+1))
    result = []
    for q in queries:
        pos = nums.index(q)
        result.append(pos)
        del nums[pos]
        nums.insert(0, q)
    return result
```

",,
"```python
def entityParser(text: str) -> str:
    entities = {
        ""&quot;"": '\""',
        ""&apos;"": '\'',
        ""&amp;"": '&',
        ""&gt;"": '>',
        ""&lt;"": '<',
        ""&frasl;"": '/'
    }

    result, i = [], 0
    while i < len(text):
        if text[i] == '&':
            temp = ''
            for j in range(i, min(i+7, len(text))):
                temp += text[j]
                if temp in entities:
                    result.append(entities[temp])
                    i = j
                    break
            else:
                result.append(text[i])
        else:
            result.append(text[i])
        i += 1
    return ''.join(result)
```


",,
"```python
from typing import List

def kids_with_candies(candies: List[int], extra_candies: int) -> List[bool]:
    max_candies = max(candies)
    result = [candy + extra_candies >= max_candies for candy in candies]
    return result
```

",,
"```python
def max_difference(num):
    a = num + 9 - (num % 10)
    b = num - (num // 1000 % 10) * 111

    return a - b
```

",,
"```python
def check_if_can_break(s1, s2):
    s1 = sorted(s1)
    s2 = sorted(s2)

    can_break_1 = can_break_2 = True
    for c1, c2 in zip(s1, s2):
        if c1 < c2:
            can_break_1 = False
        if c2 < c1:
            can_break_2 = False

    return can_break_1 or can_break_2
```


",,
"```python
def number_ways(hats):
    kMod = 1000000007
    kMaxHats = 40

    num_people = len(hats)
    people_with_hat = [[] for _ in range(kMaxHats)]

    for i in range(num_people):
        for hat in hats[i]:
            people_with_hat[hat - 1].append(i)

    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]
    dp[0][0] = 1

    for hat in range(kMaxHats):
        for mask in reversed(range(1 << num_people)):
            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod
            for person in people_with_hat[hat]:
                if mask & (1 << person) == 0:
                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod

    return dp[(1 << num_people) - 1][kMaxHats]
```

",,
"```python
from collections import defaultdict
from typing import List

def displayTable(orders: List[List[str]]) -> List[List[str]]:
    foodItems = set()
    tableOrders = defaultdict(lambda: defaultdict(int))

    for order in orders:
        foodItems.add(order[2])
        tableOrders[int(order[1])][order[2]] += 1

    foodItems = sorted(foodItems)
    header = [""Table""] + foodItems
    result = [header]

    for tableNumber, foodOrder in sorted(tableOrders.items()):
        row = [str(tableNumber)] + [str(foodOrder[food]) for food in foodItems]
        result.append(row)

    return result
```


",,
"```python
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    counts = [0] * 5
    max_frogs = 0

    for c in croakOfFrogs:
        index = ""croak"".find(c)
        if index == 0:
            counts[0] += 1
            max_frogs = max(max_frogs, counts[0])
        elif counts[index - 1] > 0:
            counts[index - 1] -= 1
            counts[index] += 1
        else:
            return -1

    if counts[0] == counts[4]:
        return max_frogs
    else:
        return -1
```

",,
"```python
def number_of_ways(n, m, k, mod=1_000_000_007):
    if k > 1:
        result = 1
        for _ in range(n):
            result = (result * m) % mod
        return result
    return 1 if n % 2 == 0 else m
```

",,
"```python
def minSwaps(grid):
    n = len(grid)
    steps = 0

    for i in range(n):
        row = -1
        for j in range(i, n):
            if grid[j][i] == 0:
                row = j
                break
        if row == -1:
            return -1

        while row > i:
            grid[row], grid[row - 1] = grid[row - 1], grid[row]
            steps += 1
            row -= 1

    return steps
```


",,
"```python
def maxScore(s):
    left_zeros, right_ones, max_score = 0, s.count('1'), 0
    for i in range(len(s) - 1):
        if s[i] == '0': left_zeros += 1
        else: right_ones -= 1
        max_score = max(max_score, left_zeros + right_ones)
    return max_score
```

",,
"```python
def maxScore(cardPoints, k):
    n = len(cardPoints)
    total = sum(cardPoints[:k])

    max_score = total
    for i in range(k - 1, -1, -1):
        j = n - k + i
        total += cardPoints[j] - cardPoints[i]
        max_score = max(max_score, total)

    return max_score
```


",,
"```python
def find_diagonal_order(nums):
    diagonals = {}
    for i in range(len(nums)):
        for j in range(len(nums[i])):
            if i + j not in diagonals:
                diagonals[i + j] = []
            diagonals[i + j].append(nums[i][j])

    res = []
    for key in diagonals:
        res.extend(reversed(diagonals[key]))

    return res
```

",,
"```python
def canConvertString(s: str, t: str, k: int) -> bool:
    if len(s) != len(t):
        return False
    count = [0] * 26
    for i in range(len(s)):
        diff = (ord(t[i]) - ord(s[i]) + 26) % 26
        if diff > 0:
            count[diff] += 1
    for i in range(1, 26):
        if count[i] > 0:
            if count[i] * 26 - 26 + i > k:
                return False
    return True
```

",,
"```python
def minInsertions(s: str) -> int:
    left = 0
    res = 0
    n = len(s)
    i = 0
    while i < n:
        if s[i] == '(':
            left += 1
        else:
            if left == 0: 
                res += 1
            else: 
                left -= 1
            if i == n - 1 or s[i + 1] != ')':
                res += 1
                i += 1
        i += 1
    return res + left * 2
```

",,
"```python
def max_power(s: str) -> int:
    max_power = current_power = 1

    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_power += 1
        else:
            max_power = max(max_power, current_power)
            current_power = 1

    return max(max_power, current_power)
```

",,
"```python
def goodNodes(root, maxVal=float('-inf')):
    if not root:
        return 0
    result = 0
    if root.val >= maxVal:
        result = 1
        maxVal = root.val
    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal)
```

",,
"```python
def largestNumber(cost, target):
    dp = ["""" for _ in range(target + 1)]
    dp[0] = """"
    
    for t in range(1, target + 1):
        for i in range(1, 10):
            if t >= cost[i - 1] and dp[t - cost[i - 1]]:
                temp = dp[t - cost[i - 1]] + str(i)
                if len(dp[t]) <= len(temp):
                    dp[t] = temp

    return dp[target] if dp[target] else ""0""
```


",,
"```python
def maxNonOverlapping(nums, target):
    prefix_sum = {0: 0}
    sum, count = 0, 0
    for num in nums:
        sum += num
        if sum - target in prefix_sum:
            count = max(count, 1 + prefix_sum[sum - target])
        prefix_sum[sum] = count
    return count
```

",,
"```python
def destCity(paths):
    starting_cities = set()
    
    for path in paths:
        starting_cities.add(path[0])

    for path in paths:
        if path[1] not in starting_cities:
            return path[1]

    return """"
```

",,
"```python
def kLengthApart(nums, k):
    last_one = -1
    for i, num in enumerate(nums):
        if num == 1:
            if last_one != -1 and i - last_one <= k:
                return False
            last_one = i
    return True
```

",,
"```python
import heapq

def kthSmallest(mat, k):
    m, n = len(mat), len(mat[0])
    
    minHeap = [(mat[0][0], 0, 0)]
    visited = [[False for _ in range(n)] for _ in range(m)]
    visited[0][0] = True
    
    for _ in range(k):
        res, i, j = heapq.heappop(minHeap)
        
        if i < m - 1 and not visited[i+1][j]:
            heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j))
            visited[i+1][j] = True
        if j < n - 1 and not visited[i][j+1]:
            heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1))
            visited[i][j+1] = True
            
    return res
```

",,
"```python
def min_operations(n):
    return n * n // 4
```

",,
"```python
def build_array(target, n):
    result = []
    current = 1
    for num in target:
        while current < num:
            result.append(""Push"")
            result.append(""Pop"")
            current += 1
        result.append(""Push"")
        current += 1
    return result
```

",,
"```python
def countTriplets(arr):
    n = len(arr)
    XOR = [0] * (n + 1)
    
    for i in range(n):
        XOR[i+1] = XOR[i] ^ arr[i]
    
    count = 0
    for i in range(n):
        for k in range(i+1, n):
            if XOR[i] == XOR[k+1]:
                count += k-i
    return count
```

",,
"```python
def minTime(n, edges, hasApple):
    graph = {i: {} for i in range(n)}

    for a, b in edges:
        graph[a][b] = 0
        graph[b][a] = 0

    def dfs(v, parent):
        ans = 0
        for u in graph[v]:
            if u == parent:
                continue
            ans += dfs(u, v) * 2
        return ans + int(hasApple[v] or ans > 0)

    return dfs(0, -1)
```

",,
"```python
def can_be_equal(target, arr):
    target.sort()
    arr.sort()
    return target == arr
```


",,
"```python
def has_all_codes(s, k):
    need = 1 << k
    got = set()
    
    for i in range(len(s) - k + 1):
        got.add(s[i:i + k])
    
    return len(got) == need
```


",,
"```python
from collections import defaultdict

def DFS(src, graph, visited, transitive_closure, dest):
    if src == dest:
        transitive_closure[dest] = True
        return
    if visited[src]:
        return
    visited[src] = True
    for neighbor in graph[src]:
        DFS(neighbor, graph, visited, transitive_closure, dest)
        if transitive_closure[dest]:
            return

def checkIfPrerequisite(numCourses, prerequisites, queries):
    graph = defaultdict(list)

    for pre in prerequisites:
        graph[pre[0]].append(pre[1])

    result = []

    for i in range(len(queries)):
        visited = [False] * numCourses
        transitive_closure = [False] * numCourses
        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])
        result.append(transitive_closure[queries[i][1]])

    return result
```

",,
"```python
def cherry_pickup(grid):
    rows, cols = len(grid), len(grid[0])
    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]

    for row in reversed(range(rows)):
        for col1 in range(cols):
            for col2 in range(cols):
                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0
                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)

                max_val = 0
                for move1 in range(-1, 2):
                    for move2 in range(-1, 2):
                        new_col1, new_col2 = col1 + move1, col2 + move2
                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:
                            max_val = max(max_val, dp[row][new_col1][new_col2])

                dp[row][col1][col2] = current_cell + max_val

    return dp[0][0][cols - 1]
```


",,
"```python
def busy_student(start_time, end_time, query_time):
    count = 0
    for i in range(len(start_time)):
        if start_time[i] <= query_time <= end_time[i]:
            count += 1
    return count
```

",,
"```python
def arrangeWords(text: str) -> str:
    words = text.split()
    words[0] = words[0].lower()
    words.sort(key=len)
    words[0] = words[0].capitalize()
    return ' '.join(words)
```

",,
"```python
from typing import List

def peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:
    result = []
    for i in range(len(favoriteCompanies)):
        is_subset = False
        for j in range(len(favoriteCompanies)):
            if i != j and set(favoriteCompanies[i]).issubset(favoriteCompanies[j]):
                is_subset = True
                break
        if not is_subset:
            result.append(i)
    return result
```

",,
"```python
from math import acos, cos, sin, sqrt

def max_number_of_darts(darts, r):
    n = len(darts)
    max_darts = 1

    for i in range(n):
        for j in range(i + 1, n):
            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)
            if dist > 2.0 * r: continue

            angle = acos(dist / (2.0 * r))
            for k in range(2):
                loc_angle = angle * (1 if k == 0 else -1)
                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)
                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)

                cnt = 0
                for l in range(n):
                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)
                    if new_dist <= r + 1e-5: cnt += 1

                max_darts = max(max_darts, cnt)

    return max_darts
```

",,
"```python
def maxBoxesInWarehouse(boxes, warehouse):
    n = len(warehouse)
    for i in range(1, n):
        warehouse[i] = min(warehouse[i], warehouse[i - 1])
    boxes.sort(reverse=True)
    boxIndex = 0
    boxesCount = 0
    for i in range(n):
        if boxIndex < len(boxes) and boxes[boxIndex] <= warehouse[i]:
            boxesCount += 1
            boxIndex += 1
    return boxesCount
```


",,
"```python
def is_prefix_of_word(sentence: str, search_word: str) -> int:
    words = sentence.split(' ')
    for index, word in enumerate(words, start=1):
        if word.startswith(search_word):
            return index
    return -1
```

",,
"```python
def max_vowels(s, k):
    max_count = count = 0
    for i, c in enumerate(s):
        count += int(c in 'aeiou')
        if i >= k:
            count -= int(s[i - k] in 'aeiou')
        max_count = max(max_count, count)
    return max_count
```


",,
"```python
def pseudoPalindromicPaths(root, cnt = 0):
    if not root:
        return 0
    cnt ^= 1 << (root.val - 1)
    if not root.left and not root.right:
        return (cnt & (cnt - 1)) == 0
    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)
```

",,
"```python
def maxDotProduct(nums1, nums2):
    n, m = len(nums1), len(nums2)
    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])
    return dp[n][m]
```

",,
"```python
def final_prices(prices):
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            if prices[j] <= prices[i]:
                prices[i] -= prices[j]
                break
    return prices
```

",,
"```python
class SubrectangleQueries:
    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        for i in range(row1, row2 + 1):
            for j in range(col1, col2 + 1):
                self.rectangle[i][j] = newValue

    def getValue(self, row: int, col: int) -> int:
        return self.rectangle[row][col]
```

",,
"```python
def min_sum_of_lengths(arr, target):
    n = len(arr)
    sum_, min_len, result = 0, float('inf'), float('inf')
    mp = {0: -1}

    for i in range(n):
        sum_ += arr[i]
        if sum_ >= target and (sum_ - target) in mp:
            if mp[sum_ - target] > -1 and min_len != float('inf'):
                result = min(result, i - mp[sum_ - target] + min_len)
            min_len = min(min_len, i - mp[sum_ - target])
        mp[sum_] = i

    return result if result != float('inf') else -1
```


",,
"```python
def findLengthOfShortestSubarray(arr):
    n = len(arr)
    left, right = 0, n - 1
    while left < n - 1 and arr[left] <= arr[left + 1]:
        left += 1
    if left == n - 1:
        return 0
    while right > 0 and arr[right] >= arr[right - 1]:
        right -= 1
    result = min(n - left - 1, right)
    i, j = 0, right
    while i <= left and j < n:
        if arr[i] <= arr[j]:
            result = min(result, j - i - 1)
            i += 1
        else:
            j += 1
    return result
```

",,
"```python
def maxArea(h, w, horizontalCuts, verticalCuts):
    horizontalCuts.sort()
    verticalCuts.sort()

    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])
    maxV = max(verticalCuts[0], w - verticalCuts[-1])

    for i in range(1, len(horizontalCuts)):
        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])

    for i in range(1, len(verticalCuts)):
        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])

    return (maxH * maxV) % (10**9 + 7)
```

",,
"```python
from collections import defaultdict

def dfs(node, parent, graph, count):
    if node != 0 and parent == 0:
        count[0] += 1

    for neighbor in graph[node]:
        if neighbor != parent:
            dfs(neighbor, node, graph, count)

def minReorder(n, connections):
    graph = defaultdict(list)
    for a, b in connections:
        graph[a].append(b)
        graph[b].append(a)

    count = [0]
    dfs(0, -1, graph, count)
    return count[0]
```

",,
"```python
class Solution:
    def getProbability(self, balls: List[int]) -> float:
        pre_sum = [0]
        dp = [[[0]*62 for _ in range(10)] for _ in range(35)]
        k = len(balls)

        for b in balls:
            pre_sum.append(pre_sum[-1] + b)

        dp[0][0][0] = 1
        for i in range(k):
            for j in reversed(range(i + 1)):
                for x in reversed(range(pre_sum[i+1] + 1)):
                    for y in reversed(range(0, pre_sum[i+1] - x + 1)):
                        if x + y <= balls[i]:
                            for d in range(max(0, balls[i] - 2 * y), x + 1):
                                tmp = 1
                                for z in range(1, d + 1):
                                    tmp *= (x + y + 1 - z) / z
                                for z in range(1, y + 1):
                                    tmp *= (x + y + d + 1 - z) / z
                                for z in range(1, balls[i] - y - y - d + 1):
                                    tmp *= (x + y + d + 1 - z) / z
                                dp[i+1][j+1][x + d] += dp[i][j][x] * tmp
                                dp[i+1][j][x + d] += dp[i][j][x] * tmp

        sum_ = sum(balls)
        return (dp[k][k >> 1][sum_ >> 1] - (1e-5 > dp[k][k >> 1][sum_ >> 1])) / (1 if sum_ % 2 else (1 << (sum_ >> 1)))
```


",,
"```python
def minTime(colors: str, neededTime: List[int]) -> int:
    res, prev = 0, -1
    for i in range(len(colors) - 1):
        if colors[i] == colors[i + 1]:
            if prev == -1 or neededTime[i] < neededTime[prev]:
                prev = i
            if neededTime[i + 1] < neededTime[prev]:
                prev = i + 1
            res += neededTime[prev]
            neededTime[prev] = 1000000
            prev = -1
    return res
```

",,
"```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.components = size

    def find(self, x):
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, x, y):
        root_x, root_y = self.find(x), self.find(y)
        if root_x != root_y:
            self.parent[root_x] = root_y
            self.components -= 1
            return True
        return False

def max_num_edges_to_remove(n, edges):
    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)
    common_edges = 0

    for t, u, v in edges:
        if t == 3:
            if ufA.unite(u, v):
                ufB.unite(u, v)
                common_edges += 1

    removed_edges = 0
    for t, u, v in edges:
        uf = ufA if t == 1 else ufB if t == 2 else None
        if uf and not uf.unite(u, v):
            removed_edges += 1

    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges
```

",,
"```python
def shuffle(nums, n):
    shuffled = []
    for i in range(n):
        shuffled.append(nums[i])
        shuffled.append(nums[i+n])
    return shuffled
```

",,
"```python
class BrowserHistory:

    def __init__(self, homepage: str):
        self.history = [homepage]
        self.current_index = 0

    def visit(self, url: str):
        self.history = self.history[:self.current_index + 1]
        self.history.append(url)
        self.current_index += 1

    def back(self, steps: int) -> str:
        self.current_index -= min(steps, self.current_index)
        return self.history[self.current_index]

    def forward(self, steps:int) -> str:
        self.current_index += min(steps, len(self.history) - 1 - self.current_index)
        return self.history[self.current_index]
```


",,
"```python
def minCost(houses, cost, m, n, target):
    dp = [[[float('inf')] * (target + 1) for _ in range(n)] for _ in range(m)]

    if houses[0] != 0:
        dp[0][houses[0] - 1][1] = 0
    else:
        for j in range(n):
            dp[0][j][1] = cost[0][j]

    for i in range(1, m):
        for j in range(n):
            for k in range(1, target + 1):
                if houses[i] != 0 and houses[i] != j + 1:
                    continue
                paint_cost = 0 if houses[i] != 0 else cost[i][j]

                for l in range(n):
                    if l == j:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + paint_cost)
                    else:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost)

    ans = min(dp[m - 1][j][target] for j in range(n))
    return -1 if ans == float('inf') else ans
```


",,
"```python
def average(salary):
    min_salary = min(salary)
    max_salary = max(salary)
    sum_salaries = sum(salary)
    sum_salaries -= (min_salary + max_salary)
    return sum_salaries / (len(salary) - 2)
```

",,
"```python
def kth_factor(n: int, k: int) -> int:
    for i in range(1, n+1):
        if n % i == 0:
            k -= 1
            if k == 0:
                return i
    return -1
```


",,
"```python
def findMaxLength(nums):
    max_length, zeroes, ones = 0, 0, 0
    count_map = {0: -1}

    for i, num in enumerate(nums):
        if num == 0:
            zeroes += 1
        else:
            ones += 1

        if zeroes - ones not in count_map:
            count_map[zeroes - ones] = i
        else:
            max_length = max(max_length, i - count_map[zeroes - ones])

    return max_length
```

",,
"```python
def sumOddLengthSubarrays(arr):
    sum = 0
    n = len(arr)
    for i in range(n):
        oddSubarrays = ((i + 1) * (n - i) + 1) // 2
        sum += arr[i] * oddSubarrays
    return sum
```

",,
"```python
def maxSumRangeQuery(nums, requests):
    n = len(nums)
    count = [0] * n
    for request in requests:
        count[request[0]] += 1
        if request[1] + 1 < n:
            count[request[1] + 1] -= 1
    for i in range(1, n):
        count[i] += count[i - 1]

    nums.sort()
    count.sort()

    ans = 0
    for i in range(n):
        ans = (ans + nums[i] * count[i]) % 1000000007
    return ans
```

",,
"```python
def minSubarray(nums, p):
    n, res, need, cur = len(nums), len(nums), 0, 0
    for num in nums:
        need = (need + num) % p
    if need == 0:
        return 0
    last_seen = {0: -1}
    for i, num in enumerate(nums):
        cur = (cur + num) % p
        last_seen[cur] = i
        res = min(res, i - last_seen.get((cur - need + p) % p, -n))
    return res if res < n else -1
```

",,
"```python
def isPrintable(self, targetGrid: List[List[int]]) -> bool:
    color_bounds = {}
    m, n = len(targetGrid), len(targetGrid[0])

    for i in range(m):
        for j in range(n):
            color = targetGrid[i][j]
            if color not in color_bounds:
                color_bounds[color] = [i, j, i, j]
            else:
                color_bounds[color][0] = min(color_bounds[color][0], i)
                color_bounds[color][1] = min(color_bounds[color][1], j)
                color_bounds[color][2] = max(color_bounds[color][2], i)
                color_bounds[color][3] = max(color_bounds[color][3], j)

    remaining_colors = set(color_bounds.keys())
    while remaining_colors:
        progress = False
        to_remove = set()
        for color in remaining_colors:
            bounds = color_bounds[color]
            contained = all(targetGrid[i][j] == color or targetGrid[i][j] == -1
                        for i in range(bounds[0], bounds[2] + 1)
                        for j in range(bounds[1], bounds[3] + 1))
            if contained:
                for i in range(bounds[0], bounds[2] + 1):
                    for j in range(bounds[1], bounds[3] + 1):
                        targetGrid[i][j] = -1
                to_remove.add(color)
                progress = True

        remaining_colors -= to_remove
        if not progress:
            return False

    return True
```


",,
"```python
def reorderSpaces(text):
    spaces = text.count(' ')
    words = text.split()
    num_words = len(words)
    
    if num_words == 1:
        spaces_between_words = 0
    else:
        spaces_between_words = spaces // (num_words - 1)
    
    extra_spaces = spaces - spaces_between_words * (num_words - 1)

    return (' ' * spaces_between_words).join(words) + ' ' * extra_spaces
```

",,
"```python
def maxUniqueSplit(s, start=0, seen=None):
    if seen is None:
        seen = set()
    if start == len(s):
        return 0
    maxUnique = -1
    for i in range(start + 1, len(s) + 1):
        sub = s[start:i]
        if sub not in seen:
            seen.add(sub)
            unique = maxUniqueSplit(s, i, seen)
            if unique != -1:
                maxUnique = max(maxUnique, unique + 1)
            seen.remove(sub)
    return maxUnique
```

",,
"```python
def maxProductPath(self, grid: List[List[int]]) -> int:
    m, n, mod = len(grid), len(grid[0]), 10**9 + 7
    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]
    dp[0][0] = [grid[0][0], grid[0][0]]
    for i in range(1, m):
        dp[i][0] = [grid[i][0] * dp[i - 1][0][0], grid[i][0] * dp[i - 1][0][0]]
    for j in range(1, n):
        dp[0][j] = [grid[0][j] * dp[0][j - 1][0], grid[0][j] * dp[0][j - 1][0]]
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] < 0:
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])
            else:
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])
    return -1 if dp[-1][-1][1] < 0 else dp[-1][-1][1] % mod
```

",,
"```python
def connectTwoGroups(cost):
    size1, size2 = len(cost), len(cost[0])
    min_cost = [float('inf')] * size2

    for i in range(size1):
        for j in range(size2):
            min_cost[j] = min(min_cost[j], cost[i][j])

    total_cost = 0
    for i in range(size1):
        total_cost += min(cost[i])

    for j in range(size2):
        total_cost += min_cost[j]

    return total_cost
```


",,
"```python
class Solution:
    def expTree(self, s: str) -> 'Node':
        def precedence(a, b):
            if a == '(':
                return False
            if b == '(' or b == ')':
                return True
            if (a in {'*', '/'}) and (b in {'+', '-'}):
                return True
            return False
        
        def process(nodes, ops):
            right = nodes.pop()
            left = nodes.pop()
            oper = Node(ops.pop())
            oper.left = left
            oper.right = right
            nodes.append(oper)
            
        nodes = []
        ops = []
        for i in s:
            if i.isdigit():
                nodes.append(Node(i))
            elif i == '(':
                ops.append(i)
            elif i == ')':
                while ops[-1] != '(':
                    process(nodes, ops)
                ops.pop()
            else:
                while ops and precedence(ops[-1], i):
                    process(nodes, ops)
                ops.append(i)
        while ops:
            process(nodes, ops)
        return nodes[0]
```

",,
"```python
def minOperations(logs):
    depth = 0
    for log in logs:
        if log == ""../"":
            depth = max(0, depth - 1)
        elif log != ""./"":
            depth += 1
    return depth
```

",,
"```python
def minOperationsMaxProfit(customers, boardingCost, runningCost):
    waiting = 0
    profit = 0
    max_profit = 0
    rotations = 0
    result = -1

    for i in range(len(customers) + sum(customers)):
        if i < len(customers):
            waiting += customers[i]
        boarding = min(waiting, 4)
        waiting -= boarding
        profit += boarding * boardingCost - runningCost

        if profit > max_profit:
            max_profit = profit
            result = rotations + 1
        rotations += 1
    
    return result
```


",,
"```python
class ThroneInheritance:

    def __init__(self, kingName: str):
        self.king = kingName
        self.family = {}
        self.dead = set()

    def birth(self, parentName: str, childName: str) -> None:
        if parentName not in self.family:
            self.family[parentName] = []
        self.family[parentName].append(childName)

    def death(self, name: str) -> None:
        self.dead.add(name)

    def getInheritanceOrder(self) -> List[str]:
        order = []
        self.dfs(self.king, order)
        return order

    def dfs(self, name: str, order: List[str]) -> None:
        if name not in self.dead:
            order.append(name)
        if name in self.family:
            for child in self.family[name]:
                self.dfs(child, order)
```


",,
"```python
def maximumRequests(n, requests):
    req_size = len(requests)
    max_requests = 0

    for i in range(1 << req_size):
        net_transfers = [0] * n
        count = 0
        
        for j in range(req_size):
            if i & (1 << j):
                net_transfers[requests[j][0]] -= 1
                net_transfers[requests[j][1]] += 1
                count += 1

        valid = all(val == 0 for val in net_transfers)

        if valid:
            max_requests = max(max_requests, count)

    return max_requests
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_nearest_right_node(root, u):
    if not root:
        return None
    
    q = [root]
    
    while q:
        n = len(q)
        
        for i in range(n):
            current = q.pop(0)
            
            if current == u:
                return q[0] if i < n - 1 else None
            
            if current.left:
                q.append(current.left)
            if current.right:
                q.append(current.right)
    
    return None
```

",,
"```python
def runningSum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums
```

",,
"```python
import heapq
from collections import Counter

def find_least_num_of_unique_ints(arr, k):
    freq_map = Counter(arr)
    min_heap = list(freq_map.values())
    heapq.heapify(min_heap)

    while k > 0:
        k -= heapq.heappop(min_heap)

    return len(min_heap) if k == 0 else len(min_heap) + 1
```

",,
"```python
def minDays(bloomDay, m, k):
    left, right = min(bloomDay), max(bloomDay)

    while left < right:
        mid = left + (right - left) // 2
        bouquets = flowers = 0
        for day in bloomDay:
            if day > mid:
                flowers = 0
            else:
                flowers += 1
                if flowers == k:
                    bouquets += 1
                    flowers = 0

        if bouquets >= m:
            right = mid
        else:
            left = mid + 1

    return -1 if m == 0 else left
```

",,
"```python
def busiestServers(k, arrival, load):
    server_status = [-1] * k
    server_request_count = [0] * k

    for i in range(len(arrival)):
        index = i % k
        for _ in range(k):
            if server_status[index] <= arrival[i]:
                server_status[index] = arrival[i] + load[i]
                server_request_count[index] += 1
                break
            index = (index + 1) % k

    max_requests = max(server_request_count)
    return [i for i in range(k) if server_request_count[i] == max_requests]
```

",,
"```python
def specialArray(nums):
    max_val = max(nums)
    for x in range(1, max_val + 1):
        count = sum([1 for num in nums if num >= x])
        if count == x:
            return x
    return -1
```

",,
"```python
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_even_odd_tree(root):
    if not root:
        return False
    
    q = deque([root])
    level = 0
    
    while q:
        size = len(q)
        prev_val = 0 if level % 2 == 0 else 10**6 + 1
        
        for _ in range(size):
            curr = q.popleft()
            
            if ((level % 2 == 0 and (curr.val % 2 == 0 or curr.val <= prev_val)) or 
                (level % 2 != 0 and (curr.val % 2 != 0 or curr.val >= prev_val))):
                return False
            
            prev_val = curr.val
            
            if curr.left:
                q.append(curr.left)
            if curr.right:
                q.append(curr.right)
        
        level += 1
    
    return True
```

",,
"```python
def xor_operation(n, start):
    xor_result = 0
    for i in range(n):
        xor_result ^= (start + 2 * i)
    return xor_result
```

",,
"```python
def get_folder_names(names):
    name_count = {}
    ans = []

    for name in names:
        if name not in name_count:
            ans.append(name)
            name_count[name] = 1
        else:
            k = name_count[name]
            new_name = f""{name}({k})""
            while new_name in name_count:
                k += 1
                new_name = f""{name}({k})""
            ans.append(new_name)
            name_count[new_name] = 1
            name_count[name] = k + 1

    return ans
```

",,
"```python
from sortedcontainers import SortedSet

def avoidFlood(rains: List[int]) -> List[int]:
    res = [-1] * len(rains)
    filled_lakes = {}
    dry_days = SortedSet()

    for i, lake in enumerate(rains):
        if lake == 0:
            dry_days.add(i)
        else:
            if lake in filled_lakes:
                day = dry_days.ceiling(filled_lakes[lake])
                if day is None:
                    return []
                res[day] = lake
                dry_days.remove(day)
            filled_lakes[lake] = i

    for day in dry_days:
        res[day] = 1

    return res
```


",,
"```python
def maxDepth(s: str) -> int:
    depth = 0
    max_depth = 0

    for c in s:
        if c == '(':
            depth += 1
            max_depth = max(depth, max_depth)
        elif c == ')':
            depth -= 1

    return max_depth
```

",,
"```python
def range_sum(nums, n, left, right):
    MOD = 10**9 + 7
    sums = []
    for i in range(n):
        sum = 0
        for j in range(i, n):
            sum += nums[j]
            sums.append(sum)
    sums.sort()
    result = 0
    for i in range(left-1, right):
        result = (result + sums[i]) % MOD
    return result
```

",,
"```python
def min_difference(nums):
    size = len(nums)
    if size < 5:
        return 0

    nums.sort()

    return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])
```

",,
"```python
def winnerSquareGame(n: int) -> bool:
    dp = [False] * (n + 1)
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            if not dp[i - j * j]:
                dp[i] = True
                break
            j += 1
    return dp[n]
```

",,
"```python
def max_font_size(text: str, w: int, h: int, fonts: List[int], font_info) -> int:
    left, right, ans = 0, len(fonts) - 1, -1
    while left <= right:
        mid = left + (right - left) // 2
        font_size = fonts[mid]
        width, height = sum(font_info.getWidth(font_size, ch) for ch in text), font_info.getHeight(font_size)
        if width <= w and height <= h:
            ans = font_size
            left = mid + 1
        else:
            right = mid - 1
    return ans
```

",,
"```python
def is_path_crossing(path: str) -> bool:
    visited = {(0, 0)}
    x, y = 0, 0
    for dir in path:
        if dir == 'N': y += 1
        elif dir == 'S': y -= 1
        elif dir == 'E': x += 1
        elif dir == 'W': x -= 1
        if (x, y) in visited: return True
        visited.add((x, y))
    return False
```

",,
"```python
def canArrange(arr, k):
    counts = [0] * k
    for num in arr:
        counts[(num % k + k) % k] += 1
    if counts[0] % 2 != 0:
        return False
    for i in range(1, k // 2 + 1):
        if counts[i] != counts[k - i]:
            return False
    return True
```

",,
"```python
def numSubseq(nums, target):
    nums.sort()
    n = len(nums)
    mod = 10**9 + 7

    power = [1] * n
    for i in range(1, n):
        power[i] = (power[i - 1] * 2) % mod

    ans = 0
    r = n
    for l in range(n):
        while r > l and nums[l] + nums[r - 1] > target:
            r -= 1

        ans = (ans + power[r - l]) % mod

    return ans
```


",,
"```python
from collections import deque

def findMaxValueOfEquation(points, k):
    res = -float(""inf"")
    q = deque()
   
    for p in points:
        while q and p[0] - q[0][1] > k:
            q.popleft()
        
        if q:
            res = max(res, p[1] + p[0] + q[0][0])
        
        while q and p[1] - p[0] >= q[-1][0]:
            q.pop()
        
        q.append((p[1] - p[0], p[0]))
    
    return res
```


",,
"```python
def maxLengthBetweenEqualCharacters(s: str) -> int:
    result = -1
    char_map = {}

    for i, c in enumerate(s):
        if c not in char_map:
            char_map[c] = i
        else:
            result = max(result, i - char_map[c] - 1)

    return result
```

",,
"```python
def findLexSmallestString(s: str, a: int, b: int) -> str:
    def add_odd(s: str, a: int) -> str:
        return ''.join([str((int(ch) + a) % 10) if idx % 2 else ch for idx, ch in enumerate(s)])

    def rotate(s: str, k: int) -> str:
        k %= len(s)
        return s[-k:] + s[:-k]

    smallest = s
    for _ in range(len(s)):
        for _ in range(10):
            rotated = rotate(s, b)
            temp = add_odd(rotated, a)
            smallest = min(smallest, temp)
            s = rotated
        s = add_odd(s, a)
    return smallest
```

",,
"```python
def can_make_arithmetic_progression(arr):
    arr.sort()
    difference = arr[1] - arr[0]
    for i in range(2, len(arr)):
        if arr[i] - arr[i - 1] != difference:
            return False
    return True
```

",,
"```python
def lastMoment(n, left, right):
    max_left = max(left, default=0)
    min_right = min(right, default=n)

    return max(max_left, n - min_right)
```

",,
"```python
def numSubmat(mat):
    m, n = len(mat), len(mat[0])
    dp = [[0] * n for _ in range(m)]
    count = 0

    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1:
                dp[i][j] = (1 if j == 0 else dp[i][j - 1] + 1)
                minWidth = dp[i][j]
                for k in range(i, -1, -1):
                    minWidth = min(minWidth, dp[k][j])
                    count += minWidth

    return count
```

",,
"```python
def minInteger(num: str, k: int) -> str:
    if k == 0:
        return num
    num = list(num)
    n = len(num)
    for i in range(n):
        idx = i
        for j in range(i + 1, n):
            if j - i > k:
                break
            if num[j] < num[idx]:
                idx = j
        min_digit = num[idx]
        for j in range(idx, i, -1):
            num[j] = num[j - 1]
        num[i] = min_digit
        k -= idx - i
    return ''.join(num)
```

",,
"```python
def count_odds(low, high):
    return (high + 1) // 2 - low // 2
```

",,
"```python
def numOfSubarrays(arr):
    odd, even, sum_, result = 0, 1, 0, 0
    mod = 10**9 + 7
    for x in arr:
        sum_ = (sum_ + x) % 2
        if sum_ % 2 == 0:
            even += 1
        else:
            odd += 1
        result = (result + odd) % mod
    return result
```

",,
"```python
def numSplits(s: str) -> int:
    left_set, right_set = set(), set()
    left, right = [0] * len(s), [0] * len(s)
    count = 0

    for i, char in enumerate(s):
        left_set.add(char)
        left[i] = len(left_set)

    for i in range(len(s) - 1, 0, -1):
        right_set.add(s[i])
        right[i] = len(right_set)

    for i in range(len(s) - 1):
        if left[i] == right[i + 1]:
            count += 1

    return count
```

",,
"```python
class PolyNode:
    def __init__(self, c: int, p: int, next: 'PolyNode' = None):
        self.coefficient = c
        self.power = p
        self.next = next

def addPoly(poly1: PolyNode, poly2: PolyNode) -> PolyNode:
    dummy = PolyNode(0, 0)
    current = dummy

    while poly1 and poly2:
        if poly1.power > poly2.power:
            current.next = poly1
            poly1 = poly1.next
        elif poly1.power < poly2.power:
            current.next = poly2
            poly2 = poly2.next
        else:
            sum = poly1.coefficient + poly2.coefficient
            if sum != 0:
                current.next = PolyNode(sum, poly1.power)
                current = current.next
            poly1 = poly1.next
            poly2 = poly2.next
        current = current.next

    current.next = poly1 if poly1 else poly2
    return dummy.next
```


",,
"```python
def num_sub(s: str) -> int:
    mod = 1000000007
    result = 0
    count = 0
    for c in s:
        count = count + 1 if c == '1' else 0
        result = (result + count) % mod
    return result
```

",,
"```python
def min_length_encoded(s: str, k: int) -> int:
    n = len(s)
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(k + 1):
            cnt = 1
            dp[i][j] = i - j
            l = i - 2
            while l >= 0 and i - 2 - l <= j:
                if s[l] == s[i - 1]:
                    cnt += 1
                else:
                    cnt = 1
                used = i - 2 - l
                new_aposition = i - 1 - cnt - used + 1
                if cnt >= 100:
                    new_aposition += 4
                elif cnt >= 10:
                    new_aposition += 3
                elif cnt >= 2:
                    new_aposition += 2
                else:
                    new_aposition += 1
                dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used])
                l -= 1

    return dp[n][k]
```

",,
"```python
def get_min_dist_sum(positions: List[List[int]]) -> float:
    x, y = 0, 0
    n = len(positions)
    for pos in positions:
        x += pos[0]
        y += pos[1]
    x /= n
    y /= n
    return x
```

",,
"```python
def numWays(words, target):
    n = len(words)
    m = len(target)
    count = [[0] * 26 for _ in range(n)]
    dp = [[0] * n for _ in range(m)]
    mod = 1000000007

    for i, word in enumerate(words):
        for c in word:
            count[i][ord(c) - ord('a')] += 1

    for i in range(n):
        dp[0][i] = count[i][ord(target[0]) - ord('a')]

    for i in range(1, m):
        for j in range(n):
            for k in range(n):
                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod

    return sum(dp[m-1]) % mod
```

",,
"```python
def canFormArray(arr, pieces):
    map = {piece[0]: piece for piece in pieces}

    i = 0
    while i < len(arr):
        if arr[i] not in map:
            return False
        piece = map[arr[i]]
        for num in piece:
            if num != arr[i]:
                return False
            i += 1
    return True
```


",,
"```python
def countVowelStrings(n: int) -> int:
    dp = [1, 1, 1, 1, 1]
    for i in range(2, n + 1):
        for j in range(3, -1, -1):
            dp[j] = dp[j] + dp[j + 1]
    return sum(dp)
```

",,
"```python
def maxWaterBottles(numBottles: int, numExchange: int) -> int:
    total = numBottles
    while numBottles >= numExchange:
        newBottles = numBottles // numExchange
        total += newBottles
        numBottles = newBottles + numBottles % numExchange
    return total
```

",,
"```python
from collections import defaultdict

def dfs(node, tree, labels, ans, count):
    prev_count = count[labels[node]]
    count[labels[node]] += 1
    ans[node] = count[labels[node]] - prev_count

    for child in tree[node]:
        dfs(child, tree, labels, ans, count)

    count[labels[node]] = prev_count

def countSubTrees(n, edges, labels):
    tree = defaultdict(list)
    for edge in edges:
        tree[edge[1]].append(edge[0])

    ans = [0] * n
    count = defaultdict(int)
    dfs(0, tree, labels, ans, count)

    return ans
```

",,
"```python
def max_num_of_substrings(s: str) -> List[str]:
    last = [-1] * 26
    for i, ch in enumerate(s):
        last[ord(ch) - ord('a')] = i
    
    res = []
    pre, max_right = -1, -1
    for i, ch in enumerate(s):
        max_right = max(max_right, last[ord(ch) - ord('a')])
        if max_right == i:
            res.append(s[pre + 1:max_right + 1])
            pre = i
    
    return res
```

",,
"```python
def findKthPositive(arr, k):
    i, num = 0, 1
    while k > 0:
        if i < len(arr) and arr[i] == num:
            i += 1
        else:
            k -= 1
        num += 1
    return num - 1
```

",,
"```python
def can_convert(s, t, k):
    diff = 0
    for i in range(len(s)):
        curr_diff = (ord(t[i]) - ord(s[i]) + 26) % 26
        if curr_diff > 0:
            diff += curr_diff
            k -= curr_diff
    return k >= 0 and k >= diff - len(s) and k % 26 == 0
```

",,
"```python
def minInsertions(s: str) -> int:
    ans, depth = 0, 0
    for i in range(len(s)):
        if s[i] == '(':
            depth += 2
        else:
            if s[i - 1] == '(':
                depth -= 1
            else:
                depth -= 2
            if depth < 0:
                ans -= depth
                depth = 0
    return ans + depth
```

",,
"```python
def maxNonOverlapping(nums, target):
    prefix_sum = {0: 1}
    sum_so_far = count = 0
    for num in nums:
        sum_so_far += num
        if sum_so_far - target in prefix_sum:
            count += 1
            prefix_sum.clear()
            prefix_sum[0] = 1
            sum_so_far = 0
        else:
            prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1
    return count
```


",,
"```python
class Node:
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

def lowest_common_ancestor(p, q):
    a, b = p, q
    while a != b:
        a = a.parent if a.parent else q
        b = b.parent if b.parent else p
    return a
```

",,
"```python
def minOperations(target: str) -> int:
    operations = 0
    current_bit = '0'
    for bit in target:
        if bit != current_bit:
            operations += 1
            current_bit = bit
    return operations
```

",,
"```python
def dfs(root, distance, depths):
    if not root:
        return 0
    if not root.left and not root.right:
        depths.append(0)
        return 1
    left, right = [], []
    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)
    for l in left:
        for r in right:
            if l + r + 2 <= distance:
                count += 1
    depths.extend(l + 1 for l in left)
    depths.extend(r + 1 for r in right)
    return count

def countPairs(root, distance):
    depths = []
    return dfs(root, distance, depths)
```

",,
"```python
from collections import deque

def minimumJumps(forbidden, a, b, x):
    forbidden_positions = set(forbidden)
    q = deque([(0, 0, 0)])
    visited = {(0, 0)}
    while q:
        pos, steps, backward = q.popleft()
        if pos == x:
            return steps
        forward_pos = pos + a
        backward_pos = pos - b
        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:
            visited.add((forward_pos, 0))
            q.append((forward_pos, steps + 1, 0))
        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:
            visited.add((backward_pos, 1))
            q.append((backward_pos, steps + 1, 1))
    return -1
```

",,
"```python
from collections import Counter

def canDistribute(nums, quantity):
    counts = Counter(nums)
    values = list(counts.values())
    quantity.sort(reverse=True)

    def dfs(index, values):
        if index == len(quantity):
            return True
        for i in range(len(values)):
            if values[i] >= quantity[index]:
                values[i] -= quantity[index]
                if dfs(index + 1, values):
                    return True
                values[i] += quantity[index]
        return False

    return dfs(0, values)
```


",,
"```python
def count_good_triplets(arr, a, b, c):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if abs(arr[i] - arr[j]) <= a:
                for k in range(j+1, len(arr)):
                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        count += 1
    return count
```


",,
"```python
def get_winner(arr, k):
    winner = arr[0]
    consecutive_wins = 0

    for i in range(1, len(arr)):
        if arr[i] > winner:
            winner = arr[i];
            consecutive_wins = 0

        consecutive_wins += 1
        if consecutive_wins == k:
            break

    return winner
```

",,
"```python
def min_swaps(grid):
    n = len(grid)
    row_zeros = [0] * n
    
    for i in range(n):
        for j in range(n - 1, -1, -1):
            if grid[i][j] == 0:
                row_zeros[i] += 1
            else:
                break
    
    steps = 0
    for i in range(n):
        target = n - i - 1
        current_row = i
        while current_row < n and row_zeros[current_row] < target:
            current_row += 1
        if current_row == n:
            return -1
        steps += current_row - i
        row_zeros.pop(current_row)
        row_zeros.insert(i, target)
    
    return steps
```

",,
"```python
def maxSum(nums1, nums2):
    mod = 10**9 + 7
    m, n = len(nums1), len(nums2)
    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)
    i, j = m - 1, n - 1
    while i >= 0 or j >= 0:
        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')
        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')
        seen = set()
        if a > b:
            dp1[i] = a % mod
            i -= 1
            seen.add(nums1[i + 1])
        else:
            dp2[j] = b % mod
            j -= 1
            seen.add(nums2[j + 1])
    return max(dp1[0], dp2[0]) % mod
```

",,
"```python
def thousand_separator(n: int) -> str:
    result = str(n)
    count = 0
    for i in range(len(result) - 1, 0, -1):
        count += 1
        if count % 3 == 0:
            result = result[:i] + '.' + result[i:]
    return result
```

",,
"```python
def min_num_operations(nums):
    result = 0
    highest_bit = [0] * 32
    for num in nums:
        for j in range(32):
            if num & (1 << j):
                highest_bit[j] += 1
    for count in highest_bit:
        result = max(result, count)
    return result + 31
```

",,
"```python
def contains_cycle(grid):
    def dfs(x, y, start_x, start_y, depth):
        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != grid[start_x][start_y]:
            return False
        
        grid[x][y] = '*'

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy

            if new_x == start_x and new_y == start_y and depth >= 4:
                return True

            if dfs(new_x, new_y, start_x, start_y, depth + 1):
                return True
        
        grid[x][y] = grid[start_x][start_y]

        return False

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if dfs(i, j, i, j, 0):
                return True

    return False
```

",,
"```python
def numberOfFairs(nums):
    even_sum = sum(nums[0::2])
    odd_sum = sum(nums[1::2])
    l_even = l_odd = count = 0
    for i, num in enumerate(nums):
        if i % 2 == 0:
            even_sum -= num
            if l_even + odd_sum == l_odd + even_sum:
                count += 1
            l_even += num
        else:
            odd_sum -= num
            if l_even + odd_sum == l_odd + even_sum:
                count += 1
            l_odd += num
    return count
```

",,
"```python
def minimumEffort(tasks):
    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)
    ans, sum_energy = 0, 0
    for task in tasks:
        ans = max(ans, sum_energy + task[1])
        sum_energy += task[0]
    return ans
```

",,
"```python
def make_good(s: str) -> str:
    result = []
    for c in s:
        if result and abs(ord(result[-1]) - ord(c)) == 32:
            result.pop()
        else:
            result.append(c)
    return """".join(result)
```


",,
"```python
def longestAwesomeSubstring(s):
    n = len(s)
    maxLen = 0
    for i in range(n):
        for j in range(i + 1, n + 1):
            substr = s[i:j]
            if isAwesome(substr):
                maxLen = max(maxLen, j - i)
    return maxLen

def isAwesome(s):
    odd_count = 0
    freq = [0] * 26
    for c in s:
        freq[ord(c) - ord('a')] += 1
    for i in range(26):
        if freq[i] % 2 == 1:
            odd_count += 1
    return odd_count <= 1
```

",,
"```python
def minCost(n, cuts):
    cuts = [0] + cuts + [n]
    cuts.sort()
    size = len(cuts)
    dp = [[0] * size for _ in range(size)]

    for len in range(2, size):
        for i in range(size - len):
            j = i + len
            dp[i][j] = float('inf')
            for k in range(i + 1, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])

    return dp[0][size - 1]
```

",,
"```python
from collections import deque

class FrontMiddleBackQueue:

    def __init__(self):
        self.first = deque()
        self.second = deque()

    def pushFront(self, val: int) -> None:
        self.first.appendleft(val)
        if len(self.first) > len(self.second) + 1:
            self.second.appendleft(self.first.pop())

    def pushMiddle(self, val: int) -> None:
        if len(self.first) < len(self.second):
            self.first.append(val)
        else:
            self.second.appendleft(val)

    def pushBack(self, val: int) -> None:
        self.second.append(val)
        if len(self.second) > len(self.first):
            self.first.append(self.second.popleft())

    def popFront(self) -> int:
        if not self.first and not self.second:
            return -1
        val = self.first.popleft()
        if len(self.first) + 1 < len(self.second):
            self.first.append(self.second.popleft())
        return val

    def popMiddle(self) -> int:
        if not self.first and not self.second:
            return -1
        if len(self.first) < len(self.second):
            val = self.second.popleft()
        else:
            val = self.first.pop()
        if len(self.second) > len(self.first):
            self.first.append(self.second.popleft())
        return val

    def popBack(self) -> int:
        if not self.first and not self.second:
            return -1
        val = self.second.pop()
        if len(self.first) > len(self.second) + 1:
            self.second.appendleft(self.first.pop())
        return val
```


",,
"```python
def minimumMountainRemovals(nums):
    n = len(nums)
    left, right = [0] * n, [0] * n
    for i in range(1, n):
        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])
        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])
    ans = n - 3
    for i in range(1, n - 1):
        ans = min(ans, n - 1 - left[i] - right[i])
    return ans
```

",,
"```python
def maximumWealth(accounts):
    max_wealth = 0
    for customer in accounts:
        wealth = sum(customer)
        max_wealth = max(max_wealth, wealth)
    return max_wealth
```

",,
"```python
from collections import deque

def mostCompetitive(nums, k):
    stack = deque()
    n = len(nums)
    for i in range(n):
        while stack and stack[-1] > nums[i] and len(stack) + n - i > k:
            stack.pop()
        if len(stack) < k:
            stack.append(nums[i])
    return list(stack)
```


",,
"```python
def min_operations(n):
    return n * (n - 1) // 2
```


",,
"```python
from typing import List

def can_place_balls(force: int, position: List[int], m: int) -> bool:
    last_position = position[0]
    placed_balls = 1

    for i in range(1, len(position)):
        if position[i] - last_position >= force:
            placed_balls += 1
            last_position = position[i]

            if placed_balls == m:
                return True

    return False

def max_distance(position: List[int], m: int) -> int:
    position.sort()

    left = 1
    right = position[-1] - position[0]
    ans = 0

    while left <= right:
        mid = (left + right) // 2
        if can_place_balls(mid, position, m):
            ans = mid
            left = mid + 1
        else:
            right = mid - 1

    return ans
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowestCommonAncestor(root, nodes):
    if root is None or root in nodes:
        return root
    left = lowestCommonAncestor(root.left, nodes)
    right = lowestCommonAncestor(root.right, nodes)
    if left is not None and right is not None:
        return root
    return left if left is not None else right
```


",,
"```python
def num_ways(s: str) -> int:
    number_of_ones = s.count('1')
    if number_of_ones % 3 != 0:
        return 0

    target = number_of_ones // 3
    if target == 0:
        n = len(s)
        return ((n - 1) * (n - 2) // 2) % 1000000007

    ones_so_far1, ones_so_far2 = 0, 0
    way1, way2 = 0, 0
    for c in s:
        if c == '1':
            ones_so_far1 += 1
            if ones_so_far1 == target:
                way1 += 1
                ones_so_far1 = 0

            ones_so_far2 += 1
            if ones_so_far2 == target * 2:
                way2 += 1
                ones_so_far2 = 0

    return (way1 * way2) % 1000000007
```


",,
"```python
def findLengthOfShortestSubarray(arr):
    n = len(arr)
    left, right = 0, n - 1

    while left < n - 1 and arr[left] <= arr[left + 1]:
        left += 1

    if left == n - 1:
        return 0

    while right > 0 and arr[right] >= arr[right - 1]:
        right -= 1

    result = min(right, n - left - 1)

    i, j = 0, right

    while i <= left and j < n:
        if arr[i] <= arr[j]:
            result = min(result, j - i - 1)
            i += 1
        else:
            j += 1

    return result
```


",,
"```python
def count_routes(locations, start, finish, fuel, curr=None, remaining_fuel=None, memo=None):
    if memo is None:
        memo = {}
     
    if curr is None:
        curr = start
        remaining_fuel = fuel

    if remaining_fuel < 0:
        return 0

    if (curr, remaining_fuel) in memo:
        return memo[(curr, remaining_fuel)]

    ans = 1 if curr == finish else 0
    for next in range(len(locations)):
        if next != curr:
            ans += count_routes(locations, start, finish, fuel, next, remaining_fuel - abs(locations[curr] - locations[next]), memo)
            ans %= 1000000007

    memo[(curr, remaining_fuel)] = ans
    return ans
```

",,
"```python
def most_visited(n, rounds):
    visited = [0] * (n + 1)
    
    for i in range(1, len(rounds)):
        start, end = rounds[i - 1], rounds[i]
        while start != end:
            visited[start] += 1
            start = (start % n) + 1
    visited[rounds[-1]] += 1
    
    max_visits = max(visited);
    return [i for i in range(1, n + 1) if visited[i] == max_visits]
```

",,
"```python
def find_latest_step(arr, m):
    n = len(arr)
    length_left, length_right = [0] * (n + 2), [0] * (n + 2)
    count, result = 0, -1

    for i, pos in enumerate(arr):
        left_length = length_right[pos - 1]
        right_length = length_left[pos + 1]
        new_length = left_length + right_length + 1

        if left_length == m or right_length == m:
            count -= 1

        if new_length == m:
            count += 1

        if new_length > 0:
            length_left[pos - left_length] = new_length
            length_right[pos + right_length] = new_length
            result = i + 1

    return result if count > 0 else -1
```


",,
"```python
def stoneGameV(stoneValue):
    memo = [[-1 for _ in range(len(stoneValue))] for _ in range(len(stoneValue))]
    return maxScore(stoneValue, 0, len(stoneValue) - 1, memo)

def maxScore(stoneValue, start, end, memo):
    if start == end:
        return 0
    if memo[start][end] != -1:
        return memo[start][end]

    left_sum, right_sum = 0, 0
    for i in range(start, end):
        left_sum += stoneValue[i]
        right_sum = sum(stoneValue[i + 1:end + 1])

        if left_sum > right_sum:
            memo[start][end] = max(memo[start][end], right_sum + maxScore(stoneValue, i + 1, end, memo))
        elif left_sum < right_sum:
            memo[start][end] = max(memo[start][end], left_sum + maxScore(stoneValue, start, i, memo))
        else:
            memo[start][end] = max(memo[start][end], left_sum + max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)))

    return memo[start][end]
```


",,
"```python
def stoneGameVI(aliceValues, bobValues):
    n = len(aliceValues)
    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)

    aliceSum, bobSum = 0, 0
    for i in range(n):
        if i % 2 == 0:
            aliceSum += aliceValues[diff[i][1]]
        else:
            bobSum += bobValues[diff[i][1]]
            
    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)
```


",,
"```python
def min_trips(boxes, portsCount, maxBoxes, maxWeight):
    trips = 0
    idx = 0
    n = len(boxes)
    while idx < n:
        curr_limit = maxWeight
        prev_port = 0
        count = 0
        while count < maxBoxes and idx < n:
            if boxes[idx][1] <= curr_limit:
                if prev_port != boxes[idx][0]:
                    prev_port = boxes[idx][0]
                    trips += 1
                curr_limit -= boxes[idx][1]
                count += 1
                idx += 1
            else:
                break
        trips += 1
    return trips
```

",,
"```python
def numberOfMatches(n: int) -> int:
    matches = 0
    while n > 1:
        matches += n // 2
        n = (n + 1) // 2
    return matches
```

",,
"```python
def containsPattern(arr, m, k):
    n = len(arr)
    if m * k > n:
        return False

    for i in range(n - m * k + 1):
        patternFound = True
        for j in range(m):
            for l in range(1, k):
                if arr[i + j] != arr[i + j + l * m]:
                    patternFound = False
                    break
            if not patternFound:
                break
        if patternFound:
            return True
    return False
```

",,
"```python
def getMaxLen(nums):
    maxLength = currentLen = currentNegLen = 0
    
    for num in nums:
        if num > 0:
            currentLen += 1
            if currentNegLen > 0:
                currentNegLen += 1
        elif num < 0:
            currentLen, currentNegLen = currentNegLen, currentLen + 1
        else:
            currentLen = currentNegLen = 0
        maxLength = max(maxLength, currentLen)
    
    return maxLength
```

",,
"```python
def numTrees(n: int) -> int:
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - 1 - j]
            dp[i] %= (10**9 + 7)

    return dp[n]
```

",,
"```python
def min_subarray(nums, p):
    n = len(nums)
    need, cur, res = 0, 0, n
    last_seen = {}

    for num in nums:
        need = (need + num) % p

    if need == 0:
        return 0

    last_seen[cur] = -1
    for i, num in enumerate(nums):
        cur = (cur + num) % p
        last_seen[cur] = i
        want = (cur - need + p) % p
        if want in last_seen:
            res = min(res, i - last_seen[want])

    return res if res != n else -1
```


",,
"```python
from typing import List

def maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -> int:
    mod = 10**9 + 7
    n = len(nums)
    cnt = [0] * n
    
    for req in requests:
        cnt[req[0]] += 1
        if req[1] + 1 < n:
            cnt[req[1] + 1] -= 1
    
    for i in range(1, n):
        cnt[i] += cnt[i - 1]
    
    nums.sort()
    cnt.sort()
    
    ans = sum(nums[i] * cnt[i] for i in range(n)) % mod
    
    return ans
```

",,
"```python
def isPrintable(targetGrid):
    m, n = len(targetGrid), len(targetGrid[0])
    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61
    vis = [[False]*n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            c = targetGrid[i][j]
            top[c] = min(top[c], i)
            bottom[c] = max(bottom[c], i)
            left[c] = min(left[c], j)
            right[c] = max(right[c], j)

    def dfs(x):
        i, j = x // n, x % n
        if vis[i][j]: return True
        c = targetGrid[i][j]
        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False
        vis[i][j] = True
        for k in range(1, 61):
            if k == c: continue
            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False
            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False
        return True

    for color in range(1, 61):
        for i in range(top[color], bottom[color] + 1):
            for j in range(left[color], right[color] + 1):
                if not vis[i][j] and not dfs(i * n + j): return False

    return True
```


",,
"```python
from collections import defaultdict, deque

def distanceLimitedPathsExist(n, edgeList, queries):
    graph = defaultdict(list)

    for u, v, dis in edgeList:
        graph[u].append((v, dis))
        graph[v].append((u, dis))

    answer = [False] * len(queries)
    for i, (pj, qj, limitj) in enumerate(queries):
        q = deque([(pj, 0)])
        visited = [False] * n
        visited[pj] = True

        while q:
            curr_node, curr_dist = q.popleft()

            for next_node, next_dist in graph[curr_node]:
                if curr_dist + next_dist < limitj:
                    if next_node == qj:
                        answer[i] = True
                        break
                    if not visited[next_node]:
                        visited[next_node] = True
                        q.append((next_node, curr_dist + next_dist))
            if answer[i]:
                break

    return answer
```

",,
"```python
def modifyString(s: str) -> str:
    s = list(s)
    for i in range(len(s)):
        if s[i] == '?':
            for c in range(ord('a'), ord('z') + 1):
                if (i - 1 < 0 or s[i - 1] != chr(c)) and (i + 1 >= len(s) or s[i + 1] != chr(c)):
                    s[i] = chr(c)
                    break
    return ''.join(s)
```


",,
"```python
def min_time_to_remove_balloons(colors, neededTime):
    n = len(colors)
    INF = 10**9
    dp = [[INF] * 26 for _ in range(n)]

    for color in range(26):
        if colors[0] != chr(ord('A') + color):
            dp[0][color] = neededTime[0]

    for i in range(1, n):
        for color1 in range(26):
            for color2 in range(26):
                if color1 != color2 and colors[i] != chr(ord('A') + color1):
                    dp[i][color1] = min(dp[i][color1], dp[i-1][color2] + neededTime[i])

    ans = INF
    for color in range(26):
        ans = min(ans, dp[n-1][color])

    return ans
```


",,
"```python
def maxNumEdgesToRemove(n, edges):
    def find(u):
        if parent[u] == u:
            return u
        else:
            parent[u] = find(parent[u])
            return parent[u]

    def unite(u, v):
        u = find(u)
        v = find(v)
        if u != v:
            parent[u] = v
            return True
        return False

    parent = list(range(2 * n + 1))
    ct = [0, 0]
    both = n - 1
    edges.sort(reverse=True)
    for edge in edges:
        type, u, v = edge
        if type == 3 and unite(u, v + n):
            both -= 1
        if both == 0:
            break

    for type in range(1, 3):
        for edge in edges:
            a, u, v = edge
            if a == type and unite(u, v + n):
                ct[type - 1] += 1
        if both + ct[type - 1] < n - 1:
            return -1

    return ct[0] + ct[1] - n + 1
```


",,
"```python
def maximum_binary_string(binary: str) -> str:
    zero_count = binary.count('0')
    
    if zero_count <= 1:
        return binary
    
    one_count = len(binary) - zero_count

    result = ""1"" * one_count + ""0"" * (zero_count - 1) + ""1####1""
    return result[:len(binary)]
```

",,
"```python
def minMoves(nums, k):
    ones_pos = [i for i, x in enumerate(nums) if x == 1]
    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]
    min_moves = sum(to_move[k // 2:])
    move = min_moves
    for left, right in zip(
        to_move[:-k],       # left ""window"" of k-sized sliding window
        to_move[k // 2 + 1:],  # right ""window"" of k-sized sliding window
    ):
        move += left - right
        min_moves = min(min_moves, move)
    return min_moves
```

",,
"```python
def numSpecial(mat):
    m, n = len(mat), len(mat[0])
    row, col = [0] * m, [0] * n

    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1:
                row[i] += 1
                col[j] += 1

    special_positions = 0
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1 and row[i] == 1 and col[j] == 1:
                special_positions += 1

    return special_positions
```

",,
"```python
def unhappyFriends(n, preferences, pairs):
    pair_mapping = [0] * n
    for pair in pairs:
        pair_mapping[pair[0]] = pair[1]
        pair_mapping[pair[1]] = pair[0]

    unhappy_count = 0
    for x in range(n):
        y = pair_mapping[x]
        pref_x = preferences[x]
        idx_y = pref_x.index(y)

        for i in range(idx_y):
            u = pref_x[i]
            v = pair_mapping[u]
            pref_u = preferences[u]
            if x in pref_u[:pref_u.index(v)]:
                unhappy_count += 1
                break

    return unhappy_count // 2
```


",,
"```python
def minCostConnectPoints(points):
    n = len(points)
    cost = [float('inf')] * n
    visited = [False] * n
    cost[0] = 0

    ans = 0

    for _ in range(n):
        min_cost = float('inf')
        cur_point = -1
        for j in range(n):
            if not visited[j] and cost[j] < min_cost:
                min_cost = cost[j]
                cur_point = j

        visited[cur_point] = True
        ans += min_cost

        for j in range(n):
            if not visited[j]:
                new_cost = abs(points[cur_point][0] - points[j][0]) + abs(points[cur_point][1] - points[j][1])
                cost[j] = min(cost[j], new_cost)

    return ans
```


",,
"```python
def can_transform(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
            j += 1
        else:
            i += 1
    return j == len(t)
```


",,
"```python
class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.slots = [big, medium, small]

    def addCar(self, carType: int) -> bool:
        if self.slots[carType - 1] > 0:
            self.slots[carType - 1] -= 1
            return True
        else:
            return False
```

",,
"```python
import heapq

def busiest_servers(k, arrival, load):
    server_requests = [0] * k
    pq = []
    available_servers = list(range(k))

    for i in range(len(arrival)):
        while pq and pq[0][0] <= arrival[i]:
            _, server_id = heapq.heappop(pq)
            available_servers.append(server_id)

        if available_servers:
            server_id = available_servers.pop(0)
            server_requests[server_id] += 1
            heapq.heappush(pq, (arrival[i] + load[i], server_id))

    max_requests = max(server_requests)
    return [i for i in range(k) if server_requests[i] == max_requests]
```


",,
"```python
def restoreMatrix(rowSum, colSum):
    m, n = len(rowSum), len(colSum)
    result = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            value = min(rowSum[i], colSum[j])
            result[i][j] = value
            rowSum[i] -= value
            colSum[j] -= value

    return result
```

",,
"```python
def waysToSplit(nums):
    MOD = 10**9 + 7
    n = len(nums)
    prefixSum = [0] * (n + 1)
    for i in range(n):
        prefixSum[i + 1] = prefixSum[i] + nums[i]
    
    ans = 0
    left, right = 0, 0
    for mid in range(1, n - 1):
        while left + 1 < mid and prefixSum[left + 1] * 2 <= prefixSum[mid]:
            left += 1
        while right < mid or (right + 1 < n and prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1]):
            right += 1
        if right >= mid and prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]:
            ans = (ans + right - mid + 1) % MOD

    return ans
```

",,
"```python
from bisect import bisect_left

def minOperations(target, arr):
    pos = {x: i for i, x in enumerate(target)}

    dp = []
    for a in arr:
        if a in pos:
            idx = bisect_left(dp, pos[a])
            if idx == len(dp):
                dp.append(pos[a])
            else:
                dp[idx] = pos[a]
    return len(target) - len(dp)
```

",,
"```python
def reorder_spaces(text: str) -> str:
    spaces = text.count(' ')
    words = text.split()
    
    if len(words) == 1:
        return words[0] + ' ' * spaces

    space_between_words = spaces // (len(words) - 1)
    extra_spaces = spaces % (len(words) - 1)
    result = ''
    
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            result += ' ' * space_between_words
    
    result += ' ' * extra_spaces

    return result
```

",,
"```python
def maxProductPath(grid):
    m, n, mod = len(grid), len(grid[0]), int(1e9 + 7)
    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]
    
    dp[0][0] = [grid[0][0], grid[0][0]]
    
    for i in range(1, m):
        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]]
    for j in range(1, n):
        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]]
    
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] < 0:
                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]
                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]
            else:
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]
                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]
            
    return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1
```


",,
"```python
def min_cost(cost, size1, size2):
    dp = [float('inf')] * (size2 + 1)
    dp[0] = 0

    for i in range(size1):
        for j in range(size2, -1, -1):
            min_cost = float('inf')
            for k in range(size2):
                if (1 << k) & j == 0:
                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)])
            dp[j] = min(dp[j], min_cost)

    return dp[(1 << size2) - 1]
```

",,
"```python
class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        res = [0] * (2 * n - 1)

        def backtrack(i, unused):
            if i == len(res):
                return True
            if res[i]:
                return backtrack(i + 1, unused)
            for num in range(n, 0, -1):
                if (unused >> num) & 1:
                    if num == 1 or (i + num < len(res) and not res[i + num]):
                        res[i] = num
                        if num > 1:
                            res[i + num] = num
                        if backtrack(i + 1, unused ^ (1 << num)):
                            return True
                        res[i] = 0
                        if num > 1:
                            res[i + num] = 0
            return False

        backtrack(0, (1 << (n + 1)) - 2)
        return res
```

",,
"```python
def check_ways(pairs):
    candidates = {}
    for x, y in pairs:
        candidates[x] = candidates.get(x, 0) + 1
        candidates[y] = candidates.get(y, 0) + 1

    root_count = sum(1 for v in candidates.values() if v == 1)
    return min(root_count, 2)
```

",,
"```python
def minOperations(logs):
    depth = 0
    for log in logs:
        if log == ""../"":
            if depth > 0:
                depth -= 1
        elif log != ""./"":
            depth += 1
    return depth
```


",,
"```python
def min_operations_max_profit(customers, boarding_cost, running_cost):
    rotations = waiting = on_board = profit = max_profit = max_rotations = 0
    while customers or waiting > 0:
        if customers:
            waiting += customers.pop(0)
            
        on_board = min(waiting, 4)
        waiting -= on_board
        profit += on_board * boarding_cost - running_cost
        rotations += 1
        
        if profit > max_profit:
            max_profit = profit
            max_rotations = rotations
            
    return max_rotations if max_profit > 0 else -1
```


",,
"```python
class ThroneInheritance:
    def __init__(self, kingName: str):
        self.children = {}
        self.alive = {kingName: True}
        self.king = kingName

    def birth(self, parentName: str, childName: str):
        if parentName not in self.children:
            self.children[parentName] = []
        self.children[parentName].append(childName)
        self.alive[childName] = True

    def death(self, name: str):
        self.alive[name] = False

    def getInheritanceOrder(self):
        order = []
        self.getSuccessor(self.king, order)
        return order

    def getSuccessor(self, name: str, order: list):
        if self.alive[name]:
            order.append(name)
        for child in self.children.get(name, []):
            self.getSuccessor(child, order)
```

",,
"```python
def max_achievable_requests(n, requests, idx=0, counts=None):
    if counts is None:
        counts = [0] * n
    if idx == len(requests):
        if all(count == 0 for count in counts):
            return 0
        return 0

    ignored = max_achievable_requests(n, requests, idx+1, counts[:])
    counts[requests[idx][0]] += 1
    counts[requests[idx][1]] -= 1

    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)

    return max(ignored, accepted)
```

",,
"```python
class DistanceLimitedPathsExist:
    def __init__(self, n: int, edgeList: List[List[int]]):
        self.id = list(range(n))
        edgeList.sort(key=lambda x: x[2])
        self.mst = []
        for edge in edgeList:
            p, q = self.find(edge[0]), self.find(edge[1])
            if p != q:
                self.id[p] = self.id[q]
                self.mst.append(edge)

    def query(self, p: int, q: int, limit: int) -> bool:
        for edge in self.mst:
            if edge[2] >= limit:
                break
            p, q = self.union_set(edge[0], p), self.union_set(edge[1], q)
            if p == q:
                return True
        return False

    def find(self, x: int) -> int:
        if self.id[x] != x:
            self.id[x] = self.find(self.id[x])
        return self.id[x]

    def union_set(self, x: int, y: int) -> int:
        px, py = self.find(x), self.find(y)
        if px != py:
            self.id[px] = py
        return py
```

",,
"```python
def numberOfSets(n, k):
    mod = 10**9 + 7
    dp = [[0] * (k + 1) for _ in range(n)]
    presum = [1] * n
    
    for j in range(1, k + 1):
        for i in range(n):
            dp[i][j] = presum[i]
            if i > 0:
                dp[i][j] += dp[i - 1][j]
            dp[i][j] %= mod
            presum[i] = (presum[i] + dp[i][j - 1]) % mod
    
    return dp[n - 1][k]
```

",,
"```python
from math import sqrt

def best_coordinate(towers, radius):
    max_quality = 0
    best_x, best_y = 0, 0

    for x in range(51):
        for y in range(51):
            sum_quality = 0
            for tower in towers:
                dist = sqrt((x - tower[0])**2 + (y - tower[1])**2)
                if dist <= radius:
                    sum_quality += tower[2] // (1 + dist)
            if sum_quality > max_quality:
                max_quality = sum_quality
                best_x, best_y = x, y

    return [best_x, best_y]
```

",,
"```python
def canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) -> bool:
    rows, cols = len(grid), len(grid[0])
    cat_r = cat_c = mouse_r = mouse_c = 0

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 'C':
                cat_r, cat_c = r, c
            elif grid[r][c] == 'M':
                mouse_r, mouse_c = r, c

    dirs = [-1, 0, 1, 0, -1]

    def dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c):
        if cnt >= 100:
            return False
        if r_m < 0 or r_m >= rows or c_m < 0 or c_m >= cols:
            return False
        if r_c < 0 or r_c >= rows or c_c < 0 or c_c >= cols:
            return True
        if grid[r_m][c_m] == 'F' or cnt != dst_m_c:
            return True
        elif grid[r_m][c_m] == '#' or cnt + 1 == dst_m_c:
            return False

        res = False
        for i in range(4):
            jump = catJump if dst_m_c == cnt else mouseJump
            res |= not dfs(r_m + jump * dirs[i], c_m + jump * dirs[i + 1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c)
            if jump == 1:
                break

        return res

    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c))
```

",,
"```python
class Fancy:
    def __init__(self):
        self.sequence = []

    def append(self, val):
        self.sequence.append(val)

    def addAll(self, inc):
        self.sequence = [num + inc for num in self.sequence]

    def multAll(self, m):
        self.sequence = [num * m for num in self.sequence]

    def getIndex(self, idx):
        if idx >= len(self.sequence):
            return -1
        return self.sequence[idx]
```


",,
"```python
def find_special_integer(nums):
    for x in range(1, len(nums) + 1):
        count = sum(1 for num in nums if num >= x)
        if count == x:
            return x
    return -1
```

",,
"```python
def min_operations(n):
    operations = 0
    while n > 0:
        if n % 2 == 0:
            n //= 2
        else:
            n -= 1
        operations += 1
    return operations
```

",,
"```python
from math import atan2, degrees

def visiblePoints(points, angle, location):
    angles = [degrees(atan2(y - location[1], x - location[0])) for x, y in points if [x, y] != location]
    angles.sort()
    angles += [a + 360 for a in angles]
    n = len(angles)
    max_points, j = 0, 0
    for i in range(2 * n):
        while angles[i] - angles[j] > angle:
            j += 1
        max_points = max(max_points, i - j + 1)
    return max_points + points.count(location)
```


",,
"```python
def decode(encoded):
    n = len(encoded) + 1
    total_xor = 0
    
    for i in range(1, n + 1):
        total_xor ^= i

    non_first_xor = 0
    for i in range(1, n - 1, 2):
        non_first_xor ^= encoded[i]

    perm = [total_xor ^ non_first_xor]
    for i in range(1, n):
        perm.append(perm[-1] ^ encoded[i - 1])
    
    return perm
```


",,
"```python
MOD = 10**9 + 7

def mul(a, b):
    return (a * b) % MOD

def ways(n, k, mem):
    if n == 1:
        return k
    if (n_tuple := (n, k)) in mem:
        return mem[n_tuple]
    if k == 1:
        mem[n_tuple] = 1
        return 1
    if n > k:
        mem[n_tuple] = 0
        return 0
    res = mul(ways(n, k - 1, mem), n)
    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD
    mem[n_tuple] = res
    return res

def waysToFillArray(queries):
    mem = {}
    ans = []
    for q in queries:
        ans.append(ways(q[0], q[1], mem))
    return ans
```

",,
"```python
def maximumTime(time: str) -> str:
    time_list = list(time)
    if time_list[0] == '?':
        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'
    if time_list[1] == '?':
        time_list[1] = '3' if time_list[0] == '2' else '9'
    if time_list[3] == '?':
        time_list[3] = '5'
    if time_list[4] == '?':
        time_list[4] = '9'
    return """".join(time_list)
```

",,
"```python
def maxDepth(s: str) -> int:
    depth, max_depth = 0, 0
    for ch in s:
        if ch == '(':
            depth += 1
        elif ch == ')':
            depth -= 1
        max_depth = max(max_depth, depth)
    return max_depth
```

",,
"```python
def maximalNetworkRank(n, roads):
    degree = [0] * n
    s = set()
    
    for road in roads:
        degree[road[0]] += 1
        degree[road[1]] += 1
        s.add(tuple(sorted(road)))
    
    ans = 0
    for i in range(n):
        for j in range(i + 1, n):
            ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0))
    return ans
```


",,
"```python
def check_palindrome_formation(a: str, b: str) -> bool:
    def is_palindrome(s: str, left: int, right: int) -> bool:
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    i, j = 0, len(a) - 1
    while i < j:
        if a[i] != b[j]:
            return is_palindrome(a, i, j) or is_palindrome(b, i, j)
        i += 1
        j -= 1
    return True
```

",,
"```python
from collections import defaultdict

def countSubgraphsForEachD(n, edges):
    tree = defaultdict(list)
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)

    def dfs(node, parent):
        depth = 0
        for child in tree[node]:
            if child != parent:
                depth = max(depth, 1 + dfs(child, node))
        return depth

    ans = [0] * (n - 1)
    for i in range(1, n + 1):
        maxD = dfs(i, 0)
        if maxD > 0:
            ans[maxD - 1] += 1

    return ans
```

",,
"```python
def maxWidthOfVerticalArea(points):
    xs = sorted([point[0] for point in points])
    max_width = 0
    for i in range(1, len(xs)):
        max_width = max(max_width, xs[i] - xs[i - 1])
    return max_width
```


",,
"```python
def count_substrings_with_one_difference(s, t):
    count = 0
    for i in range(len(s)):
        for j in range(len(t)):
            differences = 0
            k = 0
            while i + k < len(s) and j + k < len(t):
                if s[i + k] != t[j + k]:
                    differences += 1
                if differences == 2:
                    break
                if differences == 1:
                    count += 1
                k += 1
    return count
```

",,
"```python
def num_ways(words, target):
    n, m = len(words), len(target)
    MOD = 10**9 + 7
    cnt = [0] * 26
    for word in words:
        for ch in word:
            cnt[ord(ch) - ord('a')] += 1
    dp = [0] * (m + 1)
    dp[0] = 1
    for ch in target:
        for i in range(m - 1, -1, -1):
            dp[i + 1] += dp[i] * cnt[ord(ch) - ord('a')]
            dp[i + 1] %= MOD
    return dp[m]
```

",,
"```python
def is_palindrome(s, start, end):
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True

def check_partitioning(s):
    n = len(s)
    for i in range(0, n - 2):
        if is_palindrome(s, 0, i):
            for j in range(i + 1, n - 1):
                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):
                    return True
    return False
```

",,
"```python
def maxLengthBetweenEqualCharacters(s: str) -> int:
    max_length = -1
    char_index_map = {}

    for i, char in enumerate(s):
        if char in char_index_map:
            max_length = max(max_length, i - char_index_map[char] - 1)
        else:
            char_index_map[char] = i

    return max_length
```

",,
"```python
def bestTeamScore(scores, ages):
    players = sorted(zip(ages, scores))
    n = len(players)
    dp = [0] * n
    best_score = 0
    
    for i in range(n):
        dp[i] = players[i][1]
        for j in range(i):
            if players[i][1] >= players[j][1]:
                dp[i] = max(dp[i], dp[j] + players[i][1])
        best_score = max(best_score, dp[i])
    
    return best_score
```


",,
"```python
def maxAbsoluteSum(nums):
    max_sum = max_end = min_sum = min_end = 0
    for num in nums:
        max_end = max(max_end + num, num)
        min_end = min(min_end + num, num)
        max_sum = max(max_sum, max_end)
        min_sum = min(min_sum, min_end)
    return max(max_sum, -min_sum)
```

",,
"```python
def minimumLength(s: str) -> int:
    if not s: return 0
    i, j = 0, len(s) - 1
    while i < j:
        if s[i] != s[j]: break
        remove_char = s[i]
        while i < len(s) and s[i] == remove_char: i += 1
        while j >= 0 and s[j] == remove_char: j -= 1
    return max(0, j - i + 1)
```

",,
"```python
def slowestKey(releaseTimes, keysPressed):
    max_key = keysPressed[0]
    max_duration = releaseTimes[0]
    for i in range(1, len(releaseTimes)):
        duration = releaseTimes[i] - releaseTimes[i - 1]
        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):
            max_key = keysPressed[i]
            max_duration = duration
    return max_key
```


",,
"```python
def check_arithmetic_subarrays(nums, l, r):
    results = []
    for i in range(len(l)):
        subarray = sorted(nums[l[i]:r[i] + 1])
        is_arithmetic = True
        diff = subarray[1] - subarray[0]
        for j in range(1, len(subarray) - 1):
            if subarray[j + 1] - subarray[j] != diff:
                is_arithmetic = False
                break
        results.append(is_arithmetic)
    return results
```


",,
"```python
import heapq
from typing import List

def minimumEffortPath(heights: List[List[int]]) -> int:
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    rows = len(heights)
    cols = len(heights[0])
    efforts = [[float('inf')] * cols for _ in range(rows)]

    q = [(0, 0, 0)]
    efforts[0][0] = 0
    
    while q:
        effort, x, y = heapq.heappop(q)
        
        if x == rows - 1 and y == cols - 1:
            return effort
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols:
                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))
                if new_effort < efforts[nx][ny]:
                    efforts[nx][ny] = new_effort
                    heapq.heappush(q, (new_effort, nx, ny))
    
    return -1
```


",,
"```python
def largest_merge(word1: str, word2: str) -> str:
    merge = []
    while word1 or word2:
        if word1 > word2:
            merge.append(word1[0])
            word1 = word1[1:]
        else:
            merge.append(word2[0])
            word2 = word2[1:]
    return ''.join(merge)
```

",,
"```python
def decrypt(code, k):
    n = len(code)
    result = [0] * n
    if k == 0: return result
    
    for i in range(n):
        sum = 0
        for j in range(1, abs(k) + 1):
            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]
        result[i] = sum
    return result
```

",,
"```python
def min_deletions(s: str) -> int:
    a_count, deletions = 0, 0
    for c in s:
        if c == 'a':
            a_count += 1
        else:
            if a_count > 0:
                a_count -= 1
            else:
                deletions += 1
    return deletions
```

",,
"```python
from typing import List

def canDistribute(nums: List[int], quantity: List[int]) -> bool:
    counts = [0] * 51
    for num in nums:
        counts[num] += 1

    quantity.sort(reverse=True)

    def dfs(idx: int) -> bool:
        if idx == len(quantity):
            return True
        for i in range(1, 51):
            if counts[i] >= quantity[idx]:
                counts[i] -= quantity[idx]
                if dfs(idx + 1):
                    return True
                counts[i] += quantity[idx]
        return False

    return dfs(0)
```


",,
"```python
def count_homogenous(s: str) -> int:
    MOD = 1000000007
    count, total = 1, 0
    for i in range(1, len(s)):
        count = count + 1 if s[i] == s[i - 1] else 1
        total = (total + count) % MOD
    return (total + count) % MOD
```

",,
"```python
def can_form_array(arr, pieces):
    piece_map = {piece[0]: piece for piece in pieces}
    
    i = 0
    while i < len(arr):
        if arr[i] not in piece_map:
            return False
        
        for num in piece_map[arr[i]]:
            if arr[i] != num:
                return False
            i += 1
            
    return True
```

",,
"```python
def count_vowel_strings(n):
    dp = [1, 1, 1, 1, 1]

    for i in range(1, n):
        for j in range(3, -1, -1):
            dp[j] += dp[j + 1]

    return sum(dp)
```

",,
"```python
import heapq

def furthest_building(heights, bricks, ladders):
    min_heap = []
    for i in range(len(heights) - 1):
        diff = heights[i + 1] - heights[i]
        if diff > 0:
            heapq.heappush(min_heap, diff)
            if len(min_heap) > ladders:
                bricks -= heapq.heappop(min_heap)
                if bricks < 0:
                    return i
    return len(heights) - 1
```


",,
"```python
def longestNiceSubstring(s: str) -> str:
    n = len(s)
    result = """"
    for i in range(n):
        for j in range(i + 1, n):
            is_nice = True
            for ch in range(ord('A'), ord('Z') + 1):
                upper = chr(ch) in s[i:j+1]
                lower = chr(ch + 32) in s[i:j+1]
                if (upper and not lower) or (not upper and lower):
                    is_nice = False
                    break
            if is_nice and j - i + 1 > len(result):
                result = s[i:j+1]
    return result
```

",,
"```python
def max_k_repeating(sequence, word):
    max_k = 0
    seq_length = len(sequence)
    word_length = len(word)
    for i in range(seq_length - word_length + 1):
        k = 0
        while sequence[i:i + word_length * (k + 1)] == word * (k + 1):
            k += 1
        max_k = max(max_k, k)
    return max_k
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeInBetween(list1, a, b, list2):
    prev, curr = None, list1
    index = 0
    
    while curr:
        if index == a:
            last = list2
            while last.next:
                last = last.next
            prev.next = list2
            last.next = curr.next
            break
            
        if index > a and index < b:
            curr = curr.next
        else:
            prev = curr
            curr = curr.next

        index += 1

    return list1
```

",,
"```python
from bisect import bisect_left

def minimum_mountain_removals(nums):
    n = len(nums)
    left, right = [0] * n, [0] * n
    for i in range(n):
        left[i] = bisect_left(left[:i], nums[i])
        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])

    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1
```

",,
"```python
def mergeAlternately(word1: str, word2: str) -> str:
    result = []
    i, j = 0, 0
    while i < len(word1) and j < len(word2):
        result.append(word1[i])
        result.append(word2[j])
        i += 1
        j += 1
    result += word1[i:]
    result += word2[j:]
    return """".join(result)
```

",,
"```python
def maximum_generated(n: int) -> int:
    if n == 0:
        return 0
    nums = [0] * (n + 1)
    nums[1] = 1
    for i in range(2, n + 1):
        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]
    return max(nums)
```

",,
"```python
def min_deletions(s):
    freq = collections.Counter(s)
    used = set()
    deletions = 0

    for count in freq.values():
        while count in used and count > 0:
            deletions += 1
            count -= 1
        used.add(count)

    return deletions
```

",,
"```python
def maxProfit(inventory, orders):
    mod = 10**9 + 7
    inventory.sort(reverse=True)
    inventory.append(0)
    n, ans, count = len(inventory), 0, 1
    for i in range(n - 1):
        diff = inventory[i] - inventory[i + 1]
        if count * diff < orders:
            orders -= count * diff
            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod
        else:
            q, r = divmod(orders, count)
            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod
            ans = (ans + r * (inventory[i] - q)) % mod
            break
        count += 1
    return ans
```

",,
"```python
from sortedcontainers import SortedList

MOD = int(1e9) + 7

def create_sorted_array(instructions):
    s = SortedList()
    cost = 0

    for i in instructions:
        less_than = s.bisect_left(i)
        greater_than = len(s) - s.bisect_right(i)
        cost = (cost + min(less_than, greater_than)) % MOD
        s.add(i)

    return cost
```

",,
"```python
def countMatches(items, ruleKey, ruleValue):
    count = 0
    index = {""type"": 0, ""color"": 1, ""name"": 2}[ruleKey]
    for item in items:
        if item[index] == ruleValue:
            count += 1
    return count
```

",,
"```python
from itertools import product

def closest_cost(base_costs, topping_costs, target):
    closest = float('inf')
    topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs)))
    
    for base in base_costs:
        for combination in topping_combinations:
            combination_cost = sum(x * y for x, y in zip(topping_costs, combination))
            diff = abs(target - (base + combination_cost))
            if diff < closest:
                closest = diff
            if diff == 0:
                return target

    return target - closest
```

",,
"```python
class OrderedStream:
    def __init__(self, n: int):
        self.ptr = 1
        self.data = {}

    def insert(self, idKey: int, value: str):
        self.data[idKey] = value
        result = []
        while self.ptr in self.data:
            result.append(self.data[self.ptr])
            self.ptr += 1
        return result
```


",,
"```python
def minOperations(nums, x):
    total = sum(nums)
    target = total - x
    if target < 0:
        return -1

    maxLength = -1
    left = 0
    current_sum = 0

    for right in range(len(nums)):
        current_sum += nums[right]

        while current_sum > target:
            current_sum -= nums[left]
            left += 1

        if current_sum == target:
            maxLength = max(maxLength, right - left + 1)

    return -1 if maxLength == -1 else len(nums) - maxLength
```


",,
"```python
from functools import lru_cache

def getMaxGridHappiness(m, n, introvertsCount, extrovertsCount):
    @lru_cache(None)
    def maxHappy(y, mask):
        if y == n:
            return 0

        ans = 0
        for x in range(m + 1):
            happiness = 0
            if mask >> x & 1:
                happiness -= 30
                if x > 0 and mask & 1:
                    happiness -= 30
                else:
                    happiness += 20
            ans = max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1))

        return ans

    return maxHappy(0, 0)
```


",,
"```python
def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:
    min_distance = float(""inf"")
    index = -1
    for i, point in enumerate(points):
        if x == point[0] or y == point[1]:
            distance = abs(x - point[0]) + abs(y - point[1])
            if distance < min_distance:
                min_distance = distance
                index = i
    return index
```

",,
"```python
def check_powers_of_three(n: int) -> bool:
    while n > 0:
        if n % 3 == 2:
            return False
        n //= 3
    return True
```

",,
"```python
def arrayStringsAreEqual(word1, word2):
    return """".join(word1) == """".join(word2)
```

",,
"```python
def get_smallest_string(n: int, k: int) -> str:
    result = ['a'] * n
    k -= n
    idx = n - 1
    while k > 0:
        value = min(k, 25)
        result[idx] = chr(ord(result[idx]) + value)
        k -= value
        idx -= 1
    return ''.join(result)
```

",,
"```python
def minimum_energy(tasks):
    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)

    energy = 0
    for task in tasks:
        energy = max(energy + task[0], task[1])
    return energy
```

",,
"```python
def minElements(nums, limit, goal):
    sum_nums = sum(nums)
    diff = abs(goal - sum_nums)
    
    return (diff + limit - 1) // limit
```


",,
"```python
def count_consistent_strings(allowed, words):
    allowed_set = set(allowed)
    count = 0
    for word in words:
        is_valid = True
        for c in word:
            if c not in allowed_set:
                is_valid = False
                break
        if is_valid:
            count += 1
    return count
```

",,
"```python
def calculate_summation_of_absolute_differences(nums):
    n = len(nums)
    result = [0] * n

    for i in range(n):
        for j in range(n):
            if i != j:
                result[i] += abs(nums[i] - nums[j])

    return result
```

",,
"```python
def stoneGameVI(aliceValues, bobValues):
    n = len(aliceValues)
    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)
    
    aliceScore = sum(aliceValues[i] for _, i in sums[::2])
    bobScore = sum(bobValues[i] for _, i in sums[1::2])
    
    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1
```

",,
"```python
def are_almost_equal(s1, s2):
    if s1 == s2:
        return True
    diff = [i for i in range(len(s1)) if s1[i] != s2[i]]
    return len(diff) == 2 and s1[diff[0]] == s2[diff[1]] and s1[diff[1]] == s2[diff[0]]
```

",,
"```python
def maximum_wealth(accounts):
    return max(sum(customer) for customer in accounts)
```


",,
"```python
def most_competitive(nums, k):
    stack = []
    n = len(nums)

    for i in range(n):
        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:
            stack.pop()
        if len(stack) < k:
            stack.append(nums[i])

    return stack
```

",,
"```python
def min_moves(nums, limit):
    n = len(nums)
    delta = [0] * (2 * limit + 2)

    for i in range(n // 2):
        lo = min(nums[i], nums[n - 1 - i]) + 1
        hi = max(nums[i], nums[n - 1 - i]) + limit
        delta[lo] -= 1
        delta[nums[i] + nums[n - 1 - i]] -= 1
        delta[hi + 1] += 1

    moves, current = n, n
    for i in range(2, 2 * limit + 1):
        current += delta[i]
        moves = min(moves, current)

    return moves
```


",,
"```python
import heapq

def minimum_deviation(nums):
    pq = []
    min_val = float(""inf"")

    for num in nums:
        if num % 2 == 0:
            heapq.heappush(pq, -num)
        else:
            heapq.heappush(pq, -(num * 2))
        min_val = min(min_val, num)

    result = float(""inf"")
    while True:
        top = -heapq.heappop(pq)
        result = min(result, top - min_val)

        if top % 2 == 1:
            break
        heapq.heappush(pq, -(top // 2))
        min_val = min(min_val, top // 2)

    return result
```


",,
"```python
def second_highest(s: str) -> int:
    largest = -1
    second_largest = -1
    for c in s:
        if c.isdigit():
            d = int(c)
            if d > largest:
                second_largest = largest
                largest = d
            elif d < largest and d > second_largest:
                second_largest = d
    return second_largest
```

",,
"```python
def interpret(command: str) -> str:
    result = []
    i = 0
    while i < len(command):
        if command[i] == ""G"":
            result.append(""G"")
            i += 1
        elif command[i:i+2] == ""()"":
            result.append(""o"")
            i += 2
        else:
            result.append(""al"")
            i += 4
    return """".join(result)
```

",,
"```python
def maxOperations(nums, k):
    count = {}
    operations = 0

    for num in nums:
        if count.get(k - num, 0) > 0:
            count[k - num] -= 1
            operations += 1
        else:
            count[num] = count.get(num, 0) + 1

    return operations
```


",,
"```python
from typing import List

def minimumIncompatibility(nums: List[int], k: int) -> int:
    n = len(nums)
    if n % k != 0:
        return -1
    
    nums.sort()
    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]
    
    return sum(diffs)
```

",,
"```python
def concatenated_binary(n: int) -> int:
    result = 0
    mod = 1000000007
    for i in range(1, n + 1):
        length = len(bin(i)) - 2
        result = ((result << length) % mod + i) % mod
    return result
```


",,
"```python
from heapq import *

def getNumberOfBacklogOrders(orders):
    buy_orders, sell_orders = [], []
    num_orders, mod = 0, int(1e9) + 7

    for price, amount, order_type in orders:
        if order_type == 0: # buy order
            while amount and sell_orders and sell_orders[0][0] <= price:
                x = min(amount, sell_orders[0][1])
                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x
                if sell_orders[0][1] == 0:
                    heappop(sell_orders)
            if amount:
                heappush(buy_orders, (-price, amount))
        else: # sell order
            while amount and buy_orders and -buy_orders[0][0] >= price:
                x = min(amount, buy_orders[0][1])
                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x
                if buy_orders[0][1] == 0:
                    heappop(buy_orders)
            if amount:
                heappush(sell_orders, (price, amount))
    
    while buy_orders:
        num_orders = (num_orders + heappop(buy_orders)[1]) % mod

    while sell_orders:
        num_orders = (num_orders + heappop(sell_orders)[1]) % mod

    return num_orders
```

",,
"```python
from collections import deque

def countStudents(students, sandwiches):
    queue = deque(students)
    index, attempts = 0, 0

    while queue:
        student = queue[0]
        if student == sandwiches[index]:
            queue.popleft()
            index += 1
            attempts = 0
        else:
            queue.rotate(-1)
            attempts += 1

        if attempts == len(queue):
            break

    return len(queue)
```

",,
"```python
def average_waiting_time(customers):
    wait_time = 0
    curr_time = 0
    
    for arrival, time in customers:
        curr_time = max(curr_time, arrival) + time
        wait_time += curr_time - arrival
    
    return wait_time / len(customers)
```


",,
"```python
def min_moves(nums, k):
    n = len(nums)
    ones = [i - j for i, j in enumerate(nums) if j == 1]
    
    moves = sum(ones[i] - ones[k // 2] for i in range(k))
    min_moves = moves
    
    for i in range(k, len(ones)):
        moves += ones[i] - ones[i - k] - k
        min_moves = min(min_moves, moves)
    
    return min_moves
```


",,
"```python
def numberOfMatches(n):
    return n - 1
```


",,
"```python
def minPartitions(n: str) -> int:
    max_digit = 0
    for c in n:
        max_digit = max(max_digit, int(c))
        if max_digit == 9:
            break
    return max_digit
```

",,
"```python
def stoneGame(stones):
    n = len(stones)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j])
    
    return dp[0][n - 1]
```

",,
"```python
class Solution:
    def findShortestPath(self, master: 'GridMaster') -> int:
        def dfs(master, x, y):
            nonlocal target
            if master.isTarget():
                target = (x, y)
            for i in range(4):
                nx, ny = x + dirs[i], y + dirs[i + 1]
                if (nx, ny) in grid:
                    continue
                if master.canMove(DIR_CHAR[i]):
                    cost = master.move(DIR_CHAR[i])
                    grid[(nx, ny)] = cost
                    dfs(master, nx, ny)
                    master.move(OPPOSITE_DIR_CHAR[i])
                    
        def bfs():
            q = deque([(0, 0)])
            grid[(0, 0)] = 0
            while q:
                x, y = q.popleft()
                for i in range(4):
                    nx, ny = x + dirs[i], y + dirs[i + 1]
                    cost = grid[(x, y)] + grid.get((nx, ny), 0)
                    if (nx, ny) in grid and grid[(nx, ny)] > cost:
                        grid[(nx, ny)] = cost
                        if (nx, ny) != target:
                            q.append((nx, ny))
            return grid.get(target, -1)
        
        dirs = [-1, 0, 1, 0, -1]
        DIR_CHAR = ""URDL""
        OPPOSITE_DIR_CHAR = ""DLUR""
        grid = {}
        target = None
        
        dfs(master, 0, 0)
        if target is None:
            return -1
        
        return bfs()
```

",,
"```python
def reformat_number(number):
    cleaned_number = ''.join(c for c in number if c.isdigit())

    blocks = []
    n = len(cleaned_number)
    i = 0
    while i < n:
        if n - i == 2 or n - i == 4:
            blocks.append(cleaned_number[i:i + 2])
            i += 2
        else:
            blocks.append(cleaned_number[i:i + 3])
            i += 3

    return '-'.join(blocks)
```

",,
"```python
def maximum_unique_subarray(nums):
    max_sum, current_sum, left = 0, 0, 0
    elements = set()
    
    for right in range(len(nums)):
        while nums[right] in elements:
            elements.remove(nums[left])
            current_sum -= nums[left]
            left += 1
        
        elements.add(nums[right])
        current_sum += nums[right]
        max_sum = max(max_sum, current_sum)
    
    return max_sum
```


",,
"```python
from collections import deque

def maxResult(nums, k):
    n = len(nums)
    dq = deque()
    dp = [0] * n
    
    dp[0] = nums[0]
    dq.append(0)
    
    for i in range(1, n):
        while dq and dq[0] < i - k:
            dq.popleft()
        
        dp[i] = nums[i] + dp[dq[0]]
        
        while dq and dp[i] >= dp[dq[-1]]:
            dq.pop()
        
        dq.append(i)
    
    return dp[-1]
```

",,
"```python
from typing import List

def distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
    edgeList.sort(key=lambda x: x[2])
    queries = sorted(enumerate(queries), key=lambda x: x[1][2])

    def find(x: int, parent: List[int]) -> int:
        if x != parent[x]:
            parent[x] = find(parent[x], parent)
        return parent[x]

    parent = list(range(n))
    res = [False] * len(queries)
    idx = 0

    for query_id, query in queries:
        p, q, limit = query
        while idx < len(edgeList) and edgeList[idx][2] < limit:
            u, v = edgeList[idx][:2]
            ru, rv = find(u, parent), find(v, parent)
            if ru != rv:
                parent[ru] = rv
            idx += 1
        res[query_id] = find(p, parent) == find(q, parent)

    return res
```

",,
"```python
def truncateSentence(s: str, k: int) -> str:
    words = s.split()
    return "" "".join(words[:k])
```

",,
"```python
def total_money(n):
    weeks = n // 7
    days_remaining = n % 7
    return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2
```


",,
"```python
def max_points(s, x, y):
    points = 0
    s = list(s)
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            points += max(x, y)
            s[i] = '#'
    return points
```

",,
"```python
def largest_lex_sequence(n: int) -> list[int]:
    res = [0] * n
    for i in range(n):
        res[i] = i % 2
    return res
```

",,
"```python
def count_trees(pairs):
    nodes = len(pairs) + 1
    in_degrees = [0] * nodes
    for x, y in pairs:
        in_degrees[y] += 1
    
    res = 1
    for in_degree in in_degrees[1:]:
        res *= in_degree
    
    return res
```

",,
"```python
def signFunc(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0

def arraySign(nums):
    product = 1
    for num in nums:
        product *= signFunc(num)
    return product
```

",,
"```python
def halves_are_alike(s: str) -> bool:
    half_length = len(s) // 2
    count_a, count_b = 0, 0

    for i in range(half_length):
        if s[i] in ""aeiouAEIOU"": count_a += 1

    for i in range(half_length, len(s)):
        if s[i] in ""aeiouAEIOU"": count_b += 1

    return count_a == count_b
```

",,
"```python
import heapq

def eatenApples(apples, days):
    n = len(apples)
    pq = []
    ans = 0

    for i in range(n + 1):
        if i < n and apples[i] > 0:
            heapq.heappush(pq, (i + days[i], apples[i]))

        while pq and pq[0][0] <= i:
            heapq.heappop(pq)

        if pq:
            ans += 1
            curr_apple = heapq.heappop(pq)
            if curr_apple[1] > 1:
                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))

    return ans
```


",,
"```python
def minimum_working_time(jobs, k):
    max_job = max(jobs)
    sum_jobs = sum(jobs)
    
    left, right = max_job, sum_jobs
    while left < right:
        mid = left + (right - left) // 2
        count, current_sum = 1, 0

        for job in jobs:
            if current_sum + job > mid:
                count += 1
                current_sum = 0
            current_sum += job

        if count <= k:
            right = mid
        else:
            left = mid + 1

    return left
```


",,
"```python
def maximizeXor(nums, queries):
    trie = {}
    nums.sort()

    new_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda x: x[1])

    ans = [0] * len(queries)

    idx = 0
    for x, m, i in new_queries:
        while idx < len(nums) and nums[idx] <= m:
            t = nums[idx]
            idx += 1
            cur = trie
            for j in range(31, -1, -1):
                bit = (t >> j) & 1
                cur = cur.setdefault(bit, {})
        cur = trie
        xor_value = 0
        for j in range(31, -1, -1):
            bit = (x >> j) & 1
            if 1 ^ bit in cur:
                cur = cur[1 ^ bit]
                xor_value |= 1 << j
            else:
                cur = cur[bit]
        ans[i] = xor_value if cur else -1

    return ans
```


",,
"```python
def min_operations(nums):
    operations = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            operations += (nums[i - 1] - nums[i]) + 1
            nums[i] = nums[i - 1] + 1
    return operations
```

",,
"```python
def countPoints(points, queries):
    answer = []
    for query in queries:
        inside = 0
        for point in points:
            dx = point[0] - query[0]
            dy = point[1] - query[1]
            if dx * dx + dy * dy <= query[2] * query[2]:
                inside += 1
        answer.append(inside)
    return answer
```


",,
"```python
def maximumUnits(boxTypes, truckSize):
    boxTypes.sort(key=lambda x: x[1], reverse=True)
    
    totalUnits = 0
    for box in boxTypes:
        boxCount = min(truckSize, box[0])
        totalUnits += boxCount * box[1]
        truckSize -= boxCount
        if truckSize == 0:
            break
    
    return totalUnits
```

",,
"```python
from collections import defaultdict

def countPairs(deliciousness):
    MOD = 10**9 + 7
    hashMap = defaultdict(int)
    maxVal = max(deliciousness)
    maxSum = maxVal * 2

    count = 0
    for val in deliciousness:
        for sum in (1 << i for i in range(22)):
            count = (count + hashMap[sum - val]) % MOD
        hashMap[val] += 1

    return count
```

",,
"```python
from bisect import bisect_left

def min_operations(target, arr):
    index_map = {num: i for i, num in enumerate(target)}

    lis = []
    for num in arr:
        if num in index_map:
            pos = bisect_left(lis, index_map[num])
            if pos == len(lis):
                lis.append(index_map[num])
            else:
                lis[pos] = index_map[num]

    return len(target) - len(lis)
```

",,
"```python
def largestAltitude(gain):
    max_altitude, current_altitude = 0, 0
    for i in gain:
        current_altitude += i
        max_altitude = max(max_altitude, current_altitude)
    return max_altitude
```

",,
"```python
def minimum_teachings(n, languages, friendships):
    language_users = {}
    unconnected_users = set()

    for u, v in friendships:
        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])
        if not can_communicate:
            unconnected_users.add(u)
            unconnected_users.add(v)

    res = len(unconnected_users)
    for i in range(1, n+1):
        cnt = sum(i not in languages[user-1] for user in unconnected_users)
        res = min(res, cnt)

    return res
```

",,
"```python
def decode(encoded):
    n = len(encoded) + 1
    total_xor = 0
    for i in range(1, n + 1):
        total_xor ^= i
    encoded_xor = 0
    for i in range(1, n - 1, 2):
        encoded_xor ^= encoded[i]
    perm = [total_xor ^ encoded_xor]
    for i in range(1, n):
        perm.append(perm[-1] ^ encoded[i - 1])
    return perm
```

",,
"```python
from collections import defaultdict
from typing import List

MOD = 10**9 + 7

def product_ways(queries: List[List[int]]) -> List[int]:
    res = []
    for n, k in queries:
        pf = []
        pm = defaultdict(int)

        i = 2
        while i * i <= k:
            cnt = 0
            while k % i == 0:
                cnt += 1
                k //= i
            if cnt:
                pf.append(cnt)
                pm[cnt] += 1
            i += 1

        if k > 1:
            pm[k] += 1
            pf.append(1)

        ans = 1
        for p in pf:
            ans = (ans * (p * (n - 1) + 1)) % MOD

        res.append(ans)
    return res
```

",,
"```python
def sum_base(n: int, k: int) -> int:
    s = 0
    while n:
        s += n % k
        n //= k
    return s
```


",,
"```python
def maxFrequency(nums: List[int], k: int) -> int:
    nums.sort()
    n, i, s, max_freq = len(nums), 0, 0, 0

    for j in range(n):
        s += nums[j]
        while s + k < nums[j] * (j - i + 1):
            s -= nums[i]
            i += 1
        max_freq = max(max_freq, j - i + 1)

    return max_freq
```

",,
"```python
def decode(encoded, first):
    arr = [first]
    for num in encoded:
        arr.append(arr[-1] ^ num)
    return arr
```


",,
"```python
from collections import defaultdict

def dfs(node, visited, graph, group):
    if visited[node]:
        return
    visited[node] = 1
    group.append(node)
    for neighbor in graph[node]:
        dfs(neighbor, visited, graph, group)

def minimumHammingDistance(source, target, allowedSwaps):
    n = len(source)
    graph = defaultdict(list)
    for a, b in allowedSwaps:
        graph[a].append(b)
        graph[b].append(a)

    res = 0
    visited = [0] * n
    for i in range(n):
        if not visited[i]:
            group = []
            dfs(i, visited, graph, group)
            count = defaultdict(int)

            for node in group:
                count[source[node]] += 1
            for node in group:
                if count[target[node]] > 0:
                    res += 1
                    count[target[node]] -= 1

    return n - res
```


",,
"```python
from itertools import permutations

def nextPalindrome(num: str) -> str:
    n = len(num)
    first_half = num[:(n + 1) // 2]
    candidates = sorted(set(int("""".join(p)) for p in permutations(first_half)))

    for c in candidates:
        c_str = str(c)
        second_half = c_str[::-1]
        if n % 2 == 1: second_half = second_half[1:]
        candidate_str = c_str + second_half

        if candidate_str > num:
            return candidate_str

    return """"
```

",,
"```python
def count_balls(low_limit: int, high_limit: int) -> int:
    box_counts = [0] * 46
    for i in range(low_limit, high_limit + 1):
        box_number = sum(map(int, str(i)))
        box_counts[box_number] += 1
    return max(box_counts)
```

",,
"```python
def largestSubmatrix(matrix):
    m, n = len(matrix), len(matrix[0])
    height = [0] * n
    max_area = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                height[j] += 1
            else:
                height[j] = 0
        sorted_height = sorted(height)
        for j in range(n):
            max_area = max(max_area, sorted_height[j] * (n - j))

    return max_area
```


",,
"```python
def maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:
    arr.sort()
    arr[0] = 1
    for i in range(1, len(arr)):
        arr[i] = min(arr[i], arr[i - 1] + 1)
    return arr[-1]
```

",,
"
```javascript
function closestRoom(rooms, queries) {
    rooms.sort((a, b) => b[1] - a[1]);
    
    for (let i = 0; i < queries.length; ++i) {
        queries[i].push(i);
    }
    
    queries.sort((a, b) => b[1] - a[1]);
    
    let result = new Array(queries.length);
    let ids = new Set();
    
    let j = 0;
    for (const q of queries) {
        while (j < rooms.length && rooms[j][1] >= q[1]) {
            ids.add(rooms[j++][0]);
        }
        if (ids.size === 0) {
            result[q[2]] = -1;
        } else {
            let minAbsDiff = Infinity;
            let minId = undefined;
            for (let id = q[0]; id <= 10000000; ++id) {
                if (ids.has(id) && Math.abs(id-q[0]) < minAbsDiff) {
                    minAbsDiff = Math.abs(id - q[0]);
                    minId = id;
                }
                if (ids.has(id-1) && Math.abs(id-1-q[0]) < minAbsDiff) {
                    minAbsDiff = Math.abs(id - 1 - q[0]);
                    minId = id - 1;
                }
                if (minId !== undefined)
                    break;
            }
            result[q[2]] = minId;
        }
    }
    
    return result;
}
```


",,
"```python
def sum_of_unique_elements(nums):
    elem_count = {}
    for num in nums:
        elem_count[num] = elem_count.get(num, 0) + 1
    sum = 0
    for elem, count in elem_count.items():
        if count == 1:
            sum += elem
    return sum
```


",,
"```python
def maxAbsoluteSum(nums):
    max_sum, min_sum, max_so_far, min_so_far = 0, 0, 0, 0
    for num in nums:
        max_so_far = max(num, max_so_far + num)
        max_sum = max(max_sum, max_so_far)

        min_so_far = min(num, min_so_far + num)
        min_sum = min(min_sum, min_so_far)
    return max(max_sum, abs(min_sum))
```

",,
"```python
def min_length_after_operations(s: str) -> int:
    a_count = s.count('a')
    b_count = s.count('b')
    c_count = s.count('c')

    if a_count % 2 == b_count % 2 and b_count % 2 == c_count % 2:
        return len(s) % 2
    return (len(s) + 1) % 2
```

",,
"```python
from bisect import bisect_left

def maxValue(events, k):
    events.sort(key=lambda x: x[1])
    n = len(events)
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        start = -1
        for j in range(i - 1, 0, -1):
            if events[j - 1][1] < events[i - 1][0]:
                start = j
                break

        for j in range(1, k + 1):
            if start == -1:
                dp[i][j] = max(dp[i - 1][j], events[i - 1][2])
            else:
                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2])

    return dp[n][k]
```


",,
"```python
def distinct_numbers_in_subarrays(nums, k):
    counts = {}
    ans = []
    for i, num in enumerate(nums):
        counts[num] = counts.get(num, 0) + 1
        if i >= k:
            counts[nums[i - k]] -= 1
            if counts[nums[i - k]] == 0:
                del counts[nums[i - k]]
        if i >= k - 1:
            ans.append(len(counts))
    return ans
```

",,
"```python
def maxAliveYear(logs):
    years = [0] * 101
    for log in logs:
        years[log[0] - 1950] += 1
        years[log[1] - 1950] -= 1
    max_population = years[0]
    max_year = 1950
    for i in range(1, 101):
        years[i] += years[i - 1]
        if years[i] > max_population:
            max_population = years[i]
            max_year = i + 1950
    return max_year
```

",,
"```python
def maxDistance(nums1, nums2):
    i, j, maxDist = 0, 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] > nums2[j]:
            i += 1
        else:
            maxDist = max(maxDist, j - i)
            j += 1
    return maxDist
```

",,
"```python
def maxSumMinProduct(nums: list[int]) -> int:
    MOD = int(1e9 + 7)
    max_product = 0
    stk = []
    prefix_sum = [0] * (len(nums) + 1)

    for i in range(len(nums)):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    for i in range(len(nums)):
        while stk and nums[stk[-1]] > nums[i]:
            min_val = nums[stk.pop()]
            max_product = max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk[-1] + 1 if stk else 0]))
        stk.append(i)
       
    while stk:
        min_val = nums[stk.pop()]
        max_product = max(max_product, min_val * (prefix_sum[len(nums)] - prefix_sum[stk[-1] + 1 if stk else 0]))

    return max_product % MOD
```


",,
"```python
from collections import deque

def largestPathValue(colors: str, edges: List[List[int]]) -> int:
    n = len(colors)
    adj = [[] for _ in range(n)]
    
    in_degrees = [0] * n
    for e in edges:
        adj[e[0]].append(e[1])
        in_degrees[e[1]] += 1
        
    color_counts = [[0] * 26 for _ in range(n)]
    queue = deque()
    
    for i in range(n):
        if in_degrees[i] == 0:
            queue.append(i)
            
    visited_nodes = 0
    max_color_value = 0
    
    while queue:
        node = queue.pop()
        color = ord(colors[node]) - ord('a')
        visited_nodes += 1
        
        for neighbor in adj[node]:
            for c in range(26):
                count = color_counts[node][c] + (c == color)
                color_counts[neighbor][c] = max(color_counts[neighbor][c], count)
                max_color_value = max(max_color_value, count)
                
            in_degrees[neighbor] -= 1
            if in_degrees[neighbor] == 0:
                queue.append(neighbor)
                
    return max_color_value if visited_nodes == n else -1
```


",,
"```python
def maximum_time(time: str) -> str:
    time = list(time)
    if time[0] == ""?"":
        time[0] = ""2"" if time[1] == ""?"" or int(time[1]) < 4 else ""1""
    if time[1] == ""?"":
        time[1] = ""3"" if time[0] == ""2"" else ""9""
    if time[3] == ""?"":
        time[3] = ""5""
    if time[4] == ""?"":
        time[4] = ""9""
    return """".join(time)
```

",,
"```python
def min_operations_to_satisfy_conditions(a: str, b: str) -> int:
    same, less, greater = 0, 0, 0

    for i in range(len(a)):
        if a[i] == b[i]:
            same += 1
        elif a[i] < b[i]:
            less += 1
        else:
            greater += 1

    return min(same + max(less, greater), less, greater)
```

",,
"```python
import heapq

def kthLargestValue(matrix, k):
    m, n = len(matrix), len(matrix[0])
    prefix_xor = [[0] * (n + 1) for _ in range(m + 1)]
    pq = []

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1] ^ prefix_xor[i - 1][j - 1]
            heapq.heappush(pq, prefix_xor[i][j])
            if len(pq) > k:
                heapq.heappop(pq)
    return pq[0]
```


",,
"```python
def min_boxes_touching_floor(n):
    return (n + 1) // 2
```

",,
"```python
def sum_of_floored_pairs(nums):
    MOD = 10**9 + 7
    n = len(nums)
    max_element = max(nums)
    cnt = [0] * (max_element + 1)
    for num in nums:
        cnt[num] += 1
    for i in range(1, max_element + 1):
        cnt[i] += cnt[i - 1]

    res = 0
    for num in nums:
        j, k = 1, 1
        while k <= max_element:
            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])
            res %= MOD
            j += 1
            k += num

    return res
```

",,
"```python
def subsetXORSum(nums):
    ans = 0
    n = len(nums)
    max_val = 1 << n
    for i in range(1, max_val):
        xor_total = 0
        for j in range(n):
            if i & (1 << j):
                xor_total ^= nums[j]
        ans += xor_total
    return ans
```

",,
"```python
def minSwaps(s):
    zeroCount = s.count('0')
    oneCount = len(s) - zeroCount

    if abs(zeroCount - oneCount) > 1:
        return -1

    swaps1 = swaps2 = 0
    for i, c in enumerate(s):
        if i % 2 == 0 and c != '0':
            swaps1 += 1
        if i % 2 == 1 and c != '1':
            swaps1 += 1
    swaps1 = swaps1 // 2

    for i, c in enumerate(s):
        if i % 2 == 0 and c != '1':
            swaps2 += 1
        if i % 2 == 1 and c != '0':
            swaps2 += 1
    swaps2 = swaps2 // 2

    if zeroCount == oneCount:
        return min(swaps1, swaps2)
    return swaps2 if zeroCount > oneCount else swaps1
```

",,
"```python
from collections import defaultdict

class FindSumPairs:
    def __init__(self, nums1: list[int], nums2: list[int]):
        self.nums1 = nums1
        self.nums2 = nums2
        self.nums2_map = defaultdict(int)
        for num in nums2:
            self.nums2_map[num] += 1

    def add(self, index: int, val: int) -> None:
        self.nums2_map[self.nums2[index]] -= 1
        self.nums2[index] += val
        self.nums2_map[self.nums2[index]] += 1

    def count(self, tot: int) -> int:
        return sum(self.nums2_map.get(tot - num, 0) for num in self.nums1)
```


",,
"```python
from collections import defaultdict

def restoreArray(adjacentPairs):
    graph = defaultdict(list)
    for pair in adjacentPairs:
        graph[pair[0]].append(pair[1])
        graph[pair[1]].append(pair[0])

    n = len(graph)
    nums = [0] * n
    for key, nodes in graph.items():
        if len(nodes) == 1:
            nums[0] = key
            break

    nums[1] = graph[nums[0]][0]
    for i in range(2, n):
        nums[i] = (graph[nums[i - 1]][1]
                   if (nums[i - 2] == graph[nums[i - 1]][0])
                   else graph[nums[i - 1]][0])

    return nums
```

",,
"```python
def findRLEProduct(encoded1, encoded2):
    result = []
    i, j, count1, count2 = 0, 0, 0, 0

    while i < len(encoded1) and j < len(encoded2):
        product = encoded1[i][0] * encoded2[j][0]
        count = min(encoded1[i][1] - count1, encoded2[j][1] - count2)
        count1 += count
        count2 += count

        if result and result[-1][0] == product:
            result[-1][1] += count
        else:
            result.append([product, count])

        if count1 == encoded1[i][1]:
            i += 1
            count1 = 0

        if count2 == encoded2[j][1]:
            j += 1
            count2 = 0

    return result
```

",,
"```python
def checkZeroOnes(s: str) -> bool:
    max_ones, max_zeros, current_ones, current_zeros = 0, 0, 0, 0
    for c in s:
        if c == '1':
            current_ones += 1
            current_zeros = 0
        else:
            current_zeros += 1
            current_ones = 0
        max_ones = max(max_ones, current_ones)
        max_zeros = max(max_zeros, current_zeros)
    return max_ones > max_zeros
```

",,
"```python
from math import ceil

def minSpeedOnTime(dist, hour):
    max_time = hour - len(dist) + 1
    lower, upper = 1.0, 1e7
    while upper - lower >= 1e-9:
        mid = (lower + upper) / 2
        time_taken = sum(ceil(d / mid) - (0 if i == len(dist) - 1 else 1) for i, d in enumerate(dist))
        if time_taken <= max_time:
            upper = mid
        else:
            lower = mid
    return ceil(lower) if lower <= 1e7 else -1
```

",,
"```python
def is_palindrome(s, l, r):
    while l < r:
        if s[l] != s[r]:
            return False
        l += 1
        r -= 1
    return True

def check_partitioning(s):
    n = len(s)
    for i in range(n - 2):
        if is_palindrome(s, 0, i):
            for j in range(i + 1, n - 1):
                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):
                    return True
    return False
```


",,
"```python
def can_eat(candiesCount, queries):
    prefix_sum = [0] * (len(candiesCount) + 1)
    for i in range(len(candiesCount)):
        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]

    result = [False] * len(queries)
    for i in range(len(queries)):
        favoriteType, favoriteDay, dailyCap = queries[i]
        x1 = favoriteDay + 1
        y1 = (favoriteDay + 1) * dailyCap

        x2 = prefix_sum[favoriteType] + 1
        y2 = prefix_sum[favoriteType + 1]

        result[i] = not (x1 > y2 or y1 < x2)

    return result
```

",,
"```python
def can_choose(groups, nums):
    g_i, n_i = 0, 0
    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):
        if nums[n_i : n_i + len(groups[g_i])] == groups[g_i]:
            n_i += len(groups[g_i])
            g_i += 1
        else:
            n_i += 1
    return g_i == len(groups)
```

",,
"```python
from collections import deque

def highest_island(is_water):
    m, n = len(is_water), len(is_water[0])
    height = [[-1] * n for _ in range(m)]
    q = deque()

    for i in range(m):
        for j in range(n):
            if is_water[i][j] == 1:
                height[i][j] = 0
                q.append((i, j))

    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]

    while q:
        x, y = q.popleft()

        for i in range(4):
            newX = x + dx[i]
            newY = y + dy[i]

            if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1:
                height[newX][newY] = height[x][y] + 1
                q.append((newX, newY))

    return height
```

",,
"```python
def minPairSum(nums):
    nums.sort()
    max_sum = 0
    for i in range(len(nums) // 2):
        max_sum = max(max_sum, nums[i] + nums[-1 - i])
    return max_sum
```

",,
"```python
def check(nums):
    count = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            count += 1
        if count > 1:
            return False
    return count == 1 or nums[0] >= nums[-1]
```

",,
"```python
def max_score(a: int, b: int, c: int) -> int:
    return (a + b + c - max(a, b, c)) // 2
```


",,
"```python
def largest_merge(word1: str, word2: str) -> str:
    merge = []
    while word1 or word2:
        if word1 > word2:
            merge.append(word1[0])
            word1 = word1[1:]
        else:
            merge.append(word2[0])
            word2 = word2[1:]
    return ''.join(merge)
```

",,
"```python
from itertools import combinations

def minAbsDifference(nums, goal):
    n = len(nums)
    left = nums[:n//2]
    right = nums[n//2:]

    sums_left = set()

    for i in range(len(left) + 1):
        for comb in combinations(left, i):
            sums_left.add(sum(comb))

    ans = abs(goal)

    for i in range(len(right) + 1):
        for comb in combinations(right, i):
            sum_r = sum(comb)
            sum_goal = goal - sum_r
            sum_l = min(sums_left, key=lambda x: abs(x - sum_goal))

            ans = min(ans, abs(sum_l + sum_r - goal))

    return ans
```

",,
"```python
import heapq
from typing import List

def assignTasks(servers: List[int], tasks: List[int]) -> List[int]:
    free_servers = [(servers[i], i) for i in range(len(servers))]
    heapq.heapify(free_servers)
    busy_servers = []
    result = [0] * len(tasks)

    for time in range(len(tasks)):
        while busy_servers and busy_servers[0][0] <= time:
            _, server_elem = heapq.heappop(busy_servers)
            heapq.heappush(free_servers, server_elem)
        
        if free_servers:
            server_elem = heapq.heappop(free_servers)
            result[time] = server_elem[1]
            heapq.heappush(busy_servers, (time + tasks[time], server_elem))

    return result
```


",,
"```python
def minSkips(dist, speed, hoursBefore):
    n = len(dist)
    dp = [[1e9] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(n):
        for j in range(i+1):
            t = dist[i] / speed + (1 if j else 0)
            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)
            skipped_t = -(-dist[i] / speed) - dp[i][j]
            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)

    for i in range(n + 1):
        if dp[n][i] <= hoursBefore:
            return i
    return -1
```

",,
"```python
def min_operations_to_alternate(s: str) -> int:
    count_a, count_b = 0, 0
    for i, c in enumerate(s):
        if i % 2 == 0:
            if c == '0':
                count_a += 1
            else:
                count_b += 1
        else:
            if c == '0':
                count_b += 1
            else:
                count_a += 1
    return min(count_a, count_b)
```

",,
"```python
def count_homogenous(s: str) -> int:
    res, count, mod = 0, 1, 10**9 + 7
    for i in range(1, len(s)):
        count = count + 1 if s[i] == s[i - 1] else 1
        res = (res + count) % mod
    return res
```

",,
"```python
import heapq

def minimumSize(nums, maxOperations):
    pq = [-num for num in nums] # Negative numbers to simulate max heap
    heapq.heapify(pq)
    while maxOperations > 0:
        maxBalls = -heapq.heappop(pq)
        heapq.heappush(pq, -maxBalls // 2)
        heapq.heappush(pq, -(maxBalls - (maxBalls // 2)))
        maxOperations -= 1
    return -pq[0]
```

",,
"```python
from collections import defaultdict

def min_trio_degree(n, edges):
    graph = defaultdict(dict)
    degree = [0] * (n + 1)

    for u, v in edges:
        graph[u][v] = graph[v][u] = True
        degree[u] += 1
        degree[v] += 1

    min_degree = float('inf')
    for u, v in edges:
        for w in range(1, n + 1):
            if graph[u].get(w) and graph[v].get(w):
                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)

    return min_degree if min_degree != float('inf') else -1
```


",,
"```python
def nearestValidPoint(x, y, points):
    min_distance = float('inf')
    min_index = -1

    for i, point in enumerate(points):
        if x == point[0] or y == point[1]:
            distance = abs(x - point[0]) + abs(y - point[1])
            if distance < min_distance:
                min_distance = distance
                min_index = i

    return min_index
```

",,
"```python
def check_powers_of_three(n: int) -> bool:
    while n > 0:
        if n % 3 == 2:
            return False
        n //= 3
    return True
```

",,
"```python
def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:
    for i in range(left, right + 1):
        found = False
        for _range in ranges:
            if _range[0] <= i <= _range[1]:
                found = True
                break
        if not found:
            return False
    return True
```

",,
"```python
def merge_alternately(word1, word2):
    merged = []
    i, j = 0, 0
    while i < len(word1) or j < len(word2):
        if i < len(word1):
            merged.append(word1[i])
            i += 1
        if j < len(word2):
            merged.append(word2[j])
            j += 1
    return """".join(merged)
```

",,
"```python
def min_operations(boxes: str):
    result = [0] * len(boxes)
    count, total = 0, 0

    for i in range(len(boxes)):
        total += count
        result[i] = total
        if boxes[i] == '1':
            count += 1

    count, total = 0, 0
    for i in range(len(boxes) - 1, -1, -1):
        total += count
        result[i] += total
        if boxes[i] == '1':
            count += 1

    return result
```

",,
"```python
def maximumScore(nums, multipliers):
    n, m = len(nums), len(multipliers)
    dp = [[0] * (m + 1) for _ in range(m + 1)]
    maxScore = float('-inf')

    for i in range(m + 1):
        for j in range(m - i + 1):
            if i == 0 and j == 0:
                continue
            score = 0
            if i == 0:
                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]
            elif j == 0:
                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]
            else:
                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],
                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])
            dp[i][j] = score
            if i + j == m:
                maxScore = max(maxScore, score)

    return maxScore
```

",,
"```python
def longestPalindromeSubseq(word1, word2):
    n, m = len(word1), len(word2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(n):
        for j in range(m):
            if word1[i] == word2[j]:
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    return dp[n][m]
```

",,
"```python
def maximumRemovals(s: str, p: str, removable: List[int]) -> int:
    low, high = 0, len(removable)
    while low < high:
        mid = (low + high + 1) // 2
        temp_s = list(s)
        for i in range(mid):
            temp_s[removable[i]] = '-'
        i, j = 0, 0
        while i < len(temp_s) and j < len(p):
            if temp_s[i] == p[j]:
                j += 1
            i += 1
        if j == len(p):
            low = mid
        else:
            high = mid - 1
    return low
```


",,
"```python
def count_matches(items, rule_key, rule_value):
    rule = {""type"": 0, ""color"": 1, ""name"": 2}
    count = 0

    for item in items:
        if item[rule[rule_key]] == rule_value:
            count += 1

    return count
```

",,
"```python
def closest_cost(base_costs, topping_costs, target):
    closest = base_costs[0]
    
    for base in base_costs:
        cost = base
        
        for i in range(1 << (len(topping_costs) * 2)):
            bit_mask = i
            
            for j, topping_cost in enumerate(topping_costs):
                cost += (bit_mask & 3) * topping_cost
                bit_mask >>= 2
                
            if abs(target - cost) < abs(target - closest):
                closest = cost
            elif abs(target - cost) == abs(target - closest) and cost < closest:
                closest = cost
                
            cost = base
            
    return closest
```


",,
"```python
def min_operations(nums1, nums2):
    sum1, sum2 = sum(nums1), sum(nums2)
    if sum1 == sum2: return 0
    if sum1 < sum2: nums1, nums2 = nums2, nums1
    nums1.sort(reverse=True)
    nums2.sort()
    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0
    while diff > 0 and (i < len(nums1) or j < len(nums2)):
        option1 = nums1[i] - 1 if i < len(nums1) else 0
        option2 = 6 - nums2[j] if j < len(nums2) else 0
        if option1 > option2:
            diff -= option1
            i += 1
        else:
            diff -= option2
            j += 1
        operations += 1
    return operations if diff == 0 else -1
```


",,
"```python
def get_collision_times(cars):
    n = len(cars)
    collisions = [-1] * n
    for i in range(n-1, -1, -1):
        time_to_collision = 1e9
        for j in range(i+1, n):
            if cars[j][1] > cars[i][1]:
                continue
            current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])
            if current_collision < time_to_collision:
                time_to_collision = min(time_to_collision, min(collisions[j], current_collision))
        collisions[i] = -1.0 if time_to_collision == 1e9 else time_to_collision
    return collisions
```

",,
"```python
def largest_odd_number(num: str) -> str:
    for i in range(len(num) - 1, -1, -1):
        if int(num[i]) % 2 != 0:
            return num[:i + 1]
    return """"
```

",,
"```python
def second_largest_digit(s: str) -> int:
    largest = -1
    second_largest = -1
    for c in s:
        if c.isdigit():
            digit = int(c)
            if digit > largest:
                second_largest = largest
                largest = digit
            elif digit != largest and digit > second_largest:
                second_largest = digit
    return second_largest
```

",,
"class AuthenticationManager {
    constructor(timeToLive) {
        this.timeToLive = timeToLive;
        this.tokens = new Map();
    }

    generate(tokenId, currentTime) {
        this.tokens.set(tokenId, currentTime + this.timeToLive);
    }

    renew(tokenId, currentTime) {
        if (this.tokens.has(tokenId) && this.tokens.get(tokenId) > currentTime) {
            this.tokens.set(tokenId, currentTime + this.timeToLive);
        }
    }

    countUnexpiredTokens(currentTime) {
        let count = 0;
        for (const expirationTime of this.tokens.values()) {
            if (expirationTime > currentTime) count++;
        }
        return count;
    }
}
```


",,
"```python
from functools import lru_cache
from math import gcd

def maxScore(nums):
    n = len(nums)

    @lru_cache(None)
    def dfs(i, j):
        if i > n:
            return 0
        ans = 0
        for k in range(j + 1, n * 2):
            ans = max(ans, dfs(i + 1, k) + i * gcd(nums[j], nums[k]))
        return ans

    return dfs(1, 0)
```

",,
"```python
def alice_wins(piles):
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    return xor_sum != 0
```


",,
"```python
def canBeIncreasing(nums):
    count = 0
    for i in range(1, len(nums)):
        if nums[i - 1] >= nums[i]:
            count += 1
            if count > 1: return False
            if i > 1 and nums[i - 2] >= nums[i] and i < len(nums) - 1 and nums[i - 1] >= nums[i + 1]: return False
    return True
```

",,
"```python
def check_ones_segment(s: str) -> bool:
    count = 0
    for i in range(len(s)):
        if s[i] == '1':
            if i > 0 and s[i - 1] == '0':
                count += 1
    return count <= 1
```

",,
"```python
def min_elements(nums, limit, goal):
    total_sum = sum(nums)
    diff = abs(goal - total_sum)
    return (diff + limit - 1) // limit
```


",,
"```python
from heapq import heappush, heappop
from collections import defaultdict
from functools import lru_cache

mod = 10**9 + 7

def countRestrictedPaths(n, edges):
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))

    dist = [float('inf')] * (n + 1)
    dist[n] = 0
    pq = [(0, n)] # (distance, node)
    
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heappush(pq, (dist[v], v))

    @lru_cache(None)
    def dfs(u):
        if u == n:
            return 1
        ans = 0
        for v, _ in graph[u]:
            if dist[v] < dist[u]:
                ans = (ans + dfs(v)) % mod
        return ans

    return dfs(1)
```

",,
"```python
def min_changes(nums, k):
    n = len(nums)
    xor_prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1]

    dp = [{} for _ in range(k)]
    min_dp = [n] * k

    for i in range(1, n + 1):
        x = xor_prefix[i] ^ xor_prefix[i - k]

        if i >= k:
            dp[0][x] = dp[0].get(x, 0) + 1

        for j in range(1, 1 + (i - j * k) // k):
            if x in dp[j - 1]:
                dp[j][x] = dp[j].get(x, 0) + 1
                min_dp[j] = min(min_dp[j], dp[j - 1][x] - dp[j][x])

    return min(n, [min_dp[j] + j for j in range(k)])
```

",,
"```python
def rotateGrid(grid, k):
    if not grid: return grid
    
    m, n = len(grid), len(grid[0])
    numLayers = min(m, n) // 2

    for layer in range(numLayers):
        numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2
        effective_k = k % numToRotate

        while effective_k:
            temp = grid[layer][layer]
            for i in range(layer + 1, m - layer): temp, grid[i][layer] = grid[i][layer], temp
            for j in range(layer + 1, n - layer): temp, grid[m - layer - 1][j] = grid[m - layer - 1][j], temp
            for i in range(m - layer - 2, layer - 1, -1): temp, grid[i][n - layer - 1] = grid[i][n - layer - 1], temp
            for j in range(n - layer - 2, layer, -1): temp, grid[layer][j] = grid[layer][j], temp
            effective_k -= 1

    return grid
```

",,
"```python
def are_almost_equal(s1, s2):
    diff_count = 0
    first_diff = -1
    second_diff = -1
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            diff_count += 1
            if diff_count == 1:
                first_diff = i
            elif diff_count == 2:
                second_diff = i
            else:
                return False
    return diff_count == 0 or (diff_count == 2 and s1[first_diff] == s2[second_diff] and s1[second_diff] == s2[first_diff])
```


",,
"```python
def findCenter(edges):
    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:
        return edges[0][0]
    return edges[0][1]
```

",,
"```python
def maxScore(nums: List[int], k: int) -> int:
    n = len(nums)
    result = 0
    for i in range(k, -1, -1):
        for j in range(k, n):
            min_val = min(nums[i:j+1])
            result = max(result, min_val * (j - i + 1))
    return result
```

",,
"```python
def square_is_white(coordinates: str) -> bool:
    return (ord(coordinates[0]) - ord('a') + ord(coordinates[1]) - ord('1')) % 2 == 0
```

",,
"```python
def eliminate_maximum(dist, speed):
    n = len(dist)
    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]
    time_to_reach_city.sort()
    eliminated = 0
    for i in range(n):
        if time_to_reach_city[i] > i:
            eliminated += 1
        else:
            break
    return eliminated
```

",,
"```python
def goodDigitStrings(n: int) -> int:
    MOD = 1000000007
    even_count, prime_count = 1, 1
    for i in range(n):
        if i % 2 == 0:
            even_count = (even_count * 5) % MOD
        else:
            prime_count = (prime_count * 4) % MOD
    return (even_count * prime_count) % MOD
```

",,
"```python
def are_sentences_similar(sentence1, sentence2):
    words1 = sentence1.split()
    words2 = sentence2.split()

    while words1 and words2 and words1[0] == words2[0]:
        words1.pop(0)
        words2.pop(0)
    
    while words1 and words2 and words1[-1] == words2[-1]:
        words1.pop()
        words2.pop()

    return not words1 or not words2
```

",,
"```python
def max_happy_groups(batchSize, groups):
    remainders = [0] * batchSize
    for g in groups:
        remainders[g % batchSize] += 1

    result = remainders[0]
    i, j = 1, batchSize - 1

    while i < j:
        result += min(remainders[i], remainders[j])
        i += 1
        j -= 1

    if i == j:
        result += remainders[i] // 2

    return result
```

",,
"```python
def reverse(x):
    rev = 0

    while x != 0:
        rev = rev * 10 + x % 10
        x = x // 10

    return rev

def count_nice_pairs(nums):
    MOD = 1_000_000_007
    count = {}
    result = 0

    for num in nums:
        diff = num - reverse(num)
        count[diff] = count.get(diff, 0) + 1

    for val in count.values():
        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD

    return result
```

",,
"```python
from collections import deque

def nearest_exit(maze, entrance):
    m, n = len(maze), len(maze[0])
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    q = deque([tuple(entrance)])
    
    steps = -1
    while q:
        steps += 1
        for _ in range(len(q)):
            r, c = q.popleft()
            if maze[r][c] == '+': continue
            if r == 0 or r == m-1 or c == 0 or c == n-1:
                if r != entrance[0] or c != entrance[1]: return steps
            maze[r][c] = '+'
            for dr, dc in moves:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    q.append((nr, nc))
    return -1
```

",,
"```python
def max_ascending_sum(nums):
    max_sum = current_sum = nums[0]

    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            current_sum += nums[i]
        else:
            max_sum = max(max_sum, current_sum)
            current_sum = nums[i]

    return max(max_sum, current_sum)
```

",,
"```python
from heapq import heappush, heappop

def getNumberOfBacklogOrders(orders):
    buy, sell = [], []

    for price, amount, orderType in orders:
        if orderType == 0:
            while amount > 0 and sell and -sell[0][0] <= price:
                executedAmount = min(amount, sell[0][1])
                amount -= executedAmount
                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]
                if sell[0][1] == 0:
                    heappop(sell)
            if amount:
                heappush(buy, [-price, amount])
        else:
            while amount > 0 and buy and buy[0][0] >= price:
                executedAmount = min(amount, buy[0][1])
                amount -= executedAmount
                buy[0] = [buy[0][0], buy[0][1] - executedAmount]
                if buy[0][1] == 0:
                    heappop(buy)
            if amount:
                heappush(sell, [-price, amount])

    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)
    return res % 1000000007
```


",,
"```python
def maxValue(n, index, maxSum):
    maxSum -= n
    left, right, ans = 0, maxSum, 0
    while left <= right:
        mid = left + (right - left) // 2
        sum = min(mid, index) * (min(mid, index) + 1) // 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1) // 2
        if mid > index:
            sum += (mid - index - 1) * (mid - index) // 2
        if mid > n - index:
            sum += (mid - n + index) * (mid - n + index + 1) // 2
        if sum <= maxSum:
            ans = mid
            left = mid + 1
        else:
            right = mid - 1
    return ans + 1
```

",,
"```python
def max_consecutive_values(coins):
    coins.sort()
    max_value = 0    
    for coin in coins:
        if coin <= max_value + 1:
            max_value += coin
        else:
            break
    return max_value + 1
```

",,
"```python
def numOfWays(m, n):
    mod = 1000000007
    a, b, c, d = 6, 6, 3, 3
    while n > 1:
        n -= 1
        temp_a = a
        temp_c = c
        a = (a * 3 + b * 2) % mod
        b = (temp_a * 2 + b * 2) % mod
        c = (c * 3 + d * 2) % mod
        d = (temp_c * 2 + d * 2) % mod
    return b if m == 1 else (a + c) % mod
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def canMerge(trees):
    leaf_count = {}
    root_map = {}
    
    for tree in trees:
        if tree.left:
            leaf_count[tree.left.val] = leaf_count.get(tree.left.val, 0) + 1
        if tree.right:
            leaf_count[tree.right.val] = leaf_count.get(tree.right.val, 0) + 1
        root_map[tree.val] = tree

    def is_valid_bst(node, min_val, max_val):
        if not node:
            return True
        if node.val <= min_val or node.val >= max_val:
            return False
        if node.left and node.left.val in root_map:
            left_child = root_map.pop(node.left.val)
            leaf_count[tree.left.val] -= 1
            tree.left = left_child
        if node.right and node.right.val in root_map:
            right_child = root_map.pop(node.right.val)
            leaf_count[tree.right.val] -= 1
            tree.right = right_child
        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)
            

    for tree in trees:
        if leaf_count.get(tree.val, 0) == 0:
            if is_valid_bst(tree, 0, 5e4 + 1):
                return tree
            break

    return None
```

",,
"```python
def num_different_integers(word):
    for c in word:
        if not c.isdigit():
            word = word.replace(c, ' ')
    nums = word.split()
    unique_nums = set()
    for num in nums:
        num = num.lstrip('0') or '0'
        unique_nums.add(num)
    return len(unique_nums)
```

",,
"```python
def min_operations(n):
    count = 1
    temp = 1

    while temp % n != 0:
        temp = (temp * 2) % n
        count += 1

    return count
```

",,
"```python
def numberOfNiceDivisors(primeFactors):
    MOD = 1000000007
    result = 1
    p = 2
    while p <= primeFactors:
        if primeFactors % p == 0:
            count = 0
            while primeFactors % p == 0:
                primeFactors //= p
                count += 1
            result = (result * (count * 2 + 1)) % MOD
        p += 1
    return result
```

",,
"```python
def maxPoints(points):
    m, n = len(points), len(points[0])
    dp = [0] * n
    for row in points:
        next_dp = [0] * n
        for c1 in range(n):
            score = dp[c1] + row[c1] - c1
            for c2 in range(n):
                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)
        dp = next_dp
    return max(dp)
```

",,
"```python
def min_operations(nums):
    operations = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            operations += nums[i - 1] - nums[i] + 1
            nums[i] = nums[i - 1] + 1
    return operations
```

",,
"```python
def make_string_sorted(s):
    mod = 1000000007
    n = len(s)
    fact = [1] * (n + 1)
    inv = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % mod
        inv[i] = inv[i - 1] * (mod - mod // i) % mod
        
    ans = 0
    for i in range(n):
        less_than = 0
        for j in range(i + 1, n):
            if s[j] < s[i]:
                less_than += 1
        ans = (ans + less_than * fact[n - i - 1]) % mod
    return ans
```

",,
"```python
from sortedcontainers import SortedDict
from sortedcontainers import SortedSet

def smallestChair(times, targetFriend):
    events = SortedDict()
    for i, (arrival, leaving) in enumerate(times):
        events[arrival] = i
        events[leaving] = ~i

    availableChairs = SortedSet(range(len(times)))
    assignedChair = [0] * len(times)

    for time, idx in events.items():
        if idx >= 0:
            chair = availableChairs.pop(0)
            assignedChair[idx] = chair
            if idx == targetFriend:
                return chair
        else:
            availableChairs.add(assignedChair[~idx])

    return -1
```

",,
"```python
def splitPainting(segments):
    line = {}
    for s in segments:
        start, end, color = s
        if start not in line:
            line[start] = 0
        if end not in line:
            line[end] = 0
        line[start] += color
        line[end] -= color
    res = []
    pre = 0
    sum = 0
    for key in sorted(line.keys()):
        if pre > 0:
            if sum > 0:
                res.append([pre, key, sum])
        pre = key
        sum += line[key]
    return res
```

",,
"```python
def truncate_sentence(s, k):
    words = s.split(' ')
    return ' '.join(words[:k])
```

",,
"```python
from collections import defaultdict

def finding_users_active_minutes(logs, k):
    user_minutes = defaultdict(set)
    for log in logs:
        user_minutes[log[0]].add(log[1])
    result = [0] * k
    for minutes in user_minutes.values():
        if len(minutes) <= k:
            result[len(minutes) - 1] += 1
    return result
```


",,
"```python
import bisect

def minAbsoluteSumDiff(nums1, nums2):
    n = len(nums1)
    total = 0
    max_diff = 0
    mod = 10**9 + 7
    sorted_nums1 = sorted(nums1)
    
    for i in range(n):
        diff = abs(nums1[i] - nums2[i])
        total += diff
        
        pos = bisect_left(sorted_nums1, nums2[i])
        if pos != n:
            max_diff = max(max_diff, diff - abs(sorted_nums1[pos] - nums2[i]))
        if pos != 0:
            max_diff = max(max_diff, diff - abs(sorted_nums1[pos - 1] - nums2[i]))
    
    return (total - max_diff + mod) % mod
```

",,
"```python
def count_different_subsequence_GCDs(nums):
    maximum = max(nums)
    gcd_count = [0] * (maximum + 1)
    
    for num in nums:
        for i in range(1, int(num**0.5) + 1):
            if num % i == 0:
                gcd_count[i] += 1
                if i * i != num:
                    gcd_count[num // i] += 1
                    
    different_GCDs = sum(1 for count in gcd_count if count > 0)
    
    return different_GCDs
```

",,
"```python
from collections import defaultdict

def delete_duplicate_folder(paths):
    folder_counts = defaultdict(int)
    
    for path in paths:
        path_string = '/' + '/'.join(path)
        folder_counts[path_string] += 1

    remaining_paths = []

    for path in paths:
        path_string = '/' + path[0]
        not_duplicate = folder_counts[path_string] == 1
        for i in range(1, len(path)):
            path_string += '/' + path[i]
            if folder_counts[path_string] > 1:
                not_duplicate = False
                break
        if not_duplicate:
            remaining_paths.append(path)

    return remaining_paths
```


",,
"```python
def sign_func(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0

def array_sign(nums):
    product = 1
    for x in nums:
        product *= x
    return sign_func(product)
```

",,
"```python
def minSideJumps(obstacles):
    n = len(obstacles)
    dp = [[n] * 3 for _ in range(n)]
    dp[0][1] = 0
    dp[0][0] = dp[0][2] = 1

    for i in range(1, n):
        if obstacles[i] != 1:
            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1)
        if obstacles[i] != 2:
            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1)
        if obstacles[i] != 3:
            dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1)

    return min(dp[-1])
```


",,
"```python
from collections import deque
from sortedcontainers import SortedList

class MKAverage:

    def __init__(self, m: int, k: int):
        self.m = m
        self.k = k
        self.sum = 0
        self.min_set = SortedList()
        self.mid_set = SortedList()
        self.max_set = SortedList()
        self.q = deque()

    def add_element(self, num: int) -> None:
        if len(self.q) == self.m:
            self.remove_element()

        self.min_set.add(num)
        self.sum += num
        
        if len(self.min_set) > self.k:
            temp = self.min_set.pop()
            self.mid_set.add(temp)
            self.sum += temp

        if self.min_set and self.mid_set and self.min_set[-1] > self.mid_set[0]:
            temp1 = self.min_set.pop()
            temp2 = self.mid_set.pop(0)
            self.min_set.add(temp2)
            self.mid_set.add(temp1)
            self.sum += temp2 - temp1

        self.max_set.add(self.mid_set.pop())
        self.sum -= self.mid_set.pop()
        self.mid_set.add(self.max_set.pop(0))

        if len(self.max_set) > self.k:
            temp = self.max_set.pop(0)
            self.mid_set.add(temp)
            self.sum += temp
        
        self.q.append(num)

    def calculate_mkaverage(self) -> int:
        if len(self.q) < self.m:
            return -1
        return self.sum // (self.m - 2 * self.k)

    def remove_element(self) -> None:
        temp = self.q.popleft()

        if temp in self.min_set:
            self.min_set.remove(temp)
        elif temp in self.mid_set:
            self.mid_set.remove(temp)
            self.sum -= temp
        else:
            self.max_set.remove(temp)
```


",,
"```python
def replace_digits(s: str) -> str:
    s = list(s)
    for i in range(1, len(s), 2):
        s[i] = chr(ord(s[i - 1]) + int(s[i]))
    return ''.join(s)
```

",,
"```python
import heapq

class SeatManager:
    def __init__(self, n: int):
        self.available_seats = [i for i in range(1, n + 1)]
        heapq.heapify(self.available_seats)

    def reserve(self) -> int:
        return heapq.heappop(self.available_seats)

    def unreserve(self, seatNumber: int) -> None:
        heapq.heappush(self.available_seats, seatNumber)
```

",,
"```python
def max_element(arr):
    max_val = max(arr)
    return max_val // 2
```

",,
"```python
def smallest_difference_room(rooms, queries):
    n = len(rooms)
    k = len(queries)
    rooms.sort(key=lambda x: x[0])
    results = []

    for i in range(k):
        preferred, minSize = queries[i]
        diff = float(""inf"")
        room_idx = -1

        for j in range(n):
            if rooms[j][1] >= minSize:
                tmp_diff = abs(preferred - rooms[j][0])
                if tmp_diff < diff:
                    diff = tmp_diff
                    room_idx = rooms[j][0]

        results.append(room_idx)

    return results
```

",,
"```python
def checkMove(board, rMove, cMove, color):
    directions = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))
    opposite_color = 'B' if color == 'W' else 'W'

    for d in directions:
        x, y = rMove + d[0], cMove + d[1]
        count = 0
        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opposite_color:
            x += d[0]
            y += d[1]
            count += 1

        if count > 0 and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == color:
            return True

    return False
```

",,
"```python
def minSpaceWastedKResizing(nums, k):
    n = len(nums)
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    sum_nums = [0] * (n + 1)
    dp[0][0] = 0
    
    for i in range(1, n + 1):
        sum_nums[i] = sum_nums[i - 1] + nums[i - 1]
        max_val = nums[i - 1]
        for j in range(i - 1, -1, -1):
            max_val = max(max_val, nums[j])
            waste = max_val * (i - j) - (sum_nums[i] - sum_nums[j])
            for c in range(k):
                dp[i][c + 1] = min(dp[i][c + 1], dp[j][c] + waste)

    return dp[n][k]
```

",,
"```python
def is_pangram(sentence):
    alphabet = [False] * 26
    for c in sentence:
        alphabet[ord(c) - ord('a')] = True
    return all(alphabet)
```

",,
"```python
def max_ice_cream(costs, coins):
    costs.sort()
    count = 0
    for cost in costs:
        if coins >= cost:
            coins -= cost
            count += 1
        else:
            break
    return count
```

",,
"```python
from queue import PriorityQueue

def getOrder(tasks):
    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])
    min_heap = PriorityQueue()
    time = 0
    task_idx = 0
    result = []

    while task_indices:
        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:
            idx = task_indices[task_idx]
            min_heap.put((tasks[idx][1], idx))
            task_idx += 1

        if not min_heap.empty():
            processing_time, index = min_heap.get()
            time += processing_time
            result.append(index)
            task_indices.remove(index)
        elif task_idx < len(task_indices):
            time = max(time, tasks[task_indices[task_idx]][0])

    return result
```


",,
"```python
def get_xor_sum(arr1, arr2):
    xor_arr1 = xor_arr2 = 0
    for i in arr1:
        xor_arr1 ^= i
    for j in arr2:
        xor_arr2 ^= j
    return xor_arr1 & xor_arr2
```

",,
"```python
def longest_obstacle_course(obstacles):
    dp = []
    ans = [0] * len(obstacles)

    for obstacle in obstacles:
        index = bisect_left(dp, obstacle)
        ans[index] = index + 1
        if index == len(dp):
            dp.append(obstacle)
        else:
            dp[index] = obstacle

    return ans
```

",,
"```python
def maxFrequency(nums, k):
    nums.sort()
    max_freq, n, total = 1, len(nums), 0
    i = 0
    for j in range(n):
        total += nums[j]
        while total < nums[j] * (j - i + 1) - k:
            total -= nums[i]
            i += 1
        max_freq = max(max_freq, j - i + 1)
    return max_freq
```

",,
"```python
def longest_beautiful_substring(word: str) -> int:
    if len(word) < 5:
        return 0

    max_length = current_length = 1
    current_vowels = word[0]

    for i in range(1, len(word)):
        if word[i] >= current_vowels[-1] and word[i] not in current_vowels:
            current_vowels += word[i]
        elif word[i] == current_vowels[-1]:
            pass
        else:
            current_vowels = word[i]
            current_length = 0

        current_length += 1

        if current_vowels == ""aeiou"":
            max_length = max(max_length, current_length)

    return max_length
```


",,
"```python
def max_building(n, restrictions):
    restrictions += [[1, 0], [n, n - 1]]
    restrictions.sort()

    for i in range(1, len(restrictions)):
        restrictions[i][1] = min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0])

    for i in range(len(restrictions) - 2, -1, -1):
        restrictions[i][1] = min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0])

    maxHeight = 0
    for i in range(1, len(restrictions)):
        height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) // 2
        maxHeight = max(maxHeight, height)

    return maxHeight
```


",,
"```python
def minNonZeroProduct(p: int) -> int:
    mod = 10**9 + 7
    x = (1 << p) - 1
    y = (1 << p) - 2
    z = pow(y, x - 1, mod)
    return x * z % mod
```

",,
"```python
def sort_sentence(s: str) -> str:
    tokens = s.split()
    words = [''] * len(tokens)
    
    for token in tokens:
        pos = int(token[-1]) - 1
        words[pos] = token[:-1]
    
    return ' '.join(words)
```

",,
"```python
def mem_sticks_crash(memory1, memory2):
    crash_time = 1
    while True:
        if memory1 >= memory2:
            if memory1 >= crash_time:
                memory1 -= crash_time
            else:
                break
        else:
            if memory2 >= crash_time:
                memory2 -= crash_time
            else:
                break
        crash_time += 1
    return [crash_time, memory1, memory2]
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def dfs(self, root, count):
        if not root:
            return 0
        left_sum = self.dfs(root.left, count)
        right_sum = self.dfs(root.right, count)
        if root.val == left_sum + right_sum:
            count[0] += 1
        return root.val + left_sum + right_sum

    def equalToDescendants(self, root):
        count = [0]
        self.dfs(root, count)
        return count[0]
```

",,
"```python
def minTimeToType(word: str) -> int:
    time = 0
    position = 0
    for c in word:
        next_position = ord(c) - ord('a')
        diff = abs(next_position - position)
        time += min(diff, 26 - diff) + 1
        position = next_position
    return time
```

",,
"```python
def find_target_distance(nums, target, start):
    min_distance = float('inf')
    for i, num in enumerate(nums):
        if num == target:
            distance = abs(i - start)
            min_distance = min(min_distance, distance)
    return min_distance
```

",,
"```python
def can_split_string(s: str) -> bool:
    count = [0] * 10

    for c in s:
        count[int(c)] += 1

    for i in range(1, 10):
        if count[i] > 0 and count[i] == count[i - 1]:
            return True

    return False
```

",,
"```python
def intervalFinding(intervals, queries):
    intervals.sort(key=lambda x: x[0])
    ans = []
    for q in queries:
        min_size = float('inf')
        for interval in intervals:
            if interval[0] <= q <= interval[1]:
                min_size = min(min_size, interval[1] - interval[0] + 1)
        ans.append(-1 if min_size == float('inf') else min_size)
    return ans
```


",,
"```python
def findGCD(nums):
    min_val, max_val = min(nums), max(nums)
    while max_val % min_val != 0:
        min_val, max_val = max_val % min_val, min_val
    return min_val
```

",,
"```python
def findDifferentBinaryString(nums):
    s = set(nums)
    n = len(nums)
    
    for i in range(1 << n):
        candidate = ''.join(['1' if i & (1 << j) else '0' for j in range(n)])
        if candidate not in s:
            return candidate
    return """"
```

",,
"```python
def minimizeTheDifference(mat, target):
    m, n = len(mat), len(mat[0])
    dp = [[0 for _ in range(800 * 70 + 1)] for _ in range(m)]
    dp[0] = mat[0]

    for i in range(1, m):
        for j in range(n):
            for k in range(800 * 70, 0, -1):
                if k - mat[i][j] >= 0 and dp[i - 1][k - mat[i][j]]:
                    dp[i][k] = 1

    min_diff = float('inf')
    for k in range(800 * 70 + 1):
        if dp[-1][k]:
            min_diff = min(min_diff, abs(k - target))

    return min_diff
```


",,
"```python
from collections import Counter

def recoverArray(n, sums):
    sums = Counter(sums)
    ans = []

    while len(ans) < n:
        # remove the 0 sum
        sums[0] -= 1
        if sums[0] == 0: del sums[0]

        # selected next value
        cur = next(iter(sums))
        sums[cur] -= 1
        if sums[cur] == 0: del sums[cur]

        # update sums
        tmp = Counter()
        for k, v in sums.items():
            cnt = v - Ans.count(k - cur)
            if cnt > 0:
                tmp[k] = cnt
        sums = tmp
        ans.append(cur)
    return ans
```

",,
"```python
def max_alive_year(logs):
    years = [0] * 2051
    
    for log in logs:
        years[log[0]] += 1
        years[log[1]] -= 1
    
    max_population = 0
    max_year = 0
    population = 0
    for i in range(1950, 2051):
        population += years[i]
        if population > max_population:
            max_population = population
            max_year = i

    return max_year
```


",,
"```python
def max_distance(nums1, nums2):
    i, j, max_dist = 0, 0, 0
    while i < len(nums1) and j < len(nums2):
        if i <= j and nums1[i] <= nums2[j]:
            max_dist = max(max_dist, j - i)
            j += 1
        else:
            i += 1
    return max_dist
```

",,
"```python
def maxMinProduct(nums):
    res, mod = 0, 10**9 + 7
    n = len(nums)
    prefix = [0] * (n + 1)
    stack = []

    for i in range(n):
        prefix[i + 1] = (prefix[i] + nums[i]) % mod

    for i in range(n + 1):
        while stack and (i == n or nums[stack[-1]] > nums[i]):
            j = stack.pop()
            res = max(res, nums[j] * (prefix[i] - prefix[stack[-1] + 1 if stack else 0]) % mod)
        stack.append(i)

    return res
```

",,
"```python
from collections import defaultdict


def largestPathValue(colors, edges):
    def dfs(node):
        if not cache[node][ord(colors[node]) - ord('a')]:
            cache[node][ord(colors[node]) - ord('a')] = 1
            for neighbor in graph[node]:
                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],
                                                               1 + dfs(neighbor))
        return cache[node][ord(colors[node]) - ord('a')]

    n = len(colors)
    graph = [set() for _ in range(n)]
    for a, b in edges:
        graph[a].add(b)

    cache = [[0] * 26 for _ in range(n)]
    in_degree = [0] * n
    for a, b in edges:
        in_degree[b] += 1
    res = -1
    for i in range(n):
        if in_degree[i] == 0:
            res = max(res, dfs(i))
    return res
```

",,
"```python
def count_good_substrings(s: str) -> int:
    count = 0
    for i in range(len(s) - 2):
        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:
            count += 1
    return count
```

",,
"```python
def minimum_xor_sum(nums1, nums2):
    nums2.sort()
    xor_sum = 0
    for i in range(len(nums1)):
        xor_sum += nums1[i] ^ nums2[i]
    return xor_sum
```

",,
"```python
def findMiddleIndex(nums):
    total_sum = sum(nums)
    left_sum = 0

    for i, num in enumerate(nums):
        if left_sum == total_sum - left_sum - num:
            return i
        left_sum += num

    return -1
```

",,
"```python
def findFarmland(land):
    m, n = len(land), len(land[0])
    groups = []
    
    for i in range(m):
        for j in range(n):
            if land[i][j] == 1:
                r1, c1 = i, j
                while j + 1 < n and land[i][j + 1] == 1:
                    j += 1
                r2, c2 = i, j
                while r2 + 1 < m and land[r2 + 1][j] == 1:
                    r2 += 1
                for r in range(r1, r2 + 1):
                    for c in range(c1, c2 + 1):
                        land[r][c] = 0
                groups.append([r1, c1, r2, c2])

    return groups
```

",,
"```python
def subset_xor_sum(nums):
    result = 0
    n = len(nums)
    num_subsets = 1 << n

    for i in range(num_subsets):
        subset_xor = 0
        for j in range(n):
            if i & (1 << j):
                subset_xor ^= nums[j]
        result += subset_xor

    return result
```

",,
"```python
def min_swaps(s: str) -> int:
    zeros, ones = 0, 0
    for c in s:
        if c == '0':
            zeros += 1
        else:
            ones += 1

    if abs(zeros - ones) > 1:
        return -1

    mismatch_count1, mismatch_count2 = 0, 0
    for i, c in enumerate(s):
        if i % 2 == 0:
            if c != '0': mismatch_count1 += 1
            if c != '1': mismatch_count2 += 1
        else:
            if c != '1': mismatch_count1 += 1
            if c != '0': mismatch_count2 += 1

    return min(mismatch_count1, mismatch_count2) // 2
```


",,
"```python
def numberOfSticks(n, k):
    MOD = 10**9 + 7
    if n < k: return 0
    dp = [[0] * (n+1) for _ in range(n+1)]

    for i in range(1, n+1):
        dp[i][1] = 1
        for j in range(2, i+1):
            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD

    return dp[n][k]
```

",,
"```python
def firstDayBeenInAllRooms(nextVisit):
    n = len(nextVisit)
    MOD = 10**9 + 7
    dp = [0] * n

    for i in range(1, n):
        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD

    return dp[n - 1]
```

",,
"```python
from math import gcd

def can_be_sorted(nums):
    sorted_nums = sorted(nums)
    for i in range(len(nums)):
        if nums[i] != sorted_nums[i] and gcd(nums[i], sorted_nums[i]) == 1:
            return False
    return True
```

",,
"```python
def checkZeroOnes(s: str) -> bool:
    longest_zero = longest_one = current_zero = current_one = 0
    
    for c in s:
        if c == '0':
            current_zero += 1
            longest_zero = max(longest_zero, current_zero)
            current_one = 0
        else:
            current_one += 1
            longest_one = max(longest_one, current_one)
            current_zero = 0
            
    return longest_one > longest_zero
```


",,
"```python
import math
def minimum_speed(n, hour, dist):
    if n > math.ceil(hour): return -1
    low, high = 1, int(1e7)
    
    while low <= high:
        mid = low + (high - low) // 2
        time = sum(math.ceil(d / mid) for d in dist)
        if time <= hour:
            speed = mid
            high = mid - 1
        else:
            low = mid + 1
            
    return speed
```

",,
"```python
def canReach(s: str, minJump: int, maxJump: int) -> bool:
    n = len(s)
    dp = [False] * n
    dp[0] = True
    pre = 0
    for i in range(1, n):
        if i >= minJump:
            pre += dp[i - minJump]
        if i > maxJump:
            pre -= dp[i - maxJump - 1]
        dp[i] = pre > 0 and s[i] == '0'
    return dp[n - 1]
```


",,
"```python
def stoneGameVII(stones):
    n = len(stones)
    dp = [[0] * n for _ in range(n)]

    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])

    return dp[0][n - 1]
```

",,
"```python
from collections import defaultdict

def smallestMissingValueSubtree(parents, nums):
    n = len(parents)
    children = defaultdict(set)
    for i in range(1, n):
        children[parents[i]].add(nums[i])

    ans = [0] * n
    dfs(0, parents, nums, children, ans)
    return ans

def dfs(node, parents, nums, children, ans):
    for child in list(children[node]):
        dfs(child, parents, nums, children, ans)
        children[node].remove(child)
        children[node].add(ans[child])
    it = next((x for x in children[node] if x > nums[node]), nums[node] + 1)
    ans[node] = it - 1 if it != nums[node] + 1 else it
```

",,
"```python
def is_covered(ranges, left, right):
    for i in range(left, right + 1):
        is_covered = False
        for range_ in ranges:
            if i >= range_[0] and i <= range_[1]:
                is_covered = True
                break
        if not is_covered:
            return False
    return True
```


",,
"```python
def chalk_replacer(chalk, k):
    total_chalk = sum(chalk)
    k %= total_chalk
    for i, val in enumerate(chalk):
        if k < val:
            return i
        k -= val
    return 0
```

",,
"```python
def find_original_array(changed):
    if len(changed) % 2 != 0:
        return []

    count = {}
    for num in changed:
        count[num] = count.get(num, 0) + 1

    original = []
    for num, freq in count.items():
        if freq > count.get(num * 2, 0):
            return []

        for _ in range(freq):
            original.append(num)

    return original
```

",,
"```python
def minOperationsToFlip(expression: str) -> int:
    zero, one, op = [0], [0], []
    for c in expression:
        if c == '&':
            op.append(1)
        elif c == '|':
            op.append(2)
        elif c.isdigit():
            if c == '0':
                one.append(1)
                zero.append(0)
            else:
                zero.append(1)
                one.append(0)
        elif c == ')':
            cur_op = op.pop()
            x = zero.pop()
            y = one.pop() + 1
            if cur_op == 1:
                new_zero = max(x, y)
                new_one = one[-1] + min(x, zero[-1])
            else:
                new_zero = zero[-1] + min(x, one[-1])
                new_one = max(y, one[-1])
            zero.pop()
            one.pop()
            zero.append(new_zero)
            one.append(new_one)
    return zero[-1] + 1
```

",,
"```python
def min_operations(nums):
    n = len(nums)
    s = sorted(set(nums))
    res = float('inf')
    j = 0
    
    for i in range(len(s)):
        while j < len(s) and s[j] <= s[i] + n - 1:
            j += 1
        res = min(res, n - (j - i))
        
    return res
```

",,
"```python
def max_value(n: str, x: int) -> str:
    is_negative = n[0] == '-'
    pos = 1 if is_negative else 0

    while pos < len(n):
        if (is_negative and int(n[pos]) > x) or (not is_negative and int(n[pos]) < x):
            break
        pos += 1

    return n[:pos] + str(x) + n[pos:]
```

",,
"```python
from queue import PriorityQueue

def assignTasks(servers, tasks):
    n, m = len(servers), len(tasks)
    ans = [0] * m
    freeServers = PriorityQueue()

    for i in range(n):
        freeServers.put((servers[i], i))

    busyServers = PriorityQueue()
    currentTask = 0

    while currentTask < m:
        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:
            _, idx = busyServers.get()
            freeServers.put((servers[idx], idx))

        while not freeServers.empty() and currentTask < m:
            _, idx = freeServers.get()
            ans[currentTask] = idx
            busyServers.put((currentTask + tasks[currentTask], idx))
            currentTask += 1
            
        if freeServers.empty():
            currentTask = busyServers.queue[0][0]
    
    return ans
```

",,
"```python
from math import ceil

def min_skips(dist, speed, hours_before):
    n = len(dist)
    dp = [[1e6] * (n + 1) for _ in range(n + 1)]
    
    dp[0][0] = 0
    for i in range(1, n + 1):
        dp[i][0] = ceil(dp[i - 1][0] + dist[i - 1] / speed)
    
    for i in range(1, n + 1):
        for skip in range(1, i + 1):
            dp[i][skip] = min(dp[i][skip], dp[i - 1][skip - 1] + dist[i - 1] / speed)
            dp[i][skip] = min(dp[i][skip], ceil(dp[i - 1][skip] + dist[i - 1] / speed))
    
    for skip in range(n + 1):
        if dp[n][skip] <= hours_before:
            return skip
    return -1
```

",,
"```python
def longestSubsequenceRepeatedK(s, k):
    count = [0] * 26
    for c in s:
        count[ord(c) - ord('a')] += 1
    seq = """".join(chr(i + ord('a')) * (count[i] // k) for i in range(26) if count[i] >= k)

    def dp(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        if i >= len(seq) or j >= len(seq):
            return 0
        if seq[i] == seq[j]:
            res = 1 + dp(i + 1, j + 1)
        else:
            res = max(dp(i + 1, j), dp(i, j + 1))
        memo[(i, j)] = res
        return res

    memo = {}
    res = []
    i, j = 0, 0
    while j < len(seq) and len(res) < len(seq) // k:
        if not res or seq[j] > res[-1]:
            if dp(i, j) >= (len(seq) // k - len(res)) * 2:
                res.append(seq[j])
                i = j + 1
        j += 1

    return """".join(res)
```


",,
"```python
def findRotation(mat, target):
    for _ in range(4):
        if mat == target:
            return True
        n = len(mat)
        for r in range((n + 1) // 2):
            for c in range(n // 2):
                mat[r][c], mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r] = mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r], mat[r][c]
    return False
```

",,
"```python
def min_steps_to_equal_elements(nums):
    min_elem = min(nums)
    steps = 0
    for num in nums:
        steps += (num - min_elem)
    return steps
```

",,
"```python
def min_operations(s):
    cnt = 0
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            cnt += 1
    return cnt
```

",,
"```python
from bisect import bisect_right

class Solution:
    def minWastedSpace(self, packages, boxes) -> int:
        MOD = 10**9 + 7
        packages.sort()
        total_package_size = sum(packages)
        min_wasted_space = float('inf')

        for box_sizes in boxes:
            box_sizes.sort()
            if box_sizes[-1] < packages[-1]:
                continue
            wasted_space = 0
            package_idx = 0
            for box_size in box_sizes:
                package_idx = bisect_right(packages, box_size, package_idx)
                wasted_space += box_size - packages[package_idx - 1]
            min_wasted_space = min(min_wasted_space, wasted_space)

        return -1 if min_wasted_space == float('inf') else (total_package_size + min_wasted_space) % MOD
```


",,
"```python
def sumOfPoints(s: str, answers: List[int]) -> int:
    correct = 0
    mul = 1
    add = 0
    for i in range(len(s)):
        if s[i].isdigit():
            num = int(s[i])
            mul *= num
            if i == len(s) - 1 or s[i + 1] == '+':
                add += mul
                mul = 1
    correct = add

    wrongOrder = int(s[0])
    for i in range(2, len(s), 2):
        if s[i - 1] == '+':
            wrongOrder += int(s[i])
        else:
            wrongOrder *= int(s[i])

    return sum(5 * (ans == correct) + 2 * (ans == wrongOrder) for ans in answers)
```

",,
"```python
def remove_occurrences(s, part):
    while part in s:
        s = s.replace(part, '', 1)
    return s
```

",,
"```python
def max_alternating_sum(nums):
    even_sum = odd_sum = 0
    for num in nums:
        even_sum, odd_sum = max(even_sum + num, odd_sum), even_sum - num
    return even_sum
```

",,
"```python
from collections import defaultdict
from sortedcontainers import SortedList

class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.price = defaultdict(dict)
        self.rented = SortedList(key=lambda x: (x[0], x[1]))
        self.available = defaultdict(SortedList)
        for shop, movie, p in entries:
            self.price[shop][movie] = p
            self.available[movie].add((p, shop))

    def search(self, movie: int) -> List[int]:
        return [x[1] for x in self.available[movie][:5]]

    def rent(self, shop: int, movie: int) -> None:
        p = self.price[shop][movie]
        self.rented.add((p, shop))
        self.available[movie].discard((p, shop))

    def drop(self, shop: int, movie: int) -> None:
        p = self.price[shop][movie]
        self.rented.discard((p, shop))
        self.available[movie].add((p, shop))

    def report(self) -> List[List[int]]:
        return [[shop, movie] for p, shop, movie in self.rented]

```


",,
"```python
def max_consecutive_answers(answer_key: str, k: int) -> int:
    max_len, left, T_cnt, F_cnt = 0, 0, 0, 0

    for right, c in enumerate(answer_key):
        if c == 'T':
            T_cnt += 1
        else:
            F_cnt += 1

        if min(T_cnt, F_cnt) > k:
            if answer_key[left] == 'T':
                T_cnt -= 1
            else:
                F_cnt -= 1
            left += 1
        else:
            max_len = max(max_len, T_cnt + F_cnt)

    return max_len
```


",,
"```python
def make_equal(words):
    chars = set()
    total_chars = 0
    for word in words:
        total_chars += len(word)
        for c in word:
            chars.add(c)
    return total_chars % len(chars) == 0
```

",,
"```python
def maximumRemovals(s: str, p: str, removable: List[int]) -> int:
    low, high = 0, len(removable)
    while low < high:
        mid = low + (high - low + 1) // 2
        ss = list(s)
        for i in range(mid):
            ss[removable[i]] = '-'
        j, i = 0, 0
        while i < len(ss) and j < len(p):
            if ss[i] == p[j]:
                j += 1
            i += 1
        if j == len(p):
            low = mid
        else:
            high = mid - 1
    return low
```


",,
"```python
def earliest_and_latest(n, first_player, second_player):
    earliest, latest = 1, 1
    while (first_player + second_player) != n + 1 or abs(first_player - second_player) != 1:
        if (first_player + second_player) <= n + 1 and (first_player - 1) // 2 == (second_player - 1) // 2:
            break
        if (first_player + second_player) > n + 1:
            n = (n + 1) // 2
            first_player, second_player = (n + 1) - second_player, (n + 1) - first_player
        else:
            first_player = (first_player + 1) // 2
            second_player = (second_player + 1) // 2
        earliest += 1
        latest += 1

    return [earliest, latest]
```

",,
"```python
def stoneGameIX(stones: List[int]) -> bool:
    cnt = [0, 0, 0]
    for s in stones:
        cnt[s % 3] += 1
    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)
```


",,
"```python
def smallestSubsequence(s, k, letter, repetition):
    n = len(s)
    remaining = n - k
    letter_count = 0

    res = []
    for c in s:
        while res and res[-1] > c and remaining > 0:
            if res[-1] == letter:
                if letter_count > repetition:
                    letter_count -= 1
                    res.pop()
                    remaining -= 1
            else:
                res.pop()
                remaining -= 1
        if len(res) < k:
            if c == letter:
                letter_count += 1
            elif k - len(res) > repetition - letter_count:
            else:
                continue
            res.append(c)

    return ''.join(res)
```


",,
"```python
def min_moves(n):
    dp = [0, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
        dp[i] = i
        for x in range(1, i):
            broken = x - 1
            unbroken = i - x
            dp[i] = min(dp[i], 1 + max(dp[broken], dp[unbroken]))

    return dp[n]
```

",,
"```python
def largest_odd(num: str) -> str:
    for i in range(len(num)):
        if (int(num[i]) % 2) == 1:
            return num[:i + 1]
    return """"
```

",,
"```python
def full_rounds_played(login_time, logout_time):
    login_hour, login_minute = map(int, login_time.split(':'))
    logout_hour, logout_minute = map(int, logout_time.split(':'))

    if (logout_hour * 60 + logout_minute) < (login_hour * 60 + login_minute):
        logout_hour += 24

    rounds = (logout_hour * 60 + logout_minute - (login_hour * 60 + login_minute)) // 15
    return rounds
```


",,
"```python
def min_absolute_difference(nums, queries):
    result = []

    for query in queries:
        left, right = query
        unique = list(set(nums[left:right + 1]))

        if len(unique) == 1:
            result.append(-1)
        else:
            unique.sort()
            min_diff = float('inf')
            for i in range(1, len(unique)):
                min_diff = min(min_diff, unique[i] - unique[i - 1])

            result.append(min_diff)

    return result
```

",,
"```python
def countSubIslands(grid1, grid2):
    def dfs(i, j):
        if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0:
            return True

        grid2[i][j] = 0

        isSubIsland = grid1[i][j] == 1
        isSubIsland &= dfs(i + 1, j)
        isSubIsland &= dfs(i - 1, j)
        isSubIsland &= dfs(i, j + 1)
        isSubIsland &= dfs(i, j - 1)

        return isSubIsland

    count = 0

    for i in range(len(grid1)):
        for j in range(len(grid1[0])):
            if grid2[i][j] == 1 and dfs(i, j):
                count += 1

    return count
```

",,
"```python
def maxAlternatingSum(nums):
    odd, even = 0, 0
    for num in nums:
        newOdd = max(even + num, odd)
        even = max(odd - num, even)
        odd = newOdd
    return odd
```

",,
"```python
def count_square_triples(n):
    count = 0
    for a in range(1, n + 1):
        for b in range(a, n + 1):
            c = int((a * a + b * b)**0.5)
            if c * c == a * a + b * b and c <= n:
                count += 1
    return count
```


",,
"```python
from collections import deque

def nearest_exit(maze, entrance):
    m, n = len(maze), len(maze[0])
    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
    q = deque()
    maze[entrance[0]][entrance[1]] = '+'
    q.append((entrance[0], entrance[1]))
    steps = 0

    while q:
        size = len(q)
        for _ in range(size):
            x, y = q.popleft()
            if (x == 0 or x == m - 1 or y == 0 or y == n - 1) and (x != entrance[0] or y != entrance[1]):
                return steps

            for dir in directions:
                xx, yy = x + dir[0], y + dir[1]
                if 0 <= xx < m and 0 <= yy < n and maze[xx][yy] == '.':
                    maze[xx][yy] = '+'
                    q.append((xx, yy))
        steps += 1

    return -1
```


",,
"```python
def sumGame(num: str) -> bool:
    n = len(num)
    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0

    for i in range(n // 2):
        if num[i] == '?': cnt1 += 1
        else: sum1 += int(num[i])

    for i in range(n // 2, n):
        if num[i] == '?': cnt2 += 1
        else: sum2 += int(num[i])

    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9
```

",,
"```python
import heapq
from collections import defaultdict

def minCost(maxTime, edges, passingFees):
    n = len(passingFees)
    graph = defaultdict(list)
    for x, y, time in edges:
        graph[x].append((y, time))
        graph[y].append((x, time))

    dp = [[float('inf')] * (maxTime + 1) for _ in range(n)]
    dp[0][0] = passingFees[0]

    pq = [(0, 0, passingFees[0])]
    while pq:
        time, city, cost = heapq.heappop(pq)
        if city == n - 1:
            return cost

        for neighbor, t in graph[city]:
            next_time = time + t
            if next_time > maxTime:
                continue

            new_cost = cost + passingFees[neighbor]
            if new_cost < dp[neighbor][next_time]:
                dp[neighbor][next_time] = new_cost
                heapq.heappush(pq, (next_time, neighbor, new_cost))

    return -1
```


",,
"```python
def maxProductDifference(nums):
    min1, min2, max1, max2 = float('inf'), float('inf'), float('-inf'), float('-inf')
    for num in nums:
        if num < min1:
            min2, min1 = min1, num
        elif num < min2:
            min2 = num
        if num > max1:
            max2, max1 = max1, num
        elif num > max2:
            max2 = num
    return max1 * max2 - min1 * min2
```

",,
"```python
def rotateGrid(grid, k):
    def rotateLayer(layer, k):
        m, n = len(grid), len(grid[0])
        top, bottom = layer, m - 1 - layer
        left, right = layer, n - 1 - layer
        data_in_layer = (right - left + 1) * 2 + (bottom - top - 1) * 2
        k %= data_in_layer
        for _ in range(k):
            temp = grid[top][left]
            for j in range(left, right):
                grid[top][j] = grid[top][j + 1]
            for i in range(top, bottom):
                grid[i][right] = grid[i + 1][right]
            for j in range(right, left, -1):
                grid[bottom][j] = grid[bottom][j - 1]
            for i in range(bottom, top, -1):
                grid[i][left] = grid[i - 1][left]
            grid[top + 1][left] = temp

    m, n = len(grid), len(grid[0])
    layers = min(m, n) // 2
    for layer in range(layers):
        rotateLayer(layer, k)
    return grid
```

",,
"```python
def wonderfulSubstrings(word: str) -> int:
    res = 0
    mask = 0
    count = {0: 1}
    for c in word:
        mask ^= 1 << (ord(c) - ord('a'))
        res += count.get(mask, 0)
        for i in range(10):
            res += count.get(mask ^ (1 << i), 0)
        count[mask] = count.get(mask, 0) + 1
    return res
```

",,
"```python
from collections import defaultdict, deque

def secondMinimum(n, edges, time, change):
    graph = defaultdict(list)
    
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    dist = [float('inf')] * (n + 1)
    dist2 = [float('inf')] * (n + 1)
    dist[1] = 0

    q = deque([1])

    while q:
        cur = q.popleft()

        nextDist = dist[cur] + time
        waitTime = change if (nextDist // change) % 2 == 1 else 0
        nextDist += waitTime

        for next in graph[cur]:
            if nextDist < dist[next]:
                nextDist, dist[next] = dist[next], nextDist
                q.append(next)
            if nextDist < dist2[next]:
                nextDist, dist2[next] = dist2[next], nextDist
                q.append(next)

    return dist2[n]
```


",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def sortedList(head):
    if not head or not head.next:
        return head

    prev = head
    cur = head.next

    while cur:
        if cur.val < prev.val:
            prev.next = cur.next
            cur.next = head
            head = cur
            cur = prev
        else:
            prev = cur
        cur = cur.next
    return head
```

",,
"```python
def findPeakGrid(mat: List[List[int]]) -> List[int]:
    m, n = len(mat), len(mat[0])
    l, r = 0, n - 1

    while l < r:
        mid = (l + r) // 2
        max_row = 0

        for i in range(1, m):
            if mat[i][mid] > mat[max_row][mid]:
                max_row = i

        if mat[max_row][mid] < mat[max_row][mid + 1]:
            l = mid + 1
        else:
            r = mid

    max_row = 0
    for i in range(1, m):
        if mat[i][l] > mat[max_row][l]:
            max_row = i

    return [max_row, l]
```

",,
"```python
def build_array(nums):
    ans = []
    for i in range(len(nums)):
        ans.append(nums[nums[i]])
    return ans
```

",,
"```python
def eliminate_monsters(dist, speed):
    n = len(dist)
    time_to_reach = sorted(dist[i] / speed[i] for i in range(n))
    monsters_eliminated = 0
    for time in time_to_reach:
        if monsters_eliminated < time:
            monsters_eliminated += 1
    return monsters_eliminated
```

",,
"```python
def count_good_digit_strings(n):
    mod = 10 ** 9 + 7
    even_digits, prime_digits = 5, 4
    total = 1
    for i in range(n):
        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod
    return total
```

",,
"```python
def minCost(sentence: str, k: int) -> int:
    words = sentence.split()
    dp = [float('inf')] * (len(words) + 1)
    dp[0] = 0
    for i in range(len(words)):
        length = 0
        j = i
        while j >= 0:
            length += len(words[j])
            if length + (i - j) <= k:
                dp[i + 1] = min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)))
            else:
                break
            length += 1
            j -= 1
    return dp[-1]
```


",,
"```python
def is_good_string(s: str) -> bool:
    freq_map = {}
    for c in s:
        if c in freq_map:
            freq_map[c] += 1
        else:
            freq_map[c] = 1

    count = next(iter(freq_map.values()))
    for value in freq_map.values():
        if value != count:
            return False
    return True
```

",,
"```python
def find_chair(times, target_friend):
    n = len(times)
    events = []
    for i, (arrival, leaving) in enumerate(times):
        events.append((arrival, i))
        events.append((leaving, ~i))
    events.sort()
    chairs = [-1] * n
    available_chairs = sorted(range(n))
    for time, friend_id in events:
        if friend_id >= 0:
            chairs[friend_id] = available_chairs.pop(0)
            if friend_id == target_friend:
                return chairs[friend_id]
        else:
            available_chairs.append(chairs[~friend_id])
            available_chairs.sort()
    return -1
```


",,
"```python
from collections import defaultdict

def splitPainting(segments):
    changes = defaultdict(int)
    for start, end, color in segments:
        changes[start] += color
        changes[end] -= color

    result = []
    start, color_sum = 0, 0
    for key in sorted(changes.keys()):
        if start != key:
            if color_sum:
                result.append([start, key, color_sum])
            start = key
        color_sum += changes[key]

    return result
```

",,
"```python
def count_valid_combos(pieces, positions, index=0):
    if index == len(pieces):
        return 1

    r, c = positions[index]
    dr = [0, 1, 0, -1, 1, 1, -1, -1]
    dc = [1, 0, -1, 0, 1, -1, 1, -1]
    valids = 0

    for x in range(8):
        if pieces[index] == ""bishop"" and x < 4:
            continue
        if pieces[index] == ""rook"" and x >= 4:
            break

        for dist in range(1, 9):
            nr, nc = r + dr[x] * dist, c + dc[x] * dist
            if nr < 1 or nr > 8 or nc < 1 or nc > 8:
                break
            if nr == r and nc == c:
                continue

            valid = True
            for other in range(len(positions)):
                if other == index:
                    continue
                orr, occ = positions[other]
                if orr == nr and occ == nc:
                    valid = False
                    break
                if orr + occ == nr + nc or orr - occ == nr - nc:
                    valid = False
                    break
                if orr == nr or occ == nc:
                    valid = False
                    break

            if valid:
                positions[index] = [nr, nc]
                valids += count_valid_combos(pieces, positions, index + 1)
                positions[index] = [r, c]

    return valids
```

",,
"```python
def smallest_index(nums):
    for i, num in enumerate(nums):
        if i % 10 == num:
            return i
    return -1
```

",,
"```python
def get_concatenation(nums):
    n = len(nums)
    ans = [0] * (2 * n)
    for i in range(n):
        ans[i] = nums[i]
        ans[i + n] = nums[i]
    return ans
```

",,
"```python
def count_three_char_palindromes(s):
    count = 0
    freq = {}
    for ch in s:
        if ch in freq:
            freq[ch] += 1
        else:
            freq[ch] = 1
    for value in freq.values():
        count += value * (value - 1) // 2
    return count
```


",,
"```python
def merge_trees(trees):
    while len(trees) > 1:
        tree1 = trees.pop()
        tree2 = trees.pop()

        if tree1.val < tree2.val:
            tree1.right = tree2
            trees.append(tree1)
        else:
            tree2.right = tree1
            trees.append(tree2)
    return None if not trees else trees[0]
```

",,
"```python
def colorTheGrid(m, n):
    mod = 10**9 + 7
    dp = [6, 6]
    dpf = [3, 3]

    for _ in range(2, max(m, n) + 1):
        temp = dp[1]
        dp[1] = (dpf[1] * 2) % mod
        dp[0] = temp
        dpf[1] = (dpf[1] + dpf[0]) % mod
        dpf[0] = (dpf[0] + temp) % mod

    return (dp[0 if m == 1 else 1] * dpf[0 if n == 1 else 1]) % mod
```

",,
"```python
def count_vowel_substrings(word: str) -> int:
    count, a, e, i, o, u = 0, 0, 0, 0, 0, 0
    for c in word:
        if c == 'a': a += 1
        elif c == 'e': e = a + e
        elif c == 'i': i = e + i
        elif c == 'o': o = i + o
        elif c == 'u': u = o + u
    return u
```

",,
"```python
def count_vowels(word):
    sum = 0
    count = 0
    for letter in word:
        if letter in ""aeiou"":
            count += 1
        sum += count
    return sum

def count_vowels_in_substrings(word):
    return count_vowels(word)
```

",,
"```python
def minimum_maximum(n, quantities):
    sum_products = sum(quantities)
    x = (sum_products + n - 1) // n
    remaining_stores = n
    for q in quantities:
        remaining_stores -= (q + x - 1) // x
        if remaining_stores < 0:
            x = (sum_products + remaining_stores) // (n + remaining_stores)
            remaining_stores = n
    return x
```


",,
"```python
from collections import defaultdict

def maxQuality_dfs(node, time_left, visited, values, neighbors):
    acc = 0
    for neighbor, cost in neighbors[node]:
        if time_left >= cost and not visited[neighbor]:
            visited[neighbor] = 1
            acc = max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors))
            visited[neighbor] = 0
    return acc

def maxQuality(values, edges, maxTime):
    neighbors = defaultdict(list)
    for u, v, cost in edges:
        neighbors[u].append((v, cost))
        neighbors[v].append((u, cost))
    visited = [0] * len(values)
    return maxQuality_dfs(0, maxTime, visited, values, neighbors)
```


",,
"```python
def maxScore(points):
    m, n = len(points), len(points[0])
    dp = [points[0]]

    for r in range(1, m):
        dp.append([0] * n)
        for c in range(n):
            score = points[r][c]
            dp[r][c] = max(dp[r - 1][c_prev] + score - abs(c - c_prev) for c_prev in range(n))
            
    return max(dp[m - 1])
```


",,
"```python
import collections

def maxGeneticDifference(parents, queries):
    M = 17
    tr = [0, 0]

    def insert(x):
        nonlocal tr
        u = 0
        for i in range(M - 1, -1, -1):
            v = (x >> i) & 1
            if not tr[u][v]:
                tr[u][v] = len(tr)
                tr.append([0, 0])
            u = tr[u][v]

    def query(x, y=0):
        u = 0
        ans = 0
        for i in range(M - 1, -1, -1):
            v = ((x >> i) & 1) ^ 1
            if not tr[u][v]:
                v ^= 1
            ans |= (y := (y << 1) | v)
            u = tr[u][v]
        return ans

    def dfs(u, tree=0, g=collections.defaultdict(list), ans=None):
        nonlocal tr
        insert(tree := tree ^ u)
        ans[u] = query(tree)
        for v in g[u]:
            dfs(v, tree, g, ans)

    n = len(parents)
    root = -1
    graph = collections.defaultdict(list)
    for i, parent in enumerate(parents):
        if parent != -1:
            graph[parent].append(i)
        else:
            root = i

    ans = [0] * n
    dfs(root, 0, graph, ans)
    result = [ans[node] ^ val for node, val in queries]
    return result
```


",,
"```python
class Robot:

    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.x, self.y = 0, 0
        self.dir = 0
        self.dx = [1, 0, -1, 0]
        self.dy = [0, 1, 0, -1]

    def step(self, num: int):
        while num > 0:
            nx, ny = self.x + self.dx[self.dir], self.y + self.dy[self.dir]
            if 0 <= nx < self.width and 0 <= ny < self.height:
                self.x, self.y = nx, ny
            else:
                self.dir = (self.dir + 1) % 4
                num += 1  # Retry the step
            num -= 1

    def getPos(self) -> list[int]:
        return [self.x, self.y]

    def getDir(self) -> str:
        return [""East"", ""North"", ""West"", ""South""][self.dir]
```

",,
"```python
from bisect import bisect_right

def maxPrices(items, queries):
    answer = []
    sorted_items = [item[0] for item in items]
    sorted_items.sort()

    max_beauty = 0
    for i, price in enumerate(sorted_items):
        max_beauty = max(max_beauty, items[i][1])
        sorted_items[i] = max_beauty

    for query in queries:
        idx = bisect_right(sorted_items, query) - 1
        answer.append(sorted_items[idx] if idx >= 0 else 0)

    return answer
```


",,
"```python
def maxTasks(tasks, workers, pills, strength):
  tasks.sort()
  workers.sort()

  cnt = 0
  i = 0
  for j in range(pills):
    while i < len(tasks) and tasks[i] > workers[j] + strength:
      i += 1
    if i < len(tasks):
      cnt += 1
      i += 1

  i = 0
  for j in range(pills, len(workers)):
    if i < len(tasks) and tasks[i] <= workers[j]:
      cnt += 1
      i += 1
      
  return cnt
```


",,
"```python
def time_to_buy_tickets(tickets, k):
    time = 0
    while tickets[k] > 0:
        for i in range(len(tickets)):
            if tickets[i] > 0:
                tickets[i] -= 1
                time += 1
                if i == k and tickets[k] == 0:
                    break
    return time
```

",,
"```python
class Solution:
    def reverseGroup(self, head, k):
        if not head or k == 1:
            return head
        prev = None
        cur = head
        for _ in range(k):
            next = cur.next
            cur.next = prev
            prev = cur
            cur = next
        head.next = cur
        return prev

    def reverseEvenGroups(self, head):
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        n = 0
        cur = head
        while cur:
            n += 1
            cur = cur.next
        i, k = 1, 1
        while n >= 0 and k <= n:
            if i % 2 == 0:
                tail = prev.next
                next = prev.next
                for _ in range(k):
                    next = next.next
                prev.next = self.reverseGroup(tail, k)
                tail.next = next
            n -= k
            for _ in range(k):
                prev = prev.next
            i += 1
            k += i
        return dummy.next
```


",,
"```python
def slanted_transposition_cipher(encodedText, rows):
    if rows == 1:
        return encodedText
    
    n = len(encodedText)
    cols = (n + rows - 2) // (rows - 1)
    pos = 0
    matrix = [[' ' for col in range(cols)] for row in range(rows)]
    for k in range(cols):
        for i in range(rows):
            if k % 2 == 0 or i != 0:
                matrix[i][k] = encodedText[pos]
                pos += 1
                
    originalText = ''.join(''.join(row) for row in matrix)
    
    return originalText
```

",,
"```python
def alphabet_position_sum(s, k):
    sum = 0
    for c in s:
        sum += ord(c) - ord('a') + 1
    for _ in range(k):
        new_sum = 0
        while sum > 0:
            new_sum += sum % 10
            sum //= 10
        sum = new_sum
    return sum
```

",,
"```python
def maximumNumber(num: str, change: List[int]) -> str:
    num = list(num)
    mutatable = False
    for i in range(len(num)):
        digit = int(num[i])
        if digit < change[digit]:
            if not mutatable: mutatable = True
            num[i] = str(change[digit])
        elif digit > change[digit] and mutatable:
            break
    return """".join(num)
```

",,
"```python
from itertools import permutations

def maxCompatibilitySum(students, mentors):
    ans = 0
    for mentors_perm in permutations(mentors):
        cur_sum = sum(sum(a == b for a, b in zip(student, mentor)) for student, mentor in zip(students, mentors_perm))
        ans = max(ans, cur_sum)
    return ans
```

",,
"```python
from collections import defaultdict

def deleteDuplicateFolder(paths):
    graph = defaultdict(set)
    count = defaultdict(int)

    for path in paths:
        serialized_path = """"
        for folder in path:
            serialized_path += ""/"" + folder
            graph[serialized_path].add(folder)

    for value in graph.values():
        count[str(value)] += 1

    ans = []
    for path in paths:
        serialized_path = """"
        duplicate = False
        for folder in path:
            serialized_path += ""/"" + folder
            if count[str(graph[serialized_path])] > 1:
                duplicate = True
                break
        if not duplicate:
            ans.append(path)

    return ans
```

",,
"```python
def check_good_line(board, r, c, color, dr, dc):
    opp_color = 'B' if color == 'W' else 'W'
    count = 0
    r += dr
    c += dc
    while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opp_color:
        count += 1
        r += dr
        c += dc
    return 0 <= r < 8 and 0 <= c < 8 and board[r][c] == color and count >= 2

def is_legal_move(board, r_move, c_move, color):
    if board[r_move][c_move] != '.':
        return False
    board[r_move][c_move] = color
    for dr in range(-1, 2):
        for dc in range(-1, 2):
            if not (dr == 0 and dc == 0) and check_good_line(board, r_move, c_move, color, dr, dc):
                return True
    return False
```

",,
"```python
def minWastedSpace(nums, k):
    n = len(nums)
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(1, n + 1):
        total = 0
        for j in range(i, 0, -1):
            total += nums[j - 1]
            for l in range(k):
                dp[i][l + 1] = min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total)

    return min(dp[n])
```


",,
"```python
def has_three_divisors(n):
    count = 0
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            if n // i == i:
                count += 1
            else:
                count += 2
        if count > 3:
            break
    return count == 3
```

",,
"```python
def rearrangeArray(nums):
    nums.sort()
    for i in range(1, len(nums) - 1, 2):
        nums[i], nums[i + 1] = nums[i + 1], nums[i]
    return nums
```

",,
"```python
def num_special_subsequences(nums):
    zeros, ones, twos = 0, 0, 0
    mod = 1000000007
    for num in nums:
        if num == 0:
            zeros = (zeros + 1) % mod
        elif num == 1:
            ones = (ones + zeros) % mod
        else:
            twos = (twos + ones) % mod
    return twos
```


",,
"```python
def minTotalCost(startPos, homePos, rowCosts, colCosts):
    row_difference = abs(startPos[0] - homePos[0])
    col_difference = abs(startPos[1] - homePos[1])

    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])
    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])

    return row_cost + col_cost
```

",,
"```python
def min_time_to_type(word: str) -> int:
    time, prev = 0, 0
    for c in word:
        pos = ord(c) - ord('a')
        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1
        prev = pos
    return time
```


",,
"```python
def maxMatrixSum(matrix):
    n = len(matrix)
    minValue, negativeCount, total = float('inf'), 0, 0

    for i in range(n):
        for j in range(n):
            total += abs(matrix[i][j])
            minValue = min(minValue, abs(matrix[i][j]))
            if matrix[i][j] < 0:
                negativeCount += 1

    if negativeCount % 2 == 0:
        return total
    else:
        return total - 2 * minValue
```

",,
"```python
from heapq import heappush, heappop

MODULO = 1000000007

def countPaths(n, roads):
    adj_list = [[] for _ in range(n)]

    for u, v, time in roads:
        adj_list[u].append((v, time))
        adj_list[v].append((u, time))

    dist = [float('inf')] * n
    dist[0] = 0
    count = [0] * n
    count[0] = 1
    pq = [(0, 0)]

    while pq:
        distance, node = heappop(pq)

        if distance > dist[node]:
            continue

        for next_node, edge_distance in adj_list[node]:
            if distance + edge_distance > dist[next_node]:
                continue

            if distance + edge_distance == dist[next_node]:
                count[next_node] = (count[next_node] + count[node]) % MODULO
            else:
                count[next_node] = count[node]
                dist[next_node] = distance + edge_distance
                heappush(pq, (dist[next_node], next_node))

    return count[n - 1]
```

",,
"```python
def numberOfLists(num: str) -> int:
    mod = 10 ** 9 + 7
    n = len(num)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(n):
        for j in range(1, n + 1):
            if num[i] == '0': continue
            for k in range(1, min(n - i + 1, 11)):
                if k > 1 and num[i + k - 1] == '0': break
                dp[i + k][j] = (dp[i + k][j] + dp[i][j - 1]) % mod

    return sum(dp[n]) % mod
```

",,
"```python
def find_secret_sharers(n, meetings, first_person):
    secret_holders = [-1] * n
    secret_holders[0] = 0
    secret_holders[first_person] = 0

    meetings.sort(key=lambda x: x[2])

    for x, y, time in meetings:
        if secret_holders[x] != -1 and secret_holders[x] <= time:
            secret_holders[y] = time
        if secret_holders[y] != -1 and secret_holders[y] <= time:
            secret_holders[x] = time

    return [i for i in range(n) if secret_holders[i] != -1]
```


",,
"```python
def is_prefix_string(s, words):
    temp = """"
    for word in words:
        temp += word
        if temp == s:
            return True
        if len(temp) > len(s):
            break
    return False
```

",,
"```python
def min_stones_remaining(piles, k):
    for _ in range(k):
        max_pile_index = piles.index(max(piles))
        piles[max_pile_index] -= piles[max_pile_index] // 2

    return sum(piles)
```


",,
"```python
def min_swaps_to_balance(s: str) -> int:
    open_brackets = 0
    swaps = 0

    for c in s:
        if c == '[':
            open_brackets += 1
        else:
            if open_brackets == 0:
                swaps += 1
                open_brackets += 1
            else:
                open_brackets -= 1

    return swaps
```

",,
"```python
from bisect import bisect_right

def longest_obstacle_course(obstacles):
    ans, active = [0] * len(obstacles), []
    for i, obstacle in enumerate(obstacles):
        idx = bisect_right(active, obstacle)
        ans[i] = idx + 1
        if idx == len(active):
            active.append(obstacle)
        else:
            active[idx] = obstacle
    return ans
```

",,
"```python
def valid_arrangement(pairs):
    graph = {}
    for start, end in pairs:
        if start not in graph:
            graph[start] = []
        graph[start].append(end)

    result = []
    current = pairs[0][0]

    while graph:
        pair = [current, graph[current].pop()]
        if not graph[current]:
            del graph[current]
        result.append(pair)
        current = pair[1]

    return result
```


",,
"```python
def largest_even_sum(nums, k):
    evens = sorted([num for num in nums if num % 2 == 0], reverse=True)
    odds = sorted([num for num in nums if num % 2 != 0], reverse=True)

    sum = 0
    for _ in range(k):
        if evens:
            sum += evens.pop()

    for _ in range(0, k - 1, 2):
        if odds:
            first = odds.pop()
            if odds:
                second = odds.pop()
                sum += first + second

    return sum if sum % 2 == 0 else -1
```


",,
"```python
def count_patterns_in_word(patterns, word):
    count = 0
    for pattern in patterns:
        if pattern in word:
            count += 1
    return count
```

",,
"```python
def minNonZeroProduct(p):
    MOD = 10**9 + 7
    prod = 1
    a = (1 << p) - 2
    b = ((1 << p) - 1) % MOD
       
    while a > 0:
        if a % 2:
            prod = (prod * b) % MOD
        b = (b * b) % MOD
        a //= 2
    return prod
```


",,
"```python
def can_reach_bottom(grid, row, col):
    if row == len(grid) - 1:
        return True
    grid[row][col] = 1

    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]

    for dr, dc in directions:
        nr, nc = row + dr, col + dc
        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:
            if can_reach_bottom(grid, nr, nc):
                return True

    return False

def latestDayToCross(row, col, cells):
    grid = [[0] * col for _ in range(row)]
    ans = 0

    for day, cell in enumerate(cells):
        grid[cell[0] - 1][cell[1] - 1] = 1

        found = False
        for j in range(col):
            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):
                found = True
                break

        if not found:
            ans = day
            break

    return ans
```


",,
"```python
def findMiddleIndex(nums):
    total_sum = sum(nums)
    
    left_sum = 0
    for i, num in enumerate(nums):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    
    return -1
```

",,
"```python
def findFarmland(land):
    m, n = len(land), len(land[0])
    res = []
    
    for i in range(m):
        for j in range(n):
            if land[i][j] == 1:
                r, c = i, j
                while r < m and land[r][j] == 1: r += 1
                while c < n and land[i][c] == 1: c += 1
                for x in range(i, r):
                    for y in range(j,c):
                        land[x][y] = 0
                res.append([i, j, r - 1, c - 1])

    return res
```


",,
"```python
from collections import defaultdict

class LockingTree:

    def __init__(self, parent):
        self.parent = parent
        self.children = defaultdict(set)
        self.locks = [-1] * len(parent)
        for i in range(1, len(parent)):
            self.children[parent[i]].add(i)
    
    def lock(self, num, user):
        if self.locks[num] == -1:
            self.locks[num] = user
            return True
        return False
    
    def unlock(self, num, user):
        if self.locks[num] == user:
            self.locks[num] = -1
            return True
        return False
    
    def upgrade(self, num, user):
        if self.locks[num] != -1: return False
        
        cur = num
        while cur != -1:
            if self.locks[cur] != -1: return False
            cur = self.parent[cur]
        
        locked_descendant = self._has_locked_descendants(num)
        if locked_descendant:
            self.locks[num] = user
        return locked_descendant
    
    def _has_locked_descendants(self, node):
        locked_descendant = False
        for child in self.children[node]:
            if self.locks[child] != -1:
                locked_descendant = True
                self.locks[child] = -1
            locked_descendant |= self._has_locked_descendants(child)
        return locked_descendant
```


",,
"```python
def numberOfGoodSubsets(nums: list[int]) -> int:
    MOD = 10**9 + 7

    def is_prime(n: int) -> bool:
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = [i for i in range(2, 91) if is_prime(i)]
    cnt = [0] * 100
    for n in nums:
        cnt[n] += 1

    dp = [0] * (1 << 20)
    dp[0] = 1
    
    for i in range(30, 0, -1):
        if cnt[i] == 0:
            continue
        mask = [j for j in primes if i % j == 0]
        i = i // j
        if i > 1:
            continue

        m = 0
        for j in mask:
            m |= 1 << (j - 2)

        for j in range(len(dp)-1, -1, -1):
            if dp[j] == 0:
                continue
            cur = 1
            for k in range(cnt[m]):
                cur = (cur * 2) % MOD
                dp[j | m] = (dp[j | m] + dp[j] * cur) % MOD

    ans = sum(dp) % MOD
    ans = (ans - dp[0] + MOD) % MOD
    return (ans * (1 << (cnt[1] - 1))) % MOD
```

",,
"```python
from math import gcd

def findGCD(nums):
    return gcd(min(nums), max(nums))
```

",,
"```python
def find_different_binary_string(nums):
    return """".join(""1"" if nums[i][i] == ""0"" else ""0"" for i in range(len(nums)))
```

",,
"```python
def minimizeTheDifference(mat, target):
    m, n = len(mat), len(mat[0])
    dp, new_dp = [1] + [0] * 4900, [0] * 4901
    for i in range(m):
        for j in range(n):
            for k in range(4900 - mat[i][j] + 1):
                new_dp[k + mat[i][j]] |= dp[k]
        dp, new_dp = new_dp, [0] * 4901
    for i in range(4901):
        if dp[i]:
            return abs(target - i)
    return float('inf')
```

",,
"```python
from collections import Counter
def recoverArray(n, sums):
    counter = Counter(sums)
    ans = []
    for _ in range(n):
        num, _ = counter.most_common(1)[0]
        counter -= Counter([num] + [prevNum - num for prevNum in ans])
        ans.append(num)
    return ans
```


",,
"```python
def num_smooth_descent_periods(prices):
    result = 0
    count = 0
    for i in range(1, len(prices)):
        if prices[i] == prices[i - 1] - 1:
            count += 1
        else:
            count = 0
        result += count + 1
    return result + 1
```

",,
"```python
def minOperations(arr, k):
    dp = [0] * len(arr)
    for i in range(k, len(arr)):
        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0)
    return sum(dp)
```


",,
"```python
def kthLargestNumber(nums, k):
    nums.sort(key=lambda x: (len(x), x))
    return nums[-k]
```

",,
"```python
def min_sessions(tasks, session_time):
    sessions = []
    tasks.sort(reverse=True)

    for task in tasks:
        added = False
        for session_idx, session in enumerate(sessions):
            if session + task <= session_time:
                sessions[session_idx] += task
                added = True
                break

        if not added:
            sessions.append(task)

    return len(sessions)
```

",,
"```python
def numDistinct(binary):
    mod = 10**9 + 7
    zero_count, ones_count = 0, 0

    for c in binary:
        if c == '0':
            zero_count = (zero_count + ones_count) % mod
        else:
            ones_count = (ones_count * 2 + 1) % mod
    
    return zero_count
```

",,
"```python
def count_pairs_with_difference_k(nums, k):
    freq_map = {}
    count = 0

    for num in nums:
        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)
        freq_map[num] = freq_map.get(num, 0) + 1

    return count
```


",,
"```python
def findOriginalArray(changed):
    count = {}
    for num in changed:
        count[num] = count.get(num, 0) + 1

    sorted_values = sorted(count.keys())

    original = []
    for num in sorted_values:
        while count[num] > 0 and count.get(num * 2, 0) > 0:
            original.append(num)
            count[num] -= 1
            count[num * 2] -= 1
        if count[num] > 0:
            return []

    return original
```


",,
"```python
def minOperations(nums):
    nums = sorted(set(nums))
    n = len(nums)
    ans = n
    for i in range(n):
        j = 0
        while j < n and nums[j] <= nums[i] + n - 1:
            j += 1
        ans = min(ans, n - (j - i))
    return ans
```

",,
"```python
def findNoOfInstructions(n: int, startPos: List[int], s: str) -> List[int]:
    answer = [0] * len(s)
    x, y = startPos

    for i in range(len(s)):
        cnt = 0
        cx, cy = x, y
        for j in range(i, len(s)):
            step = s[j]
            if step == 'L':
                if cy == 0: break
                cy -= 1
            elif step == 'R':
                if cy == n - 1: break
                cy += 1
            elif step == 'U':
                if cx == 0: break
                cx -= 1
            else:
                if cx == n - 1: break
                cx += 1
            cnt += 1
            if j == len(s) - 1: break
        answer[i] = cnt

    return answer
```


",,
"```python
from collections import defaultdict, deque

def has_path(n, edges, source, destination):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    q = deque([source])
    visited = [False] * n
    while q:
        current = q.popleft()
        visited[current] = True
        if current == destination:
            return True
        for neighbor in graph[current]:
            if not visited[neighbor]:
                q.append(neighbor)
    return False
```


",,
"```python
def numberOfWeakCharacters(properties):
    properties.sort(key=lambda x: (x[0], -x[1]))
    
    max_defense = 0
    weak_count = 0
    for attack, defense in reversed(properties):
        if defense < max_defense:
            weak_count += 1
        else:
            max_defense = defense
            
    return weak_count
```

",,
"```python
def firstDayBeenInAllRooms(nextVisit):
    n = len(nextVisit)
    ans = 0
    MOD = 10**9 + 7
    dp = [0] * n

    for i in range(1, n):
        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD
        ans = (ans + dp[i]) % MOD
    return ans
```

",,
"```python
def can_sort_using_swap(nums):
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            nums[i], nums[i - 1] = nums[i - 1], nums[i]
            if sorted(nums) == nums:
                return True
            nums[i], nums[i - 1] = nums[i - 1], nums[i]
    return False
```

",,
"```python
def can_destroy_all(mass: int, asteroids: List[int]) -> bool:
    asteroids.sort()
    for asteroid in asteroids:
        if mass >= asteroid:
            mass += asteroid
        else:
            return False
    return True
```

",,
"```python
def max_invited(favorite):
    in_degree = [0] * len(favorite)
    for fav in favorite:
        in_degree[fav] += 1
    result = 0
    for degree in in_degree:
        result += max(degree - 1, 0)
    return min(result + 2, len(favorite))
```

",,
"```python
def reverse_prefix(word: str, ch: str) -> str:
    try:
        index = word.index(ch)
        return word[:index+1][::-1] + word[index+1:]
    except ValueError:
        return word
```

",,
"```python
def interchangeable_rectangles(rectangles):
    ratio_count = {}
    count = 0

    for r in rectangles:
        ratio = r[0] / r[1]
        count += ratio_count.get(ratio, 0)
        ratio_count[ratio] = ratio_count.get(ratio, 0) + 1

    return count
```


",,
"```python
def maxProduct(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = 1
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    max_product = 0
    for i in range(1, n):
        max_product = max(max_product, dp[0][i - 1] * dp[i][n - 1])

    return max_product
```

",,
"```python
def smallest_missing_value_subtree(parents, nums):
    def dfs(node, parents, nums, tree, ans):
        tree[node].add(nums[node])
        for i in range(1, len(parents)):
            if parents[i] == node:
                dfs(i, parents, nums, tree, ans)
                tree[node].update(tree[i])
        missing = 1
        while missing in tree[node]:
            missing += 1
        ans[node] = missing

    n = len(parents)
    ans = [0] * n
    tree = [set() for _ in range(n)]
    
    dfs(0, parents, nums, tree, ans)
    return ans
```


",,
"```python
def construct2DArray(original, m, n):
    if m * n != len(original): return []
    res = [[0] * n for _ in range(m)]
    for i in range(len(original)):
        res[i // n][i % n] = original[i]
    return res
```

",,
"```python
def count_pairs(nums, target):
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target or nums[j] + nums[i] == target:
                count += 1
    return count
```

",,
"```python
def max_consecutive_answers(answer_key: str, k: int) -> int:
    n = len(answer_key)
    start, max_len, max_count = 0, 0, 0
    count = {'T': 0, 'F': 0}

    for end in range(n):
        max_count = max(max_count, count.__setitem__(answer_key[end], count[answer_key[end]] + 1))

        if end - start + 1 - max_count > k:
            count[answer_key[start]] -= 1
            start += 1

        max_len = max(max_len, end - start + 1)

    return max_len
```

",,
"```python
def numOfWays(nums, k):
    left = 0
    right = 0
    for num in nums:
        if num < k:
            left += 1
        if num <= k:
            right += 1

    if left == len(nums):
        return 0
    if right - left != len(nums) - right:
        return left + 1
    return left
```

",,
"```python
def earliestBlooms(plantTime, growTime):
    n = len(plantTime)
    processTime = list(zip(plantTime, growTime))
    processTime.sort()

    day = 0
    blooms = 0
    for p in processTime:
        day += p[0]
        blooms = max(blooms, day + p[1])
    return blooms
```

",,
"```python
def perform_operations(operations):
    X = 0
    for op in operations:
        if op == ""++X"" or op == ""X++"":
            X += 1
        elif op == ""--X"" or op == ""X--"":
            X -= 1
    return X
```

",,
"```python
def sum_of_beauties(nums: List[int]) -> int:
    n = len(nums)
    result = 0

    left_max = [0] * n
    left_max[0] = nums[0]
    right_min = [0] * n
    right_min[n - 1] = nums[n - 1]

    for i in range(1, n):
        left_max[i] = max(left_max[i - 1], nums[i])

    for i in range(n - 2, -1, -1):
        right_min[i] = min(right_min[i + 1], nums[i])

    for i in range(1, n - 1):
        if nums[i] > left_max[i - 1] and nums[i] < right_min[i + 1]:
            result += 1

    return result
```

",,
"```python
class DetectSquares:

    def __init__(self):
        self.points = collections.defaultdict(lambda: collections.defaultdict(int))

    def add(self, point):
        self.points[point[0]][point[1]] += 1

    def count(self, point):
        ans = 0
        for x2 in self.points[point[0]]:
            if x2 == point[1]:
                continue
            for y2 in self.points[x2]:
                if y2 == point[1] or abs(x2 - point[1]) != abs(y2 - point[0]):
                    continue
                ans += self.points[point[0]][x2] * self.points[x2][y2] * self.points[point[0]][y2]
        return ans
```


",,
"```python
def longest_subsequence_repeated_k(s, k):
    counts = [0] * 26
    for c in s:
        counts[ord(c) - ord('a')] += 1
    seq = ''.join([chr(i + ord('a')) * (counts[i] // k) for i in range(25, -1, -1)])
    return seq
```

",,
"```python
def max_computer_runtime(n, batteries):
    batteries.sort()
    result = 0
    for i in range(len(batteries)):
        result = max(result, min(n, len(batteries) - i) * batteries[i])
    return result
```


",,
"```python
def numberOfBalancedRanges(nums1, nums2):
    MOD = 10**9 + 7
    dp = [[[0] * (101) for _ in range(101)] for _ in range(101)]

    dp[0][0] = 2
    sums1, sums2 = [0] * (len(nums1) + 1), [0] * (len(nums1) + 1)
    for i, (a, b) in enumerate(zip(nums1, nums2)):
        sums1[i + 1], sums2[i + 1] = sums1[i] + a, sums2[i] + b

    ans = 0
    for r in range(len(nums1)):
        for l in range(r, -1, -1):
            for k in range(l, r + 1):
                leftSum1 = sums1[l]
                rightSum1 = sums1[len(nums1)] - sums1[k + 1]
                leftSum2 = sums2[l]
                rightSum2 = sums2[len(nums1)] - sums2[r + 1]

                if leftSum1 + rightSum2 == leftSum2 and leftSum1 + rightSum1 == rightSum2:
                    for last in range(3):
                        ans += dp[l][r][k][last]
                        ans %= MOD
                        next = k + 1 if last == 2 else k
                        dp[next][k if k else r + 1][k - 1 if k else r +
                                                   2][last] += dp[l][r][k][last]
                        dp[l][r][k][last] = (dp[l][r][k][last] +
                                             ((!last) or last == 2)) % MOD
    return ans
```

",,
"```python
def max_difference(nums):
    min_val = nums[0]
    max_diff = -1

    for i in range(1, len(nums)):
        if nums[i] > min_val:
            max_diff = max(max_diff, nums[i] - min_val)
        else:
            min_val = nums[i]

    return max_diff
```

",,
"```python
def min_second_robot_points(grid: List[List[int]]) -> int:
    n = len(grid[0])
    for r in range(2):
        for c in range(1, n):
            grid[r][c] += grid[r][c - 1]
    dp = [grid[0][n - 1], 0]
    for c in range(n - 2, -1, -1):
        dp_new = [max(dp[0] - grid[0][c], dp[1] + grid[1][c]), max(dp[1] - grid[1][c], dp[0] + grid[0][c])]
        dp = dp_new
    return max(dp)
```

",,
"```python
def can_place_word(board, word):
    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if board[i][j] == word[0]:
                if check_word(board, word, i, j, 0, 1) or check_word(board, word, i, j, 1, 0):
                    return True
    return False

def check_word(board, word, i, j, di, dj):
    m, n = len(board), len(board[0])
    for k in range(len(word)):
        i += di
        j += dj
        if i < 0 or i >= m or j < 0 or j >= n:
            return False
        if k == 0 or k == len(word) - 1:
            if board[i][j] != word[k] and board[i][j] != ' ':
                return False
        if k > 0 and k < len(word) - 1:
            if board[i][j] != word[k] and board[i][j] != ' ' and board[i][j] != '#':
                return False
    return True
```

",,
"```python
def sum_of_points(s, answers):
    total_points = 0
    result = 0
    term = 1
    sign = ""+""

    for char in s:
        if char.isdigit():
            number = int(char)
            if sign == ""+"":
                result += term
                term = number
            elif sign == ""*"":
                term *= number
        else:
            sign = char

    result += term

    for ans in answers:
        total_points += (ans == result)

    return total_points
```


",,
"```python
def min_moves(seats, students):
    seats.sort()
    students.sort()

    moves = 0
    for i in range(len(seats)):
        moves += abs(seats[i] - students[i])
    return moves
```

",,
"```python
def solve_puzzle(colors: str) -> bool:
    return colors.count('A') % 2 == 1
```

",,
"
```javascript
function lonelyNumbers(nums) {
    const count = {};
    const result = [];

    for (const num of nums) {
        if (count[num] === undefined) {
            count[num] = 1;
        } else {
            count[num]++;
        }
    }

    for (const key in count) {
        const k = parseInt(key);
        if (count[k] === 1 && count[k - 1] === undefined && count[k + 1] === undefined) {
            result.push(k);
        }
    }

    return result;
}
```

",,
"```python
from collections import defaultdict, deque

def network_becomes_idle(edges, patience):
    n = len(patience)
    graph = defaultdict(list)
    
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])

    dist = [-1] * n
    dist[0] = 0
    q = deque([0])
    
    while q:
        node = q.popleft()
        
        for neighbor in graph[node]:
            if dist[neighbor] == -1:
                dist[neighbor] = dist[node] + 1
                q.append(neighbor)

    max_time = 0
    for i in range(1, n):
        time = ((2 * dist[i] - 1) // patience[i]) * patience[i] + 2 * dist[i]
        max_time = max(max_time, time)
    
    return max_time + 1
```

",,
"```python
from math import gcd
from itertools import combinations

def minStraightLines(points):
    lines = set()
    for p1, p2 in combinations(points, 2):
        dy, dx = p2[1] - p1[1], p2[0] - p1[0]
        g = gcd(dx, dy)
        lines.add((dy // g, dx // g))
    return len(lines)
```


",,
"```python
def min_moves_to_convert(s):
    count = 0
    i = 0
    while i < len(s) - 2:
        if s[i] == ""X"" and s[i + 1] == ""X"" and s[i + 2] == ""X"":
            count += 1
            i += 3
        else:
            i += 1
    return count
```

",,
"```python
from typing import List

def missing_rolls(rolls: List[int], mean: int, n: int) -> List[int]:
    m = len(rolls)
    total_sum = mean * (n + m)
    sum_m = sum(rolls)
    
    if total_sum - sum_m < n or total_sum - sum_m > 6 * n:
        return []
    
    ans = [1] * n
    total_sum -= sum_m + n
    for i in range(n):
        add = min(5, total_sum)
        ans[i] += add
        total_sum -= add
    
    return ans
```


",,
"```python
def alice_wins(stones):
    sum_, count = 0, [0] * 3
    for stone in stones:
        sum_ += stone
        count[stone % 3] += 1
    if sum_ % 3:
        return count[sum_ % 3] % 2 == 1
    return count[1] % 2 == 0 or count[2] % 2 == 0 or count[1] == 0 or count[2] == 0
```

",,
"```python
from heapq import heappop, heappush

def smallest_subsequence(s, k, letter, repetition):
    result = []
    letter_count = s.count(letter)

    pq = []
    for c in s:
        if c <= letter or letter_count > repetition:
            while pq and pq[0] > c:
                if heappop(pq) == letter:
                    letter_count -= 1
            heappush(pq, c)
            if len(pq) > k:
                heappop(pq)
        if k - len(pq) == repetition:
            letter_count -= 1
        repetition = max(0, repetition)

    return """".join(pq)
```

",,
"```python
def painting_plan(paint):
    worklog = [0] * len(paint)
    painted = set()

    for i in range(len(paint)):
        start, end = paint[i]

        for j in range(start, end):
            if j not in painted:
                painted.add(j)
                worklog[i] += 1

    return worklog
```

",,
"```python
def min_operations(grid, x):
    min_element = min(min(row) for row in grid)
    min_ops = float('inf')

    base = min_element
    while True:
        operations = 0
        impossible = False
        for row in grid:
            if impossible:
                break
            for cell in row:
                diff = abs(cell - base)
                if diff % x != 0:
                    impossible = True
                    break
                operations += diff // x
        if impossible:
            break
        min_ops = min(min_ops, operations)
        base -= 1

    return -1 if min_ops == float('inf') else min_ops
```

",,
"```python
def min_partition_difference(nums):
    n = len(nums) // 2
    nums.sort(reverse=True)
    return sum(nums[:n]) - sum(nums[n:])
```

",,
"```python
def kth_distinct_string(arr, k):
    frequency = {}
    for s in arr:
        frequency[s] = frequency.get(s, 0) + 1

    count = 0
    for s in arr:
        if frequency[s] == 1:
            count += 1
            if count == k:
                return s

    return """"
```

",,
"```python
def maxValue(events):
    events.sort(key=lambda a: a[1])

    dp = [0] * len(events)
    dp[0] = events[0][2]

    for i in range(1, len(events)):
        lastNonConflict = -1
        for j in range(i - 1, -1, -1):
            if events[j][1] < events[i][0]:
                lastNonConflict = j
                break
                
        includedValue = events[i][2]
        if lastNonConflict != -1:
            includedValue += dp[lastNonConflict]

        dp[i] = max(includedValue, dp[i - 1])

    return dp[-1]
```

",,
"```python
from typing import List, Tuple

def plates_between_candles(s: str, queries: List[Tuple[int, int]]) -> List[int]:
    n = len(s)
    prefix = [0] * n
    plates = 0
    
    for i in range(1, n):
        prefix[i] = prefix[i - 1]
        if s[i] == '*' and s[i - 1] == '|':
            plates += 1
        prefix[i] += plates
    
    res = []
    for left, right in queries:
        res.append(prefix[right] - (prefix[left - 1] if left > 0 else 0))
    
    return res
```

",,
"```python
def valid_move_combinations(pieces, positions):
    n = len(pieces)
    count = 0

    for i in range(n):
        for j in range(n):
            if i != j and not (pieces[i] == ""bishop"" and (positions[i][0] + positions[i][1]) % 2 != (positions[j][0] + positions[j][1]) % 2):
                count += 1

    return count
```

",,
"```python
def min_time_to_remove_illegal_goods(s: str) -> int:
    ones = twos = 0
    for c in s:
        if c == '1':
            twos += ones
            ones += 1
    return ones + min(ones, twos)
```

",,
"```python
def are_numbers_increasing(s: str) -> bool:
    tokens = s.split()
    numbers = []
    
    for token in tokens:
        if token.isdigit():
            num = int(token)
            if numbers and numbers[-1] >= num:
                return False
            numbers.append(num)
    
    return True
```

",,
"```python
def count_max_or_subsets(nums):
    max_OR = 0
    for num in nums:
        max_OR |= num

    OR_subsets = {0}
    for num in nums:
        tmp = OR_subsets.copy()
        for x in OR_subsets:
            tmp.add(x | num)
        OR_subsets = tmp

    return OR_subsets.count(max_OR)
```


",,
"```python
import heapq

def second_minimum(n: int, edges: List[List[int]], time: int, change: int) -> int:
    adj = [[] for _ in range(n + 1)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)

    dist = [-1] * (n + 1)
    queue = [(0, 1)]
    dist[1] = 0

    while queue:
        t1, v1 = heapq.heappop(queue)

        if v1 == n:
            return t1

        for v2 in adj[v1]:
            t2 = t1 + time
            waiting = change - (t2 % change) if (t2 // change) % 2 == 1 else 0

            if dist[v2] == -1 or dist[v2] > t2 + waiting:
                if dist[v2] != -1:
                    heapq.heappush(queue, (dist[v2], v2))
                dist[v2] = t2 + waiting
                heapq.heappush(queue, (dist[v2], v2))

    return -1
```

",,
"```python
def max_and_sum(nums, num_slots, idx, used, sum):
    if idx == len(nums):
        return sum
    max_sum = 0
    for i in range(1, num_slots + 1):
        if not used & (1 << (i - 1)):
            new_sum = sum + (nums[idx] & i)
            new_used = used | (1 << (i - 1))
            max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 1, new_used, new_sum))
            if idx + 1 < len(nums):
                new_sum = new_sum + (nums[idx + 1] & i)
                max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 2, new_used, new_sum))
    return max_sum

def max_and_sum(nums, num_slots):
    return max_and_sum(nums, num_slots, 0, 0, 0)
```


",,
"```python
def next_balanced(n):
    while True:
        n += 1
        digit_count = {}
        temp = n
        while temp:
            digit = temp % 10
            digit_count[digit] = digit_count.get(digit, 0) + 1
            temp //= 10
        balanced = all(k == v for k, v in digit_count.items())
        if balanced:
            return n
```

",,
"```python
def min_months(n, relations, time):
    order = [0] * n
    for r in relations:
        order[r[1] - 1] = max(order[r[1] - 1], r[0])
    totalTime = 0
    for i in range(n):
        totalTime = max(totalTime, time[i] + order[i])
    return totalTime
```

",,
"```python
def almost_equivalent(word1, word2):
    freq1 = {}
    freq2 = {}

    for c in word1:
        freq1[c] = freq1.get(c, 0) + 1
    for c in word2:
        freq2[c] = freq2.get(c, 0) + 1

    for c in ""abcdefghijklmnopqrstuvwxyz"":
        if abs(freq1.get(c, 0) - freq2.get(c, 0)) > 3:
            return False

    return True
```


",,
"```python
class Robot:
    def __init__(self):
        self.x, self.y, self.dir = 0, 0, 1

    def move(self, steps):
        if self.dir == 0:
            self.y += steps
        elif self.dir == 1:
            self.x += steps
        elif self.dir == 2:
            self.y -= steps
        else:
            self.x -= steps

    def turn_left(self):
        self.dir = (self.dir + 3) % 4

    def turn_right(self):
        self.dir = (self.dir + 1) % 4
```

",,
"```python
def max_beauty(items, queries):
    sorted_items = [0] * 10001
    for price, beauty in items:
        sorted_items[price] = max(sorted_items[price], beauty)

    for i in range(1, len(sorted_items)):
        sorted_items[i] = max(sorted_items[i], sorted_items[i - 1])

    return [sorted_items[query] for query in queries]
```


",,
"```python
def max_tasks(tasks, workers, pills, strength):
    tasks.sort()
    workers.sort()
    task_index = 0
    pill_index = pills
    completed_tasks = 0

    for worker_strength in workers:
        while pill_index > 0 and worker_strength + strength >= tasks[task_index]:
            worker_strength += strength
            pill_index -= 1
        
        if worker_strength >= tasks[task_index]:
            task_index += 1
            completed_tasks += 1

        if task_index >= len(tasks):
            break

    return completed_tasks
```


",,
"```python
def smallest_index(nums):
    for i in range(len(nums)):
        if i % 10 == nums[i]:
            return i
    return -1
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def critical_distance(head):
    min_distance, max_distance = float('inf'), float('-inf')
    last_cp, index = -1, 0
    current = head.next

    while current and current.next:
        if (current.val > current.next.val and current.val > current.prev.val) or \
           (current.val < current.next.val and current.val < current.prev.val):

            if last_cp != -1:
                min_distance = min(min_distance, index - last_cp)
                max_distance = max(max_distance, index - last_cp)
            last_cp = index

        current = current.next
        index += 1

    if min_distance != float('inf'):
        return [min_distance, max_distance]
    return [-1, -1]
```

",,
"```python
from collections import deque

def minOperations(nums, start, goal):
    seen = {start}
    q = deque([start])
    level = 0

    while q:
        size = len(q)
        for i in range(size):
            x = q.popleft()
            if x == goal:
                return level
            for num in nums:
                next_x = x + num
                if 0 <= next_x <= 1000 and next_x not in seen:
                    seen.add(next_x)
                    q.append(next_x)
        level += 1

    return -1
```

",,
"```python
def are_encoded_strings_equal(s1: str, s2: str) -> bool:
    decoded1, decoded2 = """", """"

    for i, c in enumerate(s1):
        if c.isdigit():
            count = int(c)
            decoded1 += s1[i - 1] * count
        else:
            decoded1 += c

    for i, c in enumerate(s2):
        if c.isdigit():
            count = int(c)
            decoded2 += s2[i - 1] * count
        else:
            decoded2 += c

    return decoded1 == decoded2
```


",,
"```python
def count_prefixes(words, pref):
    return sum(1 for word in words if word.startswith(pref))
```

",,
"```python
def count_vowel_substrings(word: str) -> int:
    count = 0
    n = len(word)
    vowels = set()

    for i in range(n):
        if word[i] in ""aeiou"":
            vowels.clear()
            for j in range(i, n):
                if word[j] in ""aeiou"":
                    vowels.add(word[j])
                if len(vowels) == 5:
                    count += 1
    return count
```


",,
"```python
def sum_of_vowels_in_the_substrings(word: str) -> int:
    total_sum = 0
    n = len(word)

    for i, char in enumerate(word):
        if char in {'a', 'e', 'i', 'o', 'u'}:
            total_sum += (i + 1) * (n - i)

    return total_sum
```

",,
"```python
def min_x(n, quantities):
    total_products = sum(quantities)
    return (total_products + n - 1) // n
```

",,
"```python
from collections import defaultdict

def maxQualityRec(adjDict, values, node, timeLeft, visited):
    if timeLeft < 0:
        return float('-inf')

    maxQuality = 0
    visited.add(node)
    for neighbor, time in adjDict[node]:
        adjDict[neighbor].remove((node, time))
        maxQuality = max(maxQuality, maxQualityRec(adjDict, values, neighbor, timeLeft - time, visited))
        adjDict[neighbor].append((node, time))
    
    visited.remove(node)
    return maxQuality + (values[node] if node not in visited else 0)

def maxQuality(n, values, edges, maxTime):
    adjDict = defaultdict(list)
    for u, v, time in edges:
        adjDict[u].append((v, time))
        adjDict[v].append((u, time))

    visited = set()
    return maxQualityRec(adjDict, values, 0, maxTime, visited)
```


",,
"```python
def count_once_in_both(words1, words2):
    counter1 = {}
    counter2 = {}

    for word in words1:
        counter1[word] = counter1.get(word, 0) + 1
    for word in words2:
        counter2[word] = counter2.get(word, 0) + 1

    count = 0
    for item in counter1.items():
        if item[1] == 1 and counter2.get(item[0], 0) == 1:
            count += 1

    return count
```

",,
"```python
def min_buckets(street):
    buckets = 0
    i = 0
    n = len(street)
    while i < n:
        if street[i] == 'H':
            if i + 1 < n and street[i + 1] == '.':
                buckets += 1
                i += 2
            elif i + 2 < n and street[i + 2] == '.':
                buckets += 1
                i += 3
            else:
                return -1
        else:
            i += 1
    return buckets
```


",,
"```python
def min_cost(grid, start_pos, home_pos, row_costs, col_costs):
    return abs(row_costs[start_pos[0]] - row_costs[home_pos[0]]) + abs(col_costs[start_pos[1]] - col_costs[home_pos[1]])
```

",,
"```python
def count_pyramids(grid):
    m, n, count = len(grid), len(grid[0]), 0
    for i in range(1, m - 1):
        for j in range(1, n - 1):
            if grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] \
                and grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]:
                count += grid[i][j]
    return count
```

",,
"```python
def cell_range(s):
    r1 = int(s[1])
    r2 = int(s[4])
    c1 = ord(s[0]) - ord('A') + 1
    c2 = ord(s[3]) - ord('A') + 1

    res = []
    for c in range(c1, c2 + 1):
        for r in range(r1, r2 + 1):
            res.append(chr(ord('A') + c - 1) + str(r))
    return res
```

",,
"```python
def time_to_buy_tickets(tickets, k):
    time = 0
    while tickets[k] > 0:
        for i in range(len(tickets)):
            if tickets[i] > 0:
                tickets[i] -= 1
                time += 1
                if i == k and tickets[k] == 0:
                    return time
    return time
```

",,
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def reverse_even_groups(head: ListNode) -> ListNode:
    dummy = ListNode(-1)
    dummy.next = head
    prev, curr = dummy, head
    count = 0
    while curr:
        count += 1
        curr = curr.next
    curr = head
    i = 2
    while i <= count:
        next_group_head = curr
        for _ in range(i):
            if not next_group_head:
                break
            next_group_head = next_group_head.next
        prev_group_tail = prev
        for _ in range(i):
            if not curr:
                break
            next_node = curr.next
            curr.next = prev_group_tail.next
            prev_group_tail.next = curr
            curr = next_node
        for _ in range(i):
            prev = prev.next
        i += 2
    return dummy.next
```

",,
"```python
def decode_slanted_cipher(encoded_text, rows):
    matrix = ['' for _ in range(rows)]
    index = 0

    for diagonal in range(2 * (rows - 1)):
        for row in range(max(0, diagonal - rows + 1), min(diagonal, rows - 1) + 1):
            if index < len(encoded_text):
                matrix[row] += encoded_text[index]
                index += 1

    return ''.join(matrix)
```

",,
"```python
from collections import defaultdict

def check_friends(n, restrictions, requests):
    friends = defaultdict(set)
    for a, b in restrictions:
        friends[a].add(b)
        friends[b].add(a)

    result = []
    for a, b in requests:
        if b not in friends[a] and a not in friends[b]:
            friends[a].add(b)
            friends[b].add(a)
            result.append(True)
        else:
            result.append(False)
    return result
```

",,
"```python
def can_fit_stamps(grid, stampHeight, stampWidth):
    m, n = len(grid), len(grid[0])
    for i in range(m - stampHeight + 1):
        for j in range(n - stampWidth + 1):
            canFit = True
            for x in range(stampHeight):
                for y in range(stampWidth):
                    if grid[i + x][j + y] == 1:
                        canFit = False
                        break
                if not canFit:
                    break
            if canFit:
                return True
    return False
```

",,
"```python
def arrange_pairs(pairs):
    adj = {pair[0]: pair for pair in pairs}
    result = []
    start = pairs[0][0]

    while adj:
        pair = adj.pop(start)
        result.append(pair)
        start = pair[1]

    return result
```


",,
"```python
def to_base_k(num, k):
    base_k_num = ''
    while num:
        base_k_num = str(num % k) + base_k_num
        num //= k
    return base_k_num

def is_k_mirror(num, k):
    base_10_num = str(num)
    base_k_num = to_base_k(num, k)
    return base_10_num == base_10_num[::-1] and base_k_num == base_k_num[::-1]

def sum_k_mirror_numbers(k, n):
    total = 0
    num = 0
    while n:
        if is_k_mirror(num, k):
            total += num
            n -= 1
        num += 1
    return total
```


",,
"```python
from heapq import heappop, heappush
from sys import maxsize

def dijkstra(src, adj):
    dist = [maxsize] * len(adj)
    dist[src] = 0
    pq = [(0, src)]

    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            if d + w < dist[v]:
                dist[v] = d + w
                heappush(pq, (dist[v], v))

    return dist

def min_weight_subgraph(n, edges, src1, src2, dest):
    adj = [[] for _ in range(n)]
    for u, v, w in edges:
        adj[u].append((v, w))

    dist1 = dijkstra(src1, adj)
    dist2 = dijkstra(src2, adj)

    res = dist1[dest] + dist2[dest]
    for u, v, w in edges:
        res = min(res, dist1[u] + dist2[v] + w)
        res = min(res, dist1[v] + dist2[u] + w)

    return res if res != maxsize else -1
```

",,
"```python
import heapq

def largest_sum_sequence(nums, k):
    min_heap = []
    
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    
    result = [0] * k
    for i in range(k-1, -1, -1):
        result[i] = heapq.heappop(min_heap)
    
    return result
```

",,
"```python
from typing import List

def max_bombs_detonated(bombs: List[List[int]]) -> int:
    n = len(bombs)
    max_bombs = 0

    for i in range(n):
        count = 0
        for j in range(n):
            dx = bombs[i][0] - bombs[j][0]
            dy = bombs[i][1] - bombs[j][1]
            distance = dx * dx + dy * dy
            range_ = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2]
            if distance <= range_:
                count += 1
        max_bombs = max(max_bombs, count)

    return max_bombs
```


",,
"```python
import heapq

def min_operations(nums):
    max_heap = [-num for num in nums]
    heapq.heapify(max_heap)
    initial_sum = sum(nums)
    target_sum = initial_sum // 2
    sum_so_far = 0
    operations = 0

    while sum_so_far <= target_sum:
        largest = -heapq.heappop(max_heap)
        sum_so_far += largest // 2
        operations += 1

    return operations
```


",,
"```python
def minVisibleWhiteTiles(floor: str, numCarpets: int, carpetLen: int) -> int:
    n, res = len(floor), len(floor)
    for i in range(n - carpetLen + 1):
        count = sum(1 for j in range(carpetLen) if floor[i + j] == '1')
        for k in range(1, numCarpets + 1):
            if k * carpetLen - 1 <= i + carpetLen:
                res = min(res, n - count * k)
                if i + carpetLen < n:
                    count -= floor[i + carpetLen - k * carpetLen] == '1'
                    count += floor[i + carpetLen] == '1'
    return res
```


",,
"```python
def sorted_target_indices(nums, target):
    result = [i for i, num in enumerate(nums) if num == target]
    return sorted(result)
```

",,
"```python
def k_radius_average(nums, k):
    n = len(nums)
    avgs = [-1] * n
    for i in range(k, n - k):
        sum = 0
        for j in range(i - k, i + k + 1):
            sum += nums[j]
        avgs[i] = sum // (2 * k + 1)
    return avgs
```

",,
"```python
def min_deletions(nums):
    n = len(nums)
    if n <= 2:
        return 0
        
    min_idx, max_idx = 0, 0

    for i in range(1, n):
        if nums[i] < nums[min_idx]:
            min_idx = i
        if nums[i] > nums[max_idx]:
            max_idx = i

    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)
```

",,
"```python
from collections import defaultdict

def people_with_secret(n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
    secret_holders = set([firstPerson])
    meetings_by_time = defaultdict(list)

    for meeting in meetings:
        meetings_by_time[meeting[2]].append(tuple(meeting[:2]))
        
    for time in range(n):
        if time in meetings_by_time:
            for x, y in meetings_by_time[time]:
                if x in secret_holders or y in secret_holders:
                    secret_holders.add(x)
                    secret_holders.add(y)

    return list(secret_holders)
```

",,
"```python
def min_health(damage, armor):
    health = 0
    for dmg in reversed(damage):
        health += dmg
        if health > armor:
            health -= armor
            armor = 0
    return health + 1
```

",,
"```python
from itertools import permutations

def unique_permutations(digits):
    unique_perms = set(permutations(digits))
    unique_ints = sorted({int(''.join(map(str, perm))) for perm in unique_perms})
    
    return unique_ints
```

",,
"```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def delete_middle(head):
    if not head or not head.next:
        return head
    slow = head
    fast = head
    prev = None

    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next

    prev.next = slow.next
    return head
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_path(root, target, path):
    if not root: return """"
    if root.val == target: return path
    left = find_path(root.left, target, path + ""L"")
    right = find_path(root.right, target, path + ""R"")
    return left if left else right

def shortest_path(root, start_value, dest_value):
    s_path = find_path(root, start_value, """")
    t_path = find_path(root, dest_value, """")
    i = 0
    while i < len(s_path) and i < len(t_path) and s_path[i] == t_path[i]: i += 1
    res = ""U"" * (len(s_path) - i) + t_path[i:]
    return res
```

",,
"```python
import heapq

def maxCoins(piles, k):
    pq = []
    for pile in piles:
        for coin in pile:
            heapq.heappush(pq, -coin)
    
    max_value = 0
    while k > 0:
        max_value += -heapq.heappop(pq)
        k -= 1
    return max_value
```

",,
"```python
def max_words_in_sentence(sentences):
    max_words = 0
    for sentence in sentences:
        words = len(sentence.split())
        max_words = max(max_words, words)
    return max_words
```

",,
"```python
def is_valid_parentheses_string(s: str, locked: str) -> bool:
    balance = 0
    for i in range(len(s)):
        if locked[i] == '0':
            balance += 1 if s[i] == '(' else -1
            if balance < 0:
                return False
    return balance == 0
```

",,
"```python
def abbreviated_product(left: int, right: int) -> str:
    product = 1
    for i in range(left, right + 1):
        product *= i
    return str(product)
```


",,
"```python
def string_sum_scores(s):
    score = 0
    prefix_length = 0

    for i in range(len(s) - 1, -1, -1):
        if s[i] == s[-1]:
            prefix_length += 1
        else:
            prefix_length = 0
        score += prefix_length
        
    return score
```


",,
"```python
def minimum_operations(current: str, correct: str) -> int:
    ch, cm = map(int, current.split(':'))
    th, tm = map(int, correct.split(':'))
    ct = ch * 60 + cm
    tt = th * 60 + tm

    operations = 0
    while ct < tt:
        if tt - ct >= 60:
            ct += 60
        elif tt - ct >= 15:
            ct += 15
        elif tt - ct >= 5:
            ct += 5
        else:
            ct += 1

        operations += 1

    return operations
```


",,
"```python
from collections import defaultdict
from typing import List, Set

def twoLists(matches: List[List[int]]) -> List[Set[int]]:
    loss_count = defaultdict(int)
    participants = set()
    
    for winner, loser in matches:
        loss_count[loser] += 1
        participants.add(winner)
        participants.add(loser)
    
    no_losses = {participant for participant in participants if loss_count[participant] == 0}
    one_loss = {participant for participant in participants if loss_count[participant] == 1}
    
    return [no_losses, one_loss]
```

",,
"```python
def count_rods_with_all_colors(rings: str) -> int:
    rod_colors = [0] * 10

    for i in range(0, len(rings), 2):
        color = ord(rings[i]) - ord('A')
        rod = int(rings[i + 1])

        rod_colors[rod] |= (1 << color)

    return rod_colors.count(7)
```

",,
"```python
def sum_of_subarray_ranges(nums):
    n = len(nums)
    ans = 0
    for i in range(n):
        for j in range(i, n):
            ans += max(nums[i:j+1]) - min(nums[i:j+1])
    return ans
```

",,
"```python
from bisect import bisect_left

def maxFruits(fruits, startPos, k):
    n = len(fruits)
    left, right = [0] * (n + 1), [0] * (n + 1)
    j = 0

    for i in range(n):
        while j < n and fruits[j][0] - fruits[i][0] <= k:
            right[i + 1] += fruits[j][1]
            j += 1
        right[i + 1] += right[i]
        if j < n and fruits[j][0] - startPos <= k:
            right[0] += fruits[j][1]
            j += 1

    j = n - 1
    for i in range(n - 1, -1, -1):
        while j >= 0 and fruits[j][0] - fruits[i][0] <= k:
            left[i] += fruits[j][1]
            j -= 1
        left[i] += left[i + 1]

    ans = 0
    for i in range(n):
        rest = max(0, k - abs(fruits[i][0] - startPos))
        idx = bisect_left(fruits, [fruits[i][0] + rest, 0])
        ans = max(ans, left[i] + right[idx])

    return ans
```


",,
"```python
def first_palindrome(words):
    for word in words:
        if word == word[::-1]:
            return word
    return """"
```


",,
"```python
def add_spaces(s: str, spaces: List[int]) -> str:
    result = []
    j = 0
    for i, c in enumerate(s):
        while j < len(spaces) and i == spaces[j]:
            result.append(' ')
            j += 1
        result.append(c)
    return ''.join(result)
```

",,
"```python
def smooth_descent_periods(prices):
    count = 0
    i = 1
    while i < len(prices):
        if prices[i] == prices[i - 1] - 1:
            while i < len(prices) and prices[i] == prices[i - 1] - 1:
                i += 1
            count += 1
        else:
            i += 1
    return count
```

",,
"```python
def min_operations_to_K_increasing(arr, k):
    operations = 0
    for i in range(k, len(arr)):
        if arr[i] <= arr[i - k]:
            operations += (arr[i - k] - arr[i] + 1)
            arr[i] = arr[i - k] + 1
    return operations
```

",,
"```python
def capitalize_title(title):
    return ' '.join([word.capitalize() for word in title.split(' ')])
```


",,
"```python
def max_twin_sum(head):
    sum = 0
    max_sum = 0
    i = 0
    slow = head
    fast = head

    while fast and fast.next:
        fast = fast.next.next
        i += 1

    for j in range(i):
        sum = slow.val + fast.val
        max_sum = max(max_sum, sum)
        slow = slow.next
        fast = fast.prev

    return max_sum
```

",,
"```python
def longest_palindrome(words):
    from collections import defaultdict
    dict = defaultdict(int)
    result = 0
    has_odd = False

    for word in words:
        dict[word[0]] += 1
        dict[word[1]] += 1

    for count in dict.values():
        result += count // 2 * 2
        has_odd |= count % 2

    return result + has_odd
```

",,
"```python
def robot_instructions(n: int, start_pos: list, s: str) -> list:
    answer = [0] * len(s)

    for idx in range(len(s)):
        row, col = start_pos

        for i in range(idx, len(s)):
            move = s[i]
            if move == 'L':
                col -= 1
            elif move == 'R':
                col += 1
            elif move == 'U':
                row -= 1
            elif move == 'D':
                row += 1

            if row < 0 or row >= n or col < 0 or col >= n:
                break

            answer[idx] += 1

    return answer
```


",,
"```python
from collections import defaultdict

def sum_of_intervals(arr):
    n = len(arr)
    indices = defaultdict(list)
    intervals = [0] * n

    for i in range(n):
        indices[arr[i]].append(i)

    for i in range(n):
        for index in indices[arr[i]]:
            intervals[i] += abs(index - i)

    return intervals
```

",,
"```python
def recoverArray(n, nums):
    nums.sort()
    arr = [nums[i * 2] for i in range(n)]
    return arr
```

",,
"```python
def maxScore(scores, edges):
    adj_list = [[] for _ in range(len(scores))]
    result = -1

    for edge in edges:
        adj_list[edge[0]].append(edge[1])
        adj_list[edge[1]].append(edge[0])

    for edge in edges:
        for neighbor in adj_list[edge[0]]:
            for next in adj_list[edge[1]]:
                if next != neighbor and next != edge[0]:
                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next])

    return result
```


",,
"```python
def is_a_only_before_b(s: str) -> bool:
    last_index_a = -1
    for i, c in enumerate(s):
        if c == 'a':
            last_index_a = i
        elif c == 'b' and last_index_a > -1:
            return False
    return True
```

",,
"```python
def numOfBeams(bank):
    m = len(bank)
    n = len(bank[0])
    beams = 0

    for i in range(m):
        for j in range(n):
            if bank[i][j] == '1':
                k = j + 1
                while k < n and bank[i][k] != '1':
                    beams += bank[i][k] == '0'
                    k += 1
                k = i + 1
                while k < m and bank[k][j] != '1':
                    beams += bank[k][j] == '0'
                    k += 1

    return beams
```

",,
"```python
def can_destroy_all_asteroids(mass, asteroids):
    asteroids.sort()
    for asteroid in asteroids:
        if mass >= asteroid:
            mass += asteroid
        else:
            return False
    return True
```


",,
"```python
def max_invites(favorite):
    n = len(favorite)
    dp = [0] * n
    max_invites = 0

    for i in range(n):
        dp[i] = 2 if i == favorite[favorite[i]] else 1
        max_invites = max(max_invites, dp[i])

    return max_invites
```


",,
"```python
def dfs(curr_city, remaining_highways, cost_so_far, highways, visited):
    if remaining_highways == 0:
        return cost_so_far

    visited[curr_city] = True
    max_cost = -1

    for highway in highways:
        next_city = -1
        if highway[0] == curr_city and not visited[highway[1]]:
            next_city = highway[1]
        elif highway[1] == curr_city and not visited[highway[0]]:
            next_city = highway[0]

        if next_city != -1:
            cost = dfs(next_city, remaining_highways - 1, cost_so_far + highway[2], highways, visited)
            max_cost = max(max_cost, cost)

    visited[curr_city] = False
    return max_cost

def max_cost(n, highways, k):
    visited = [False] * n
    max_cost = -1

    for i in range(n):
        cost = dfs(i, k, 0, highways, visited)
        max_cost = max(max_cost, cost)

    return max_cost
```

",,
"```python
def min_cost(cost):
    cost.sort(reverse=True)
    n = len(cost)
    min_cost = 0

    for i in range(0, n, 3):
        min_cost += cost[i]
        if i+1 < n:
            min_cost += cost[i+1]

    return min_cost
```

",,
"```python
def count_sequences(differences, lower, upper):
    count = 0
    n = len(differences)
    hidden = [0] * (n + 1)

    hidden[0] = lower
    while True:
        valid = True
        for i in range(1, n + 1):
            hidden[i] = hidden[i - 1] + differences[i - 1]
            if hidden[i] < lower or hidden[i] > upper:
                valid = False
                break
        if valid: count += 1

        if hidden[0] == upper: break
        hidden[0] += 1
    
    return count
```


",,
"```python
from heapq import heappush, heappop

def kHighestRankedItems(grid, pricing, start, k):
    m, n = len(grid), len(grid[0])
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    res = []
    pq = []
    visited = [[False for _ in range(n)] for _ in range(m)]

    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))
    visited[start[0]][start[1]] = True

    while pq and k > 0:
        size = len(pq)
        for _ in range(size):
            curr = heappop(pq)
            steps, price, row, col = curr

            if pricing[0] <= -price <= pricing[1]:
                res.append([row, col])
                k -= 1

            for dr, dc in directions:
                newRow, newCol = row + dr, col + dc
                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:
                    visited[newRow][newCol] = True
                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))

    return res
```

",,
"```python
MOD = 10**9 + 7

def corridor_ways(corridor):
    n = len(corridor)
    dp = [0] * (n + 1)
    dp[0] = 1

    seats = 0
    for i in range(n):
        if corridor[i] == 'S':
            seats += 1
            if seats % 2 == 0:
                dp[i + 1] = dp[max(0, i - 1)]
            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD
        else:
            dp[i + 1] = dp[i]

    return dp[n]
```

",,
"```python
def isValidMatrix(matrix):
    n = len(matrix)
    for i in range(n):
        row = set(matrix[i])
        col = set(matrix[j][i] for j in range(n))
        if len(row) != n or len(col) != n:
            return False
    return True
```

",,
"```python
def minSwaps(nums):
    ones = maxOnes = currOnes = left = 0

    for num in nums:
        ones += num

    for right in range(len(nums)):
        currOnes += nums[right]

        if right - left + 1 > ones:
            currOnes -= nums[left]
            left += 1

        maxOnes = max(maxOnes, currOnes)

    return ones - maxOnes
```

",,
"```python
def count_convertible_words(start_words, target_words):
    count = 0
    for target in target_words:
        for start in start_words:
            if len(start) + 1 == len(target) and target.startswith(start):
                count += 1
                break
    return count
```

",,
"```python
def earliest_blooming_day(plant_time, grow_time):
    bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))]
    bloom_time.sort()
    earliest_day = 0
    for i in bloom_time:
        earliest_day = max(earliest_day, i)
        earliest_day += 1
    return earliest_day
```

",,
"```python
from collections import deque

dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

def getMaxSafeMinutes(grid):
    m, n = len(grid), len(grid[0])
    dist = [[-1 for _ in range(n)] for _ in range(m)]
    q = deque()

    if grid[m - 1][n - 1] != 1:
        dist[m - 1][n - 1] = 0
        q.append((m - 1, n - 1))

    while q:
        x, y = q.popleft()
        for d in range(4):
            nx, ny = x + dx[d], y + dy[d]
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))

    if dist[0][0] == -1:
        return -1

    res = 0
    for test in range(dist[0][0], int(1e9)):
        ok = True
        for x in range(m):
            for y in range(n):
                if grid[x][y] == 1:
                    for d in range(4):
                        nx, ny = x + dx[d], y + dy[d]
                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:
                            break
                    else:
                        ok = False
                        break
        if ok:
            res = test
        else:
            break
    return res
```
",,
"```python
def max_number_after_remove_digit(number: str, digit: str) -> str:
    index = number.find(digit)
    return number[:index] + number[index + 1:]
```

",,
"```python
def partition_string(s, k, fill):
    partitions = []
    current_partition = ''
    for c in s:
        current_partition += c
        if len(current_partition) == k:
            partitions.append(current_partition)
            current_partition = ''
    if current_partition:
        current_partition += fill * (k - len(current_partition))
        partitions.append(current_partition)
    return partitions
```

",,
"```python
def highestScoreDivisions(nums):
    count0, count1 = 0, 0
    for n in nums:
        if n == 1:
            count1 += 1
            
    max_score, current_score = -1, 0
    result = []
    for i, n in enumerate(nums):
        if n == 0:
            current_score += 1
        else:
            count1 -= 1
            
        if current_score > max_score:
            max_score = current_score
            result = [i]
        elif current_score == max_score:
            result.append(i)
            
    return result
```


",,
"```python
def max_points(questions):
    n = len(questions)
    dp = [0] * (n + 1)

    for i in range(n - 1, -1, -1):
        skip_next = i + questions[i][1]
        dp[i] = max(dp[i + 1], questions[i][0] + (dp[skip_next] if skip_next < n else 0))

    return dp[0]
```


",,
"```python
def max_running_time(n, batteries):
    batteries.sort(reverse=True)
    total_time = sum(batteries[:n])
    return total_time // n
```

",,
"```python
def split_and_minimize(num):
    a = num // 1000
    b = (num % 1000) // 100
    c = (num % 100) // 10
    d = num % 10
    return ((a * 10 + c) * 10 + b) * 10 + d
```

",,
"```python
def rearrange_array_around_pivot(nums, pivot):
    return sorted(nums, key=lambda x: (x >= pivot, x))
```


",,
"```python
def min_cost(startAt, moveCost, pushCost, targetSeconds):
    min_cost = float('inf')

    for i in range(100):
        for j in range(100):
            if i * 60 + j == targetSeconds:
                minute_move_cost = abs(i - startAt) * moveCost
                second_move_cost = abs(j - i) * moveCost
                total_push_cost = (2 if j > 0 else 0) + (1 if j // 10 != 0 else 0) + (1 if i // 10 != 0 else 0)
                
                min_cost = min(min_cost, minute_move_cost + second_move_cost + total_push_cost * pushCost)

    return min_cost
```

",,
"```python
def minDifference(nums):
    n = len(nums) // 3
    prefix, suffix = [0] * (n + 2), [0] * (n + 2)
    
    window = sorted(nums[:n])
    prefix[0] = sum(window)
    
    for i in range(n, 2 * n):
        window.remove(nums[i - n])
        bisect.insort(window, nums[i])
        prefix[i - n + 1] = sum(window)

    window = sorted(nums[-n:])
    suffix[n] = sum(window)
    
    for i in range(2 * n - 1, n - 1, -1):
        j = 3 * n - i - 1
        window.remove(nums[j])
        idx = bisect_left(window, nums[n * 2 - j - 1])
        window.insert(idx, nums[n * 2 - j - 1])
        suffix[i] = sum(window)

    return min(abs(a - b) for a, b in zip(prefix, suffix))
```

",,
"```python
def min_keypresses(s: str) -> int:
    keypresses = [(i % 9) + 1 for i in range(26)]
    result = 0
    for c in s:
        result += keypresses[ord(c) - ord('a')]
    return result
```

",,
"```python
def num_elements_with_smaller_and_greater(nums):
    n = len(nums)
    res = 0
    for i in range(n):
        has_smaller = has_greater = False
        for j in range(n):
            if i == j:
                continue
            if nums[j] > nums[i]:
                has_greater = True
            if nums[j] < nums[i]:
                has_smaller = True
            if has_smaller and has_greater:
                res += 1
                break
    return res
```

",,
"```python
def lonely_numbers(nums):
    num_set = set(nums)
    lonely = []
    for num in nums:
        if num - 1 not in num_set and num + 1 not in num_set:
            lonely.append(num)
    return lonely
```


",,
"```python
def rearrange_array(nums):
    nums.sort()
    half = len(nums) // 2
    result = [0] * len(nums)
    j = 0
    for i in range(half):
        result[j] = nums[i]
        result[j + 1] = nums[half + i]
        j += 2
    return result
```

",,
"```python
def maximum_good_people(statements):
    n = len(statements)
    count_good = 0
    for i in range(n):
        is_good = True
        for j in range(n):
            if statements[j][i] == 1 and statements[i][j] == 0:
                is_good = False
                break
        if is_good:
            count_good += 1
    return count_good
```

",,
"```python
def anagramOperations(words):
    i = 1
    while i < len(words):
        word1 = sorted(words[i])
        word2 = sorted(words[i - 1])
        if word1 == word2:
            del words[i]
        else:
            i += 1
    return words
```


",,
"```python
def final_value(nums, original):
    while original in nums:
        original += 1
    return original
```

",,
"```python
def find_substring(s, power, modulo, k, hash_value):
    current_hash = 0
    power_k = 1

    for i in range(k):
        current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo
        power_k = (power_k * power) % modulo

    if current_hash == hash_value:
        return s[:k]

    for i in range(k, len(s)):
        current_hash = ((current_hash - (ord(s[i - k]) - ord('a') + 1) * power_k) % modulo + modulo) % modulo
        current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo
        if current_hash == hash_value:
            return s[i - k + 1:i + 1]

    raise AssertionError(""No matching substring found"")
```

",,
"```python
def group_strings(words):
    groups = {}
    groups_count = 0

    for word in words:
        s_key = ''.join(sorted(word))

        if s_key not in groups:
            groups[s_key] = groups_count
            groups_count += 1

    return [groups_count, len(words) - groups_count]
```

",,
"```python
from collections import deque

def closest_nodes(n, edges, query):
    answer = []
    tree = [[] for _ in range(n)]
    
    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])
    
    def bfs(start, end):
        queue = deque([start])
        visited = {start}
        
        while queue:
            current = queue.popleft()
            
            if current == end:
                return current
            
            for neighbor in tree[current]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
    
    for q in query:
        lca = bfs(q[0], q[1])
        node1 = bfs(lca, q[0])
        node2 = bfs(lca, q[1])
        answer.append(q[0] if node1 == q[2] else q[1])
    
    return answer
```

",,
"```python
def three_consecutive_integers(num):
    if num % 3 == 0:
        return [num // 3 - 1, num // 3, num // 3 + 1]
    elif num % 3 == 1:
        return [(num - 2) // 3, (num + 1) // 3, (num + 4) // 3]
    else:
        return []
```

",,
"```python
def max_unique_even_sum(final_sum):
    result = []
    current = 2
    while final_sum > 0:
        if final_sum >= current:
            result.append(current)
            final_sum -= current
            current += 2
        else:
            break
    return result
```

",,
"```python
def count_good_triplets(nums1: list, nums2: list) -> int:
    n = len(nums1)
    pos1 = [0] * n
    pos2 = [0] * n
    for i in range(n):
        pos1[nums1[i]] = i
        pos2[nums2[i]] = i
    count = 0
    for x in range(n):
        for y in range(x + 1, n):
            for z in range(y + 1, n):
                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:
                    count += 1
    return count
```

",,
"```python
mod = 1000000007
def sum_of_strength(strength):
    res, strength_len = 0, len(strength)
    for i in range(strength_len):
        minimum = total = strength[i]
        for j in range(i, strength_len):
            minimum = min(minimum, strength[j])
            total += strength[j]
            res = (res + minimum * total % mod) % mod
    return res
```

",,
"```python
def visible_people(heights):
    m, n = len(heights), len(heights[0])
    answer = [[0 for _ in range(n)] for _ in range(m)]

    for i in range(m):
        for j in range(n):
            for k in range(j+1, n):
                if heights[i][j] >= heights[i][k]:
                    if heights[i][j] > heights[i][k]:
                        answer[i][j] += 1
                else:
                    break
            for k in range(i+1, m):
                if heights[i][j] >= heights[k][j]:
                    if heights[i][j] > heights[k][j]:
                        answer[i][j] += 1
                else:
                    break

    return answer
```

",,
"```python
def rearrange_array(nums):
    nums.sort()
    for i in range(1, len(nums) - 1, 2):
        nums[i], nums[i + 1] = nums[i + 1], nums[i]
    return nums
```

",,
"```python
def rearrange_digits(num):
    if num == 0:
        return 0
    digits = sorted(str(num))
    
    if digits[0] != '-' and digits[0] == '0':
        nonzero_index = next(index for index, digit in enumerate(digits) if digit != '0')
        digits[0], digits[nonzero_index] = digits[nonzero_index], digits[0]
    
    return int("""".join(digits))
```

",,
"```python
class BitSet:
    def __init__(self, size):
        self.bits = [0] * ((size + 31) // 32)

    def set(self, index):
        self.bits[index // 32] |= (1 << (index % 32))

    def get(self, index):
        return (self.bits[index // 32] & (1 << (index % 32))) != 0
```

",,
"```python
def maxNumberOfCopies(s, target):
    s_counts = [0] * 26
    target_counts = [0] * 26

    for c in s:
        s_counts[ord(c) - ord('a')] += 1

    for c in target:
        target_counts[ord(c) - ord('a')] += 1

    max_copies = float('inf')
    for i in range(26):
        if target_counts[i] > 0:
            max_copies = min(max_copies, s_counts[i] // target_counts[i])
    return max_copies
```


",,
"```python
def operations(num1, num2):
    count = 0
    while num1 != 0 and num2 != 0:
        if num1 >= num2:
            num1 -= num2
        else:
            num2 -= num1
        count += 1
    return count
```

",,
"```python
def min_operations(nums):
    n = len(nums)
    even, odd = 0, 0

    for i in range(n):
        if i % 2 == 0 and nums[i] % 2 != 0:
            even += 1
        elif i % 2 != 0 and nums[i] % 2 == 0:
            odd += 1

    return min(even, odd)
```

",,
"```python
def min_number_of_beans_to_remove(beans):
    count = {}
    for bean in beans:
        if bean not in count:
            count[bean] = 0
        count[bean] += 1

    min_remove = len(beans)
    for key, value in count.items():
        remove = 0
        for other_key, other_value in count.items():
            if other_key != key:
                remove += other_value * max(0, other_key - key)
        min_remove = min(min_remove, remove)

    return min_remove
```

",,
"```python
def max_and_sum(nums, num_slots):
    slot = [0] * (num_slots + 1)
    for num in nums:
        for j in range(num_slots, 0, -1):
            new_val = num & j
            if new_val > slot[j]:
                slot[j] = new_val

    return sum(slot)
```

",,
"```python
def min_steps(s: str, t: str) -> int:
    char_count = {}
    for c in s:
        char_count[c] = char_count.get(c, 0) + 1
    for c in t:
        char_count[c] = char_count.get(c, 0) - 1
    
    steps = sum(abs(count) for count in char_count.values())
    
    return steps // 2
```


",,
"```python
def minimum_time_for_trips(time, total_trips):
    time.sort()

    start, end = 0, time[-1] * total_trips
    while start < end:
        mid = start + (end - start) // 2
        trips = sum(mid // t for t in time)
        if trips < total_trips:
            start = mid + 1
        else:
            end = mid

    return start
```

",,
"```python
def min_race_time(tires, changeTime, numLaps):
    n = len(tires)
    times = [fi + (numLaps - 1) * ri for fi, ri in tires]
    min_time = min(times) + (numLaps - 1) * changeTime
    
    for i in range(n):
        for j in range(n):
            if i != j:
                min_time = min(min_time, times[i] + times[j] - tires[i][0] + (numLaps - 2) * changeTime)
    return min_time
```

",,
"```python
class TextEditor:
    def __init__(self):
        self.text = """"
        self.cursor = 0

    def addText(self, newText: str) -> None:
        self.text = self.text[:self.cursor] + newText + self.text[self.cursor:]
        self.cursor += len(newText)
        
    def deleteText(self, k: int) -> int:
        deleted = min(k, self.cursor)
        self.text = self.text[:self.cursor - deleted] + self.text[self.cursor:]
        self.cursor -= deleted
        return deleted

    def cursorLeft(self, k: int) -> str:
        self.cursor -= min(k, self.cursor)
        return self.text[max(0, self.cursor - 10):self.cursor]
        
    def cursorRight(self, k: int) -> str:
        self.cursor += min(k, len(self.text) - self.cursor)
        return self.text[max(0, self.cursor - 10):self.cursor]
```


",,
"```python
def minHeightJump(nums, costs):
    n = len(nums)
    dp = [float('inf')] * n

    dp[0] = 0
    for i in range(1, n):
        for j in range(i - 1, -1, -1):
            if ((nums[j] <= nums[i] and (j == 0 or nums[j - 1] < nums[i])) or (nums[j] > nums[i] and (j == 0 or nums[j - 1] >= nums[i]))):
                dp[i] = min(dp[i], dp[j] + costs[i])

    return dp[n - 1]
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_nodes_between_zeros(head: ListNode) -> ListNode:
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    cur = head

    while cur:
        if cur.val == 0:
            tmp_sum = 0
            while cur.next and cur.next.val != 0:
                tmp_sum += cur.next.val
                cur = cur.next
            prev.next = ListNode(tmp_sum)
            prev = prev.next
            cur = cur.next

    return dummy.next
```

",,
"```python
def repeat_limited_string(s, repeat_limit):
    result = []
    sorted_s = sorted(s, reverse=True)
    
    for c in sorted_s:
        pos = result.count(c)
        
        if pos < repeat_limit:
            result.insert(pos, c)

    return """".join(result)
```


",,
"```python
def count_pairs(nums, k):
    mod_count = [0] * k
    count = 0

    for num in nums:
        mod_count[num % k] += 1

    count += mod_count[0] * (mod_count[0] - 1) // 2

    for i in range(1, k // 2 + 1):
        if i != k - i:
            count += mod_count[i] * mod_count[k-i]
        else:
            count += mod_count[i] * (mod_count[i] - 1) // 2

    return count
```


",,
"```python
def countSubarrays(nums: List[int], k: int) -> int:
    n = len(nums)
    left, right = 0, 0
    sum_, count = 0, 0

    while right < n:
        sum_ += nums[right]
        while sum_ * (right - left + 1) >= k:
            sum_ -= nums[left]
            left += 1
        count += right - left + 1
        right += 1

    return count
```

",,
"```python
def tax_amount(brackets, income):
    tax = 0
    prev_upper = 0
    for upper, percent in brackets:
        tax += (min(upper, income) - prev_upper) * (percent / 100)
        prev_upper = upper
        if income <= upper:
            break
    return tax
```

",,
"```python
def excel_sheet_cells(s: str):
    c1, r1, c2, r2 = s.split(':')
    r1, r2 = int(r1[1:]), int(r2[1:])
    c1, c2 = ord(c1[0]), ord(c2[0])
    result = []

    for c in range(c1, c2 + 1):
        for r in range(r1, r2 + 1):
            result.append(chr(c) + str(r))

    return result
```

",,
"```python
def min_append_k_sum(nums, k):
    max_elem = max(nums)
    return sum(range(max_elem + 1, max_elem + k + 1))
```

",,
"```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def construct_tree(descriptions):
    nodes = {}

    for d in descriptions:
        nodes[d[0]] = TreeNode(d[0])
        nodes[d[1]] = TreeNode(d[1])

    for d in descriptions:
        if d[2]:
            nodes[d[0]].left = nodes[d[1]]
        else:
            nodes[d[0]].right = nodes[d[1]]

    return nodes[descriptions[0][0]]
```

",,
"```python
from math import gcd

def modify_array(nums):
    i = 1
    while i < len(nums):
        if gcd(nums[i-1], nums[i]) > 1:
            nums.insert(i, 1)
            i += 1
        i += 1
    return nums
```

",,
"```python
def get_max_occurrences(text: str, pattern: str) -> int:
    count = [0, 0]
    for c in text:
        if c == pattern[1]:
            count[1] += count[0]
        elif c == pattern[0]:
            count[0] += 1
    return count[1]
```

",,
"```python
def min_operations(nums):
    nums.sort(reverse=True)
    total_sum = sum(nums)
    half_sum, operations = 0, 0
    for num in nums:
        half_sum += num
        operations += 1
        if half_sum >= (total_sum + 1) // 2:
            break
    return operations
```

",,
"```python
def min_visible_white_tiles(floor, num_carpets, carpet_len):
    n = len(floor)
    visible_white_count = floor.count('1')

    covered_tiles = 0
    for i in range(n):
        if floor[i] == '1':
            start = max(0, i - carpet_len + 1)
            end = min(n - carpet_len, i)
            max_cover = 0
            for first_tile in range(start, end + 1):
                cover = floor[first_tile:first_tile + carpet_len].count('1')
                max_cover = max(max_cover, cover)
                          
            covered_tiles += max_cover
            num_carpets -= 1            
            if num_carpets == 0:
                break

    return visible_white_count - covered_tiles
```

",,
"```python
def max_count_target(nums, key):
    count = {}
    max_count = 0
    max_target = -1
    for i in range(1, len(nums)):
        if nums[i - 1] == key:
            count[nums[i]] = count.get(nums[i], 0) + 1
            if count[nums[i]] > max_count:
                max_count = count[nums[i]]
                max_target = nums[i]
    return max_target
```

",,
"```python
class Node:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def min_operations(root, result):
    if root is None:
        return 0
    if root.val <= 1:
        return 0 if root.val == result else 1
    else:
        left_operations = min_operations(root.left, result ^ 1 if root.val == 4 else result)
        right_operations = min_operations(root.right, result ^ 1 if root.val == 4 else result)
        if root.val == 3:
            return min(left_operations, right_operations)
        elif root.val == 2:
            return max(left_operations, right_operations)
        else:
            return left_operations + right_operations
```

",,
"```python
def count_stars_except_between_pair(s: str) -> int:
    count = 0
    pipe_count = 0

    for c in s:
        if c == '|':
            pipe_count += 1
        elif c == '*' and pipe_count % 2 == 0:
            count += 1

    return count
```


",,
"```python
def count_hills_valleys(nums):
    count = 0
    for i in range(1, len(nums) - 1):
        if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (nums[i] < nums[i - 1] and nums[i] < nums[i + 1]):
            count += 1
    return count
```


",,
"```python
def count_collisions(directions: str) -> int:
    collision_count = 0
    left_count = 0

    for direction in directions:
        if direction == 'L':
            left_count += 1
        elif direction == 'R':
            collision_count += left_count

    return collision_count
```

",,
"```python
def bob_arrows(num_arrows, alice_arrows):
    bob = [0] * 12
    for i in range(11, -1, -1):
        if num_arrows > 0 and alice_arrows[i] == 0:
            shot = min(num_arrows, i+1)
            bob[i] = shot
            num_arrows -= shot
    return bob
```


",,
"```python
def longest_repeat_substring(s, query_characters, query_indices):
    k = len(query_characters)
    lengths = []
    s_copy = list(s)

    for i in range(k):
        s_copy[query_indices[i]] = query_characters[i]
        max_len = cur_len = 1
        for j in range(1, len(s_copy)):
            if s_copy[j] == s_copy[j-1]:
                cur_len += 1
            else:
                max_len = max(max_len, cur_len)
                cur_len = 1
        max_len = max(max_len, cur_len)
        lengths.append(max_len)

    return lengths
```

",,
"```python
def k_distant_indices(nums, key, k):
    result = []
    for i in range(len(nums)):
        for j in range(max(0, i - k), min(i + k + 1, len(nums))):
            if nums[j] == key:
                result.append(i)
                break
    return result
```

",,
"```python
import heapq
from collections import defaultdict

def shortest_path(n, edges, src1, src2, dest):
    graph = defaultdict(list)
    
    for u, v, w in edges:
        graph[u].append((v, w))
    
    def dijkstra(src):
        dist = [float('inf')] * n
        pq = [(0, src)]

        dist[src] = 0

        while pq:
            d, u = heapq.heappop(pq)

            if d != dist[u]:
                continue

            for v, w in graph[u]:
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    heapq.heappush(pq, (dist[v], v))

        return dist

    src1_to_all = dijkstra(src1)
    src2_to_all = dijkstra(src2)

    min_weight = float('inf')
    for u, v, w in edges:
        min_weight = min(min_weight, src1_to_all[u] + w + src2_to_all[v])

    return -1 if min_weight == float('inf') else min_weight
```


",,
"```python
def dfs(node, parent, xor_values, tree):
    xor_value = xor_values[node]
    for child in tree[node]:
        if child != parent:
            xor_value ^= dfs(child, node, xor_values, tree)
    return xor_value


def minimumScore(nums, edges):
    n = len(nums)
    tree = [[] for _ in range(n)]
    
    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])
    
    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]
    
    ans = float('inf')
    for i in range(n):
        for j in range(i + 1, n):
            xor1 = xor_values[i]
            xor2 = xor_values[j] ^ nums[i]
            xor3 = nums[i] ^ nums[j]
            max_xor = max(xor1, xor2, xor3)
            min_xor = min(xor1, xor2, xor3)
            ans = min(ans, max_xor - min_xor)
    
    return ans
```

",,
"```python
def min_bit_flips(start, goal):
    xor_value = start ^ goal
    flips = 0
    while xor_value:
        flips += xor_value & 1
        xor_value >>= 1
    return flips
```

",,
"```python
def valid_selections(s: str) -> int:
    res = 0
    for i in range(1, len(s) - 1):
        if s[i - 1] != s[i] and s[i] != s[i + 1] and s[i - 1] != s[i + 1]:
            res += 1
    return res
```

",,
"```python
def sum_prefix_scores(s: str) -> int:
    n = len(s)
    sum_scores = 0
    longest_common_prefix = 0
    for i in range(n - 1, -1, -1):
        if s[i] == s[n - 1 - longest_common_prefix]:
            longest_common_prefix += 1
        else:
            longest_common_prefix = 0
        sum_scores += longest_common_prefix
    return sum_scores
```

",,
"```python
def largest_swap_permutations(num):
    num_str = str(num)
    even_digits = sorted([c for c in num_str if int(c) % 2 == 0], reverse=True)
    odd_digits = sorted([c for c in num_str if int(c) % 2 == 1], reverse=True)

    result = []
    for c in num_str:
        if int(c) % 2 == 0:
            result.append(even_digits.pop(0))
        else:
            result.append(odd_digits.pop(0))

    return int(''.join(result))
```


",,
"```python
def add_parentheses(expression: str) -> str:
    return f""({expression})""
```


",,
"```python
def max_beauty(flowers, new_flowers, target, full, partial):
    beauty = sum(full if f >= target else partial * f for f in flowers)
    flowers.sort()

    for i in range(len(flowers)):
        needed = target - flowers[i]
        if needed <= new_flowers:
            beauty += full - partial * flowers[i]
            flowers[i] = target
            new_flowers -= needed

    return beauty
```

",,
"```python
def evalTree(root: 'TreeNode') -> bool:
    if not root.left and not root.right:
        return root.val == 1
    left = evalTree(root.left)
    right = evalTree(root.right)

    if root.val == 2:
        return left or right
    return left and right
```


",,
"```python
def last_passenger_time(buses, passengers, capacity):
    buses.sort()
    passengers.sort()

    last_index = 0
    for bus in buses:
        cnt = 0
        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:
            cnt += 1
            last_index += 1

    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1
```

",,
"```python
def min_sum_of_squared_difference(nums1, nums2, k1, k2):
    res = 0
    for i in range(len(nums1)):
        diff = abs(nums1[i] - nums2[i])
        steps = min(k1 + k2, diff)
        diff -= steps
        k1 -= min(k1, steps)
        res += diff * diff
    return res
```

",,
"```python
def find_subarray_length(nums, threshold):
    n = len(nums)
    left = 0
    right = 0
    total = 0
    max_length = -1

    while right < n:
        total += nums[right]
        while total * (right - left + 1) < threshold * (right - left + 1):
            total -= nums[left]
            left += 1
        max_length = max(max_length, right - left + 1)
        right += 1

    return max_length
```

",,
"```python
def min_seconds(amount: List[int]) -> int:
    total = sum(amount)
    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])
    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two
```

",,
"```python
class SmallestInfiniteSet:
    def __init__(self):
        self.available = set(range(1, 1001))
        self.counter = 1

    def popSmallest(self):
        smallest = self.counter
        if self.counter in self.available:
            self.available.remove(self.counter)
        else:
            self.counter += 1
        return smallest

    def addBack(self, num):
        self.available.add(num)
```

",,
"```python
def canTransform(start: str, target: str) -> bool:
    n = len(start)
    p, q = 0, 0

    while p < n and q < n:
        while p < n and start[p] == '_': p += 1
        while q < n and target[q] == '_': q += 1

        if p == n or q == n: break

        if start[p] != target[q]: return False

        if start[p] == 'L' and p < q: return False
        if start[p] == 'R' and p > q: return False

        p += 1
        q += 1

    return p == n and q == n
```

",,
"```python
def numOfArrays(n: int, maxValue: int) -> int:
    mod = 10**9 + 7
    dp = [0] * (maxValue + 1)
    
    for i in range(1, maxValue + 1):
        dp[i] = i
        
    for i in range(1, n):
        for j in range(maxValue, 0, -1):
            dp[j] = (dp[j] + dp[j - 1]) % mod
            
    return dp[maxValue]
```


",,
"```python
def minSwaps(nums):
    n = len(nums)
    minPos = 0
    maxPos = 0
    swaps = 0

    for i in range(1, n):
        if nums[i] <= nums[minPos]:
            minPos = i
        if nums[i] >= nums[maxPos]:
            maxPos = i

    swaps = minPos + (n - 1 - maxPos)
    if minPos < maxPos:
        swaps -= 1

    return swaps
```

",,
"```python
def count_pairs_leftovers(nums):
    counter = [0] * 101
    pairs, leftovers = 0, 0

    for n in nums:
        counter[n] += 1

    for count in counter:
        pairs += count // 2
        leftovers += count % 2

    return [pairs, leftovers]
```

",,
"```python
def max_sum_numbers_with_equal_sum_of_digits(nums):
    digit_sum_to_max = {}
    ans = -1

    for num in nums:
        sum_of_digits = sum(map(int, str(num)))
        
        prev_max = digit_sum_to_max.get(sum_of_digits, 0)
        if prev_max:
            ans = max(ans, num + prev_max)
        
        digit_sum_to_max[sum_of_digits] = max(num, prev_max)

    return ans
```

",,
"```python
from typing import List

def kthSmallestIndex(nums: List[str], queries: List[List[int]]) -> List[int]:
    answer = []
    indices = list(enumerate(map(int, nums)))
    indices.sort(key=lambda x: (x[1], x[0]))

    for k, trim in queries:
        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]
        trimmed_indices.sort(key=lambda x: (x[1], x[0]))
        answer.append(trimmed_indices[k-1][0])

    return answer
```

",,
"```python
def min_deletions(nums, nums_divide):
    res = float('inf')
    for num in nums:
        cnt = 0
        found = True
        for d in nums_divide:
            if d % num != 0:
                found = False
                break
        if found:
            for n in nums:
                if n == num:
                    cnt += 1
            res = min(res, len(nums) - cnt)
    return -1 if res == float('inf') else res
```

",,
"```python
def min_operations(current, correct):
    current_mins = int(current[:2]) * 60 + int(current[3:])
    correct_mins = int(correct[:2]) * 60 + int(correct[3:])
    if current_mins > correct_mins:
        correct_mins += 24 * 60

    diff = correct_mins - current_mins
    count = diff // 60 + (diff % 60) // 15 + ((diff % 60) % 15) // 5 + (((diff % 60) % 15) % 5)

    return count
```

",,
"```python
def best_poker_hand(ranks, suits):
    rank_count = {}
    suit_count = {}
    for rank, suit in zip(ranks, suits):
        rank_count[rank] = rank_count.get(rank, 0) + 1
        suit_count[suit] = suit_count.get(suit, 0) + 1
    if len(suit_count) == 1:
        return ""Flush ""
    if len(rank_count) == 3:
        return ""Three of a Kind ""
    for value in rank_count.values():
        if value == 2:
            return ""Pair ""
    return ""High Card ""
```


",,
"```python
def numberOfSubarraysWithZeroes(nums):
    count = 0
    zero_count = 0

    for num in nums:
        if num == 0:
            zero_count += 1
            count += zero_count
        else:
            zero_count = 0

    return count
```


",,
"```python
class NumberContainers:
    def __init__(self):
        self.indices = {}
        self.nums = {}

    def change(self, index: int, number: int) -> None:
        if index in self.indices:
            old_number = self.indices[index]
            self.nums[old_number].remove(index)
            if not self.nums[old_number]:
                del self.nums[old_number]
        self.indices[index] = number
        if number not in self.nums:
            self.nums[number] = set()
        self.nums[number].add(index)

    def find(self, number: int) -> int:
        if number in self.nums:
            return min(self.nums[number])
        return -1
```


",,
"```python
def shortest_unrollable_sequence(rolls, k):
    count = [0] * (k + 1)
    for roll in rolls:
        count[roll] += 1
    
    len_ = 1
    while True:
        max_subsequences = 1
        for i in range(1, k + 1):
            max_subsequences *= count[i] + (1 if len_ == 1 else 0)
        
        if max_subsequences < len_ * len(rolls):
            return len_
        
        len_ += 1
```

",,
"```python
def first_letter_to_appear_twice(s: str) -> str:
    occurrences = [0] * 26
    for c in s:
        occurrences[ord(c) - ord('a')] += 1
        if occurrences[ord(c) - ord('a')] == 2:
            return c
    return '?'
```

",,
"```python
def countEqualRowColumnPairs(grid: List[List[int]]) -> int:
   n = len(grid)
   ans = 0

   for i in range(n):
      for j in range(n):
         equal = True
         for k in range(n):
             if grid[i][k] != grid[k][j]:
                 equal = False
                 break
         if equal:
             ans += 1

   return ans
```

",,
"```python
from collections import defaultdict

class FoodRatings:
    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
        self.food_ratings = {food: rating for food, rating in zip(foods, ratings)}
        self.highest_rated = defaultdict(str)
        
        for food, cuisine, rating in zip(foods, cuisines, ratings):
            if (not self.highest_rated[cuisine] or
                rating > self.food_ratings[self.highest_rated[cuisine]] or
                (rating == self.food_ratings[self.highest_rated[cuisine]] and food < self.highest_rated[cuisine])):
                self.highest_rated[cuisine] = food

    def changeRating(self, food: str, newRating: int) -> None:
        cuisine = [c for c, f in self.highest_rated.items() if f == food][0]
        self.food_ratings[food] = newRating
        for f, rating in self.food_ratings.items():
            if (self.highest_rated[cuisine] == food or
                (newRating > rating and cuisine == self.food_ratings[f]) or
                (newRating == rating and food < f)):
                self.highest_rated[cuisine] = food

    def highestRated(self, cuisine: str) -> str:
        return self.highest_rated[cuisine]
```


",,
"```python
from collections import Counter

def countExcellentPairs(nums, k):
    frequency = Counter(nums)
    count = 0
    for num1, freq1 in frequency.items():
        for num2, freq2 in frequency.items():
            setBits = bin(num1 | num2).count('1') + bin(num1 & num2).count('1')
            if setBits >= k:
                count += freq1 * freq2 if num1 != num2 else freq1 * (freq1 - 1) // 2
    return count
```

",,
"```python
def max_books(books):
    n = len(books)
    max_books = 0
    
    for l in range(n):
        r = l + 1
        books_taken = books[l]
        min_taken = books[l]
        max_books = max(max_books, books_taken)
        
        while r < n:
            min_taken = min(min_taken, books[r])
            books_taken += min_taken
            max_books = max(max_books, books_taken)
            
            if min_taken <= 1:
                break  # Can't decrease further
            r += 1
            
    return max_books
```

",,
"```python
def minOperations(nums):
    count = 0
    nums.sort()
    i = 0

    while i < len(nums):
        if nums[i] > 0:
            target = nums[i]
            while i < len(nums) and nums[i] == target:
                i += 1
            count += 1
        else:
            i += 1

    return count
```

",,
"```python
def max_groups(grades):
    grades.sort()

    dp = [1] * len(grades)

    for i in range(len(grades)):
        for j in range(i):
            if grades[i] + dp[j] * grades[j] > (i+1) * grades[j]:
                dp[i] = dp[j] + 1

    return dp[-1]
```


",,
"```python
def get_index_with_min_max_distance(edges, node1, node2):
    dist1 = [-1] * len(edges)
    dist2 = [-1] * len(edges)

    dist1[node1] = 0
    dist2[node2] = 0
    for i in range(len(edges)):
        if dist1[i] != -1 and edges[i] != -1:
            if dist1[edges[i]] == -1:
                dist1[edges[i]] = dist1[i] + 1
            else:
                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)

        if dist2[i] != -1 and edges[i] != -1:
            if dist2[edges[i]] == -1:
                dist2[edges[i]] = dist2[i] + 1
            else:
                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)

    ans = -1
    min_max_dist = float(""inf"")
    for i in range(len(edges)):
        if dist1[i] != -1 and dist2[i] != -1:
            max_dist = max(dist1[i], dist2[i])
            if max_dist < min_max_dist:
                min_max_dist = max_dist
                ans = i

    return ans
```

",,
"```python
def findLongestCycle(edges):
    n = len(edges)
    visited = [False] * n
    longest_cycle = -1

    for i in range(n):
        if not visited[i]:
            length = 0
            node = i

            while not visited[node] and edges[node] != -1:
                visited[node] = True
                length += 1
                node = edges[node]

            if edges[node] == i:
                longest_cycle = max(longest_cycle, length)

    return longest_cycle
```

",,
"```python
def min_stop_costs(regular, express, express_cost):
    n = len(regular)
    costs = [0] * n
    regular_sum, express_sum = 0, express_cost

    for i in range(n):
        regular_sum += regular[i]
        express_sum += express[i]
        costs[i] = min(regular_sum, express_sum + express_cost)

    return costs
```

",,
"```python
def sum_weights(items1, items2):
    weight_sums = {}
    result = []

    for value, weight in items1:
        weight_sums[value] = weight_sums.get(value, 0) + weight
    for value, weight in items2:
        weight_sums[value] = weight_sums.get(value, 0) + weight

    for value, weight in sorted(weight_sums.items()):
        result.append([value, weight])

    return result
```

",,
"```python
def bad_pairs(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if j - i != nums[j] - nums[i]:
                count += 1
    return count
```

",,
"```python
def min_days_to_complete_tasks(tasks, space):
    task_last_complete = {}
    days = 0

    for task in tasks:
        if task in task_last_complete:
            passed_days = days - task_last_complete[task]
            if passed_days < space:
                days += space - passed_days
        days += 1
        task_last_complete[task] = days

    return days
```

",,
"```python
def min_operations(nums):
    operations = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            diff = nums[i - 1] - nums[i] + 1
            operations += math.ceil(math.log2(diff))
            nums[i] += diff
    return operations
```

",,
"```python
def count_arithmetic_triplets(nums, diff):
    count = 0
    mp = {}
    for num in nums:
        if num - diff in mp:
            count += mp[num - diff]
        mp[num] = mp.get(num, 0) + 1
    return count
```

",,
"```python
from collections import defaultdict

def max_nodes_without_restricted(n, edges, restricted):
    tree = defaultdict(list)
    blocked_nodes = set(restricted)

    for a, b in edges:
        tree[a].append(b)
        tree[b].append(a)

    max_nodes = [0]

    def dfs(node, depth, parent):
        if node in blocked_nodes:
            return
        max_nodes[0] = max(max_nodes[0], depth)
        for child in tree[node]:
            if child != parent:
                dfs(child, depth + 1, node)

    dfs(0, 1, -1)
    return max_nodes[0]
```
",,
"```python
def valid_partition(nums):
    count = {}
    for num in nums:
        count[num] = count.get(num, 0) + 1
    for num, cnt in count.items():
        if cnt == 2 or cnt == 3 or (num - 1 in count and num + 1 in count):
            return True
    return False
```

",,
"```python
def longest_ideal_string(s: str, k: int) -> int:
    dp = [0] * 26

    for c in s:
        current = 1
        for i in range(26):
            if abs(i - (ord(c) - ord('a'))) <= k:
                current = max(current, dp[i] + 1)
        dp[ord(c) - ord('a')] = max(dp[ord(c) - ord('a')], current)

    return max(dp)
```

",,
"```python
def smallest_max_number_grid(grid):
    rows = [0] * len(grid)
    cols = [0] * len(grid[0])
    
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            rows[i] = max(rows[i], grid[i][j])
            cols[j] = max(cols[j], grid[i][j])

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            grid[i][j] = min(rows[i], cols[j])

    return grid
```


",,
"```python
def largest_matrix(grid):
    n = len(grid)
    maxLocal = [[0] * (n - 2) for _ in range(n - 2)]

    for i in range(1, n - 1):
        for j in range(1, n - 1):
            max_val = grid[i - 1][j - 1]
            for x in range(-1, 2):
                for y in range(-1, 2):
                    max_val = max(max_val, grid[i + x][j + y])
            maxLocal[i - 1][j - 1] = max_val

    return maxLocal
```

",,
"```python
def highest_edge_score_node(edges: List[int]) -> int:
    scores = [0] * len(edges)
    for i, edge in enumerate(edges):
        scores[edge] += i
    return scores.index(max(scores))
```

",,
"```python
def findSmallestNum(pattern: str) -> str:
    num = ""123456789""
    i = 0
    while i < len(pattern):
        if pattern[i] == 'D':
            j = i
            while j < len(pattern) and pattern[j] == 'D':
                j += 1
            num = num[:i] + num[i:j+1][::-1] + num[j+1:]
            i = j
        else:
            i += 1
    return num[:len(pattern) + 1]
```

",,
"```python
def is_distinct(n):
    unique_digits = set()
    while n > 0:
        digit = n % 10
        if digit in unique_digits:
            return False
        unique_digits.add(digit)
        n //= 10
    return True

def count_special(n):
    count = 0
    for i in range(1, n + 1):
        if is_distinct(i):
            count += 1
    return count
```

",,
"```python
def maxWeight(self, edges):
    n = len(edges)
    dp = [[0] * 2 for _ in range(n)]

    def dfs(node):
        for i in range(1, n):
            if edges[i][0] == node:
                dfs(i)
                dp[node][0] += max(dp[i][0], dp[i][1])
                dp[node][1] += dp[i][0]
        dp[node][1] += edges[node][1]

    dfs(0)
    return max(dp[0][0], dp[0][1])
```

",,
"```python
def min_operations(blocks, k):
    n = len(blocks)
    res = k
    w = b = 0
    i = j = 0

    while j < n:
        if blocks[j] == 'W':
            w += 1
        while b > k or (b == k and blocks[i] == 'B'):
            if blocks[i] == 'W':
                w -= 1
                i += 1
            else:
                b -= 1
                i += 1
        if b == k:
            res = min(res, w)
        else:
            b += 1
        j += 1
    
    return res
```

",,
"```python
def find_seconds_to_transform(s: str) -> int:
    cnt_0, cnt_1 = 0, 0
    for c in s:
        if c == '0': cnt_0 += 1
        else: cnt_1 += 1
    return min(cnt_0, cnt_1)
```

",,
"```python
def shiftCharacters(s: str, shifts: List[List[int]]) -> str:
    shift_values = [0] * len(s)
    for shift in shifts:
        start, end, direction = shift
        value = 1 if direction == 1 else -1
        shift_values[start] += value
        if end + 1 < len(s):
            shift_values[end + 1] -= value

    for i in range(1, len(s)):
        shift_values[i] += shift_values[i - 1]

    return ''.join(chr((ord(s[i]) - ord('a') + shift_values[i]) % 26 + ord('a')) for i in range(len(s)))
```

",,
"```python
def max_seg_sum_after_queries(nums, removeQueries):
    n = len(nums)
    answer = [0] * n
    removed = {-1, n}
    
    current_sum = 0
    max_sum = 0
    for x in nums:
        if x > 0:
            current_sum += x
        else:
            max_sum = max(max_sum, current_sum)
            current_sum = 0
    max_sum = max(max_sum, current_sum)
    
    for i, remove_idx in enumerate(removeQueries):
        answer[i] = max_sum
        nums[remove_idx] = -nums[remove_idx]
        
        left_idx = max(x for x in removed if x < remove_idx)
        right_idx = min(x for x in removed if x > remove_idx)
        
        left_sum = 0
        right_sum = 0
        for j in range(right_idx - 1, -1, -1):
            if nums[j] < 0:
                left_sum -= nums[j]
            else:
                break
        for j in range(left_idx + 1, n):
            if nums[j] < 0:
                right_sum -= nums[j]
            else:
                break
                
        max_sum -= max(0, left_sum - (-nums[remove_idx]))
        max_sum -= max(0, right_sum - (-nums[remove_idx]))
        max_sum += max(0, left_sum + right_sum - (-nums[remove_idx]))
        
        removed.add(remove_idx)
    
    return answer
```
",,
"```python
def min_training_hours(initial_energy, initial_experience, energy, experience):
    n = len(energy)
    ans = int(1e9)
    for exp_gain in range(initial_energy + initial_experience + 1):
        training_hours = exp_gain
        energy_left = initial_energy - exp_gain
        curr_experience = initial_experience + exp_gain
        
        for i in range(n):
            while curr_experience <= experience[i] or energy_left <= energy[i]:
                energy_left -= 1
                training_hours += 1
            energy_left -= energy[i]
            curr_experience += experience[i]
        ans = min(ans, training_hours)
    return ans
```

",,
"```python
def root_sum_equal(root):
    if not root:
        return False
    return root.val == root.left.val + root.right.val
```


",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def time_to_infect(node, start, minutes):
    if not node:
        return 0
    if node.val == start:
        return minutes
    return max(time_to_infect(node.left, start, minutes+1),
               time_to_infect(node.right, start, minutes+1))

def total_infection_time(root, total_minutes=0):
    if not root:
        return total_minutes
    time_needed = max(total_minutes,
                      time_to_infect(root, root.val, 0),
                      total_infection_time(root.left, total_minutes + 1),
                      total_infection_time(root.right, total_minutes + 1))
    return time_needed
```


",,
"```python
def kSum(nums, k):
    sums = [0]
    for num in nums:
        if num > 0:
            sums.extend([s + num for s in sums])
            sums.sort(reverse=True)
        else:
            sums.append(num)

    return sums[k - 1]
```

",,
"```python
def findMedian(grid: List[List[int]]) -> int:
    m, n = len(grid), len(grid[0])
    low, high = 1, 1_000_000

    while low < high:
        mid = low + (high - low) // 2
        count = sum(bisect_right(row, mid) for row in grid)

        if count < (m * n) // 2 + 1:
            low = mid + 1
        else:
            high = mid

    return low
```

",,
"```python
from bisect import bisect

def maxSizeSubsequenceSumQueries(nums, queries):
    nums.sort()
    prefixSums = [0] * (len(nums) + 1)
    for i, x in enumerate(nums):
        prefixSums[i + 1] = prefixSums[i] + x

    answer = []
    for q in queries:
        idx = bisect(prefixSums, q)
        answer.append(idx - 1)

    return answer
```

",,
"```python
def remove_stars(s: str) -> str:
    result = []
    for c in s:
        if c == '*':
            if result:
                result.pop()
        else:
            result.append(c)
    return ''.join(result)
```


",,
"```python
def min_minutes(garbage: list[str], travel: list[int]) -> int:
    time_garbage = [0, 0, 0]
    time_travel = [0, 0, 0]

    for i, g in enumerate(garbage):
        m, p, g = g.count('M'), g.count('P'), g.count('G')
        time_garbage[0] += m
        time_garbage[1] += p
        time_garbage[2] += g
        if i < len(garbage) - 1:
            time_travel[0] += travel[i]
            time_travel[1] += travel[i]
            time_travel[2] += travel[i]
    
    return sum(time_garbage) + sum(time_travel)
```

",,
"```python
def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:
    row, col = [0] * (k + 1), [0] * (k + 1)
    for condition in row_conditions:
        if row[condition[0]] >= row[condition[1]]:
            return []
        row[condition[1]] = row[condition[0]] + 1
    for condition in col_conditions:
        if col[condition[0]] >= col[condition[1]]:
            return []
        col[condition[1]] = col[condition[0]] + 1
    matrix = [[0] * k for _ in range(k)]
    for i in range(1, k + 1):
        matrix[row[i]][col[i]] = i
    return matrix
```


",,
"```python
def num_strictly_increasing_subarrays(nums):
    n = len(nums)
    count = 0
    sum = 0
    for i in range(1, n):
        if nums[i] > nums[i - 1]:
            count += 1
        else:
            count = 0
        sum += count
    return sum + n
```

",,
"```python
def equal_sum_subarrays(nums):
    sums = set()
    for i in range(1, len(nums)):
        current_sum = nums[i] + nums[i - 1]
        if current_sum in sums:
            return True
        sums.add(current_sum)
    return False
```

",,
"```python
def is_palindrome(s: str) -> bool:
    return s == s[::-1]

def to_base_str(n: int, base: int) -> str:
    s = []
    while n > 0:
        s.append(str(n % base))
        n //= base
    return """".join(reversed(s))

def is_strictly_palindromic(n: int) -> bool:
    for b in range(2, n - 1):
        if not is_palindrome(to_base_str(n, b)):
            return False
    return True
```

",,
"```python
def max_covered_rows(matrix, num_select):
    m, n = len(matrix), len(matrix[0])
    max_covered = 0
    for i in range(1 << n):
        if bin(i).count('1') == num_select:
            covered = 0
            for row in range(m):
                for col in range(n):
                    if matrix[row][col] == 1 and i & (1 << col):
                        covered += 1
                        break
            max_covered = max(max_covered, covered)
    return max_covered
```

",,
"```python
def max_consecutive_robots(charge_times, running_costs, budget):
    n = len(charge_times)
    max_robots = 0
    for i in range(n):
        max_charge = 0
        running_sum = 0
        for j in range(i, n):
            max_charge = max(max_charge, charge_times[j])
            running_sum += running_costs[j]
            cost = max_charge + running_sum * (j - i + 1)
            if cost <= budget:
                max_robots = max(max_robots, j - i + 1)
            else:
                break
    return max_robots
```

",,
"```python
def well_spaced_string(s: str, distance: List[int]) -> bool:
    first = {}
    for i, c in enumerate(s):
        if c not in first:
            first[c] = i
        else:
            if distance[ord(c) - ord('a')] != i - first[c] - 1:
                return False
    return True
```

",,
"```python
MOD = 10**9 + 7
MAX = 1001

def ways(startPos, endPos, k, dp):
    if k == 0: return 1 if startPos == endPos else 0
    if startPos < 0 or endPos < 0 or startPos >= MAX or endPos >= MAX: return 0
    
    if dp[startPos][k] != -1: return dp[startPos][k]
    
    left = ways(startPos - 1, endPos, k - 1, dp)
    right = ways(startPos + 1, endPos, k - 1, dp)
    
    dp[startPos][k] = (left + right) % MOD
    return dp[startPos][k]

def numberOfWays(startPos, endPos, k):
    dp = [[-1 for _ in range(k + 1)] for _ in range(MAX)]
    return ways(startPos, endPos, k, dp)
```

",,
"```python
def longestNiceSubarray(nums):
    n = len(nums)
    max_len = 1
    for i in range(n):
        mask = 0
        for j in range(i, n):
            mask |= nums[j]
            if mask & (mask - 1) == 0:
                max_len = max(max_len, j - i + 1)
    return max_len
```

",,
"```python
import heapq

def most_visited_room(n, meetings):
    meetings.sort()
    pq = []
    rooms = [0] * n
    
    for start, end in meetings:
        while pq and pq[0][0] <= start:
            _, room = heapq.heappop(pq)
            rooms[room] += 1
        heapq.heappush(pq, (end, len(pq) % n))
    
    return rooms.index(max(rooms))
```

",,
"```python
def min_days(power):
    n = len(power)  
    ans = int(1e9)
    dp = [int(1e9)] * (1 << n)
    dp[0] = 0
     
    sorted_power = sorted(power)

    for i in range(1 << n): 
        power_sum = sum(sorted_power[j] for j in range(n) if i & (1 << j)) 
        gain = 1 + bin(i).count('1')

        for j in range(n):
            if not i & (1 << j) and gain > sorted_power[j]:
                dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + 1)

    return dp[(1 << n) - 1]
```

",,
"```python
def most_frequent_even(nums):
    count = {}
    for num in nums:
        if num % 2 == 0:
            count[num] = count.get(num, 0) + 1
    max_count = float('-inf')
    most_frequent = -1
    for num, freq in count.items():
        if freq > max_count or (freq == max_count and num < most_frequent):
            max_count = freq
            most_frequent = num
    return most_frequent
```


",,
"```python
def min_substrs(s: str) -> int:
    seen = set()
    count = 0
    for c in s:
        if c in seen:
            count += 1
            seen.clear()
        seen.add(c)
    return count + int(bool(seen))
```

",,
"```python
import heapq

def min_groups(intervals):
    intervals.sort()
    pq = []
    for interval in intervals:
        if pq and pq[0] < interval[0]:
            heapq.heappop(pq)
        heapq.heappush(pq, interval[1])
    return len(pq)
```

",,
"```python
def longestSubsequence(nums, k):
    n = len(nums)
    dp = {}
    ans = 0

    for num in nums:
        temp = 0
        keys = [key for key in dp if num - k <= key]
        if keys:
            temp = dp[max(keys)]

        dp[num] = max(dp.get(num, 0), temp + 1)
        ans = max(ans, dp[num])

    return ans
```

",,
"```python
class SQL:
    def __init__(self, names: List[str], columns: List[int]):
        self.tables = {name: Table(columns[i]) for i, name in enumerate(names)}

    def insertRow(self, name: str, row: List[str]) -> None:
        self.tables[name].insertRow(row)

    def deleteRow(self, name: str, rowId: int) -> None:
        self.tables[name].deleteRow(rowId)

    def selectCell(self, name: str, rowId: int, columnId: int) -> str:
        return self.tables[name].selectCell(rowId, columnId)


class Table:
    def __init__(self, columns: int):
        self.next_id = 1
        self.rows = []
        self.num_columns = columns

    def insertRow(self, row: List[str]) -> None:
        self.rows.append([self.next_id, row])
        self.next_id += 1

    def deleteRow(self, rowId: int) -> None:
        self.rows = [row for row in self.rows if row[0] != rowId]

    def selectCell(self, rowId: int, columnId: int) -> str:
        for row in self.rows:
            if row[0] == rowId:
                return row[1][columnId - 1]
```

",,
"```python
def days_together(arrive_alice, leave_alice, arrive_bob, leave_bob):
    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def date_to_days(date):
        month, day = map(int, date.split('-'))
        return sum(days_in_month[:month]) + day

    arrive_days_alice = date_to_days(arrive_alice)
    leave_days_alice = date_to_days(leave_alice)
    arrive_days_bob = date_to_days(arrive_bob)
    leave_days_bob = date_to_days(leave_bob)

    common_start_date = max(arrive_days_alice, arrive_days_bob)
    common_end_date = min(leave_days_alice, leave_days_bob)

    return max(0, common_end_date - common_start_date + 1)
```

",,
"```python
def max_matchings(players, trainers):
    players.sort()
    trainers.sort()

    player_index, trainer_index, match_count = 0, 0, 0
    while (player_index < len(players)) and (trainer_index < len(trainers)):
        if players[player_index] <= trainers[trainer_index]:
            match_count += 1
            player_index += 1
            trainer_index += 1
        else:
            trainer_index += 1

    return match_count
```


",,
"```python
def minSizeMaxBitwiseOR(nums):
    n = len(nums)
    answer = [0] * n
    orSum = 0

    i, j = 0, 0
    while i < n:
        orSum |= nums[i]
        while (orSum | nums[j]) == orSum:
            orSum ^= nums[j]
            j += 1

        answer[i] = i - j + 2
        i += 1

    return answer
```

",,
"```python
def min_money(transactions):
    min_money_needed = 0
    for transaction in transactions:
        min_money_needed = max(min_money_needed, transaction[0] - transaction[1])
    return min_money_needed
```

",,
"```python
def smallest_multiple(n):
    return n if n % 2 == 0 else n * 2
```

",,
"```python
def longest_alphabetical_continuous_substring(s: str) -> int:
    max_length = current_length = 1
    for i in range(1, len(s)):
        if ord(s[i]) == ord(s[i - 1]) + 1:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    return max(max_length, current_length)
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def reverse_odd_levels(node, level):
    if node is None: return
    if level % 2 == 1:
        node.left, node.right = node.right, node.left
    reverse_odd_levels(node.left, level + 1)
    reverse_odd_levels(node.right, level + 1)

def reverse_odd_level_nodes(root):
    reverse_odd_levels(root, 0)
    return root
```

",,
"```python
from collections import defaultdict

def prefix_score_sum(words):
    result = [0] * len(words)
    prefix_count = defaultdict(int)
    
    for word in words:
        prefix = """"
        for c in word:
            prefix += c
            prefix_count[prefix] += 1
    
    for i, word in enumerate(words):
        prefix = """"
        for c in word:
            prefix += c
            result[i] += prefix_count[prefix]
    
    return result
```

",,
"```python
def smallest_fair_number(n):
    while True:
        k = n
        even = 0
        odd = 0
        while k > 0:
            if k % 2 == 0:
                even += 1
            else:
                odd += 1
            k //= 10
        if even == odd:
            return n
        n += 1
```

",,
"```python
def sort_names_by_height(names, heights):
    name_height_pairs = sorted(zip(heights, names), reverse=True)
    sorted_names = [pair[1] for pair in name_height_pairs]
    return sorted_names
```

",,
"```python
def longestSubarray(nums):
    max_and = 0
    for i in range(len(nums)):
        temp_and = nums[i]
        for j in range(i + 1, len(nums)):
            temp_and &= nums[j]
            max_and = max(max_and, temp_and)
    
    longest_subarray = 0
    current_length = 0
    for i in range(len(nums)):
        temp_and = nums[i]
        current_length = 1 if temp_and == max_and else 0
        for j in range(i + 1, len(nums)):
            temp_and &= nums[j];
            if temp_and == max_and:
                current_length += 1
            else:
                break
        longest_subarray = max(longest_subarray, current_length)
    return longest_subarray
```

",,
"```python
def find_good_indices(nums, k):
    good_indices = []
    for i in range(k, len(nums) - k):
        left_non_inc = all(nums[i - j - 1] >= nums[i - j - 2] for j in range(k - 1))
        right_non_dec = all(nums[i + j + 1] >= nums[i + j + 2] for j in range(k - 1))

        if left_non_inc and right_non_dec:
            good_indices.append(i)

    return good_indices
```
",,
"```python
from collections import defaultdict

def dfs(node, parent, adj, vals, cur_max, count):
    if vals[node] >= cur_max:
        if vals[node] > cur_max:
            count[0] += 1
            cur_max = vals[node]
        for next in adj[node]:
            if next != parent:
                dfs(next, node, adj, vals, cur_max, count)

def number_of_good_paths(vals, edges):
    n = len(vals)
    adj = defaultdict(list)
    for edge in edges:
        adj[edge[0]].append(edge[1])
        adj[edge[1]].append(edge[0])
    count = [0]
    for i in range(n):
        dfs(i, -1, adj, vals, -1, count)
    return count[0]
```

",,
"```python
def minOperations(nums):
    n = len(nums)
    i, j = 0, n - 1
    operations = 0

    while i < j:
        if nums[i] == nums[j]:
            i += 1
            j -= 1
        elif nums[i] < nums[j]:
            nums[i + 1] += nums[i]
            i += 1
            operations += 1
        else:
            nums[j - 1] += nums[j]
            j -= 1
            operations += 1

    return operations
```

",,
"```python
def can_equal_frequency(word: str) -> bool:
    freq = {}
    for c in word:
        freq[c] = freq.get(c, 0) + 1

    count_freq = {}
    for f in freq.values():
        count_freq[f] = count_freq.get(f, 0) + 1

    if len(count_freq) != 2:
        return False

    a, acount = next(iter(count_freq.items()))
    b, bcount = next(reversed(list(count_freq.items())))

    return (acount == 1 and (a - 1 == b or a == 1)) or (bcount == 1 and (b - 1 == a or b == 1))
```

",,
"```python
class LUPrefix:
    def __init__(self, n: int):
        self.max_prefix_length = 0
        self.next_video = 1
        self.uploaded = [False] * (n + 1)

    def upload(self, video: int) -> None:
        self.uploaded[video] = True
        if video == self.next_video:
            while self.uploaded[self.next_video]:
                self.next_video += 1

    def longest(self) -> int:
        return self.next_video - 1
```

",,
"```python
def get_xor(nums1, nums2):
    xor_result = 0
    for num1 in nums1:
        for num2 in nums2:
            xor_result ^= (num1 ^ num2)
    return xor_result
```

",,
"```python
def count_pairs(nums1, nums2, diff):
    n = len(nums1)
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:
                count += 1
    return count
```

",,
"```python
def common_factors(a: int, b: int) -> int:
    from math import gcd

    g = gcd(a, b)
    count = 0
    for i in range(1, int(g**0.5) + 1):
        if g % i == 0:
            count += 1
            if i * i != g:
                count += 1
    return count
```

",,
"```python
def max_hourglass_sum(grid):
    m, n = len(grid), len(grid[0])
    max_sum = float('-inf')
    for i in range(1, m - 1):
        for j in range(1, n - 1):
            sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] \
                  + grid[i][j] \
                  + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]
            max_sum = max(max_sum, sum)
    return max_sum
```


",,
"```python
def minSetXor(num1: int, num2: int) -> int:
    set_count = bin(num2).count('1')
    x = 0
    for i in range(32):
        if set_count <= 0:
            break
        if num2 & (1 << i):
            x |= (1 << i)
            set_count -= 1
    return x ^ num1
```

",,
"```python
def maxOperations(s: str) -> int:
    count = 0
    while s:
        for i in range(len(s) // 2, 0, -1):
            if s[:i] == s[i:2*i]:
                s = s[i:]
                count += 1
                break
            elif i == 1:
                s = s[1:]
                count += 1
    return count
```

",,
"```python
def maxTastiness(price, tastiness, maxAmount, maxCoupons):
    n = len(price)
    dp = [[[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        fruit_price = price[i - 1]
        fruit_tastiness = tastiness[i - 1]
        half_fruit_price = fruit_price // 2
        
        for j in range(maxAmount + 1):
            for k in range(maxCoupons + 1):
                dp[i][j][k] = dp[i - 1][j][k]
                if j >= fruit_price:
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)
                if k > 0 and j >= half_fruit_price:
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)

    return dp[n][maxAmount][maxCoupons]
```


",,
"```python
def worker_with_longest_task(n, logs):
    result = 0
    max_time = logs[0][1] - 0

    for i in range(1, len(logs)):
        time = logs[i][1] - logs[i-1][1]
        if time > max_time:
            max_time = time
            result = logs[i][0]

    return result
```

",,
"```python
def findArray(pref):
    arr = [pref[0]]
    for i in range(1, len(pref)):
        arr.append(pref[i] ^ pref[i - 1])
    return arr
```

",,
"```python
def robot_sort(s):
    t = []
    for c in s:
        while t and t[-1] <= c:
            t.pop()
        t.append(c)
    return ''.join(t)
```

",,
"```python
def ways(grid, m, n, i, j, k, sum, dp):
    if i == m - 1 and j == n - 1:
        return 1 if (sum + grid[i][j]) % k == 0 else 0
    if dp[i][j][sum] == -1:
        ans = 0
        if i + 1 < m:
            ans = (ans + ways(grid, m, n, i + 1, j, k, (sum + grid[i][j]) % k, dp)) % 1000000007
        if j + 1 < n:
            ans = (ans + ways(grid, m, n, i, j + 1, k, (sum + grid[i][j]) % k, dp)) % 1000000007
        dp[i][j][sum] = ans
    return dp[i][j][sum]

def waysToReachDivisibleSum(grid, k):
    m, n = len(grid), len(grid[0])
    dp = [[[-1] * k for _ in range(n)] for _ in range(m)]
    return ways(grid, m, n, 0, 0, k, 0, dp)
```


",,
"```python
def min_arrays(nums):
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    total_gcd = nums[0]
    for num in nums[1:]:
        total_gcd = gcd(total_gcd, num)
    
    return 2 if total_gcd == 1 else 1
```

",,
"```python
def count_valid_times(time: str) -> int:
    count = 1
    if time[0] == '?':
        count *= 3 if time[1] == '?' or time[1] < '4' else 2
    if time[1] == '?':
        count *= 4 if time[0] == '2' else 10
    if time[3] == '?':
        count *= 6
    if time[4] == '?':
        count *= 10
    return count
```


",,
"```python
def getPowers(n):
    powers = []
    while n > 0:
        powers.append(n & (-n))
        n -= n & (-n)
    return powers

def productOfPowers(n, queries):
    powers = getPowers(n)
    answers = []

    mod = 10**9 + 7

    for query in queries:
        product = 1
        for i in range(query[0], query[1] + 1):
            product = (product * powers[i]) % mod
        answers.append(product)

    return answers
```

",,
"```python
def find_min_maximum_value(nums):
    result = nums[0]
    total_sum = nums[0]
    for i in range(1, len(nums)):
        total_sum += nums[i]
        result = max(result, (total_sum + i) // (i + 1))
    return result
```

",,
"```python
from collections import defaultdict

def dfs(node, parent, nums, graph, total, result):
    total_sum = nums[node]
    for neighbor in graph[node]:
        if neighbor != parent:
            total_sum += dfs(neighbor, node, nums, graph, total, result)
    if total_sum == total // 2:
        result.append(1)
        return 0
    return total_sum

def delete_edges_to_balance_tree(nums, edges):
    n = len(nums)
    graph = defaultdict(list)
    for e in edges:
        graph[e[0]].append(e[1])
        graph[e[1]].append(e[0])

    total = sum(nums)
    if total % 2 != 0:
        return 0  # It is impossible to split the tree fairly.

    result = []
    dfs(0, -1, nums, graph, total, result)
    return len(result) - 1
```

",,
"```python
def find_K(nums):
    s = set(nums)
    k = -1
    for num in nums:
        if -num in s:
            k = max(k, abs(num))
    return k
```


",,
"```python
def distinct_integers_after_reversing_and_adding(nums):
    distinct = set(nums)
    for num in nums:
        reversed_num = int(str(num)[::-1])
        distinct.add(reversed_num)
    return len(distinct)
```

",,
"```python
def sum_with_reverse(num: int) -> bool:
    for i in range(num + 1):
        reverse = int(str(i)[::-1])
        if i + reverse == num:
            return True
    return False
```

",,
"```python
def fixed_bound_subarrays(nums, minK, maxK):
    count, min_index, max_index = 0, -1, -1
    for i, num in enumerate(nums):
        if num==minK:
            min_index=i
        elif num==maxK:
            max_index=i
        
        count += min(min_index, max_index) + 1
    return count
```

",,
"```python
def flip_trees(n, queries):
    flipped_nodes = {}
    for query in queries:
        flipped_nodes[query] = not flipped_nodes.get(query, False)
        while query > 1:
            query //= 2
            flipped_nodes[query] = not flipped_nodes.get(query, False)

    count = 0
    for value in flipped_nodes.values():
        if value:
            count += 1

    return count
```

",,
"```python
def has_event_conflict(start1: str, end1: str, start2: str, end2: str) -> bool:
    start_hour1, start_min1 = map(int, start1.split("":""))
    start_hour2, start_min2 = map(int, start2.split("":""))
    end_hour1, end_min1 = map(int, end1.split("":""))
    end_hour2, end_min2 = map(int, end2.split("":""))

    total_min1_start = start_hour1 * 60 + start_min1
    total_min1_end = end_hour1 * 60 + end_min1
    total_min2_start = start_hour2 * 60 + start_min2
    total_min2_end = end_hour2 * 60 + end_min2

    return not (total_min1_end <= total_min2_start or total_min1_start >= total_min2_end)
```

",,
"```python
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def count_GCD_subarrays(nums, k):
    count = 0

    for i in range(len(nums)):
        gcd_so_far = 0
        for j in range(i, len(nums)):
            gcd_so_far = gcd(gcd_so_far, nums[j])
            if gcd_so_far == k:
                count += 1

    return count
```

",,
"```python
def minCost(nums, cost):
    ans = float(""inf"")
    base = min(nums)
    
    for target in range(base, base + 2):
        local_res = 0
        for i in range(len(nums)):
            local_res += abs(nums[i] - target) * cost[i]
        ans = min(ans, local_res)
    
    return ans
```

",,
"```python
def minOperations(nums, target):
    n = len(nums)
    sum_nums = sum(nums)
    sum_target = sum(target)
    diff = (sum_target - sum_nums) // 2
    cnt = 0
    for i in range(n):
        if nums[i] > target[i]:
            cnt += (nums[i] - target[i] - diff) // 2
    return cnt
```


",,
"```python
def distinctStrings(s, k):
    n = len(s)
    cnt = 0
    st = set()

    for i in range(n - k + 1):
        temp = s[:i] + s[i + k:]
        if temp not in st:
            st.add(temp)
            cnt = (cnt + 1) % 1000000007

    return cnt + 1 # Add 1 for the original string
```

",,
"```python
def stringWithDifferentDifference(words):
    def get_difference_array(word):
        return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)]

    diffArrays = [get_difference_array(word) for word in words]
    
    oddArrayIndex = -1
    for i in range(1, len(diffArrays)):
        matchCount = sum(diffArrays[0][j] == diffArrays[i][j] for j in range(len(diffArrays[i])))
        if matchCount == 0:
            oddArrayIndex = i
            break

    return words[oddArrayIndex]
```

",,
"```python
def count_differences(a, b):
    return sum(c1 != c2 for c1, c2 in zip(a, b))

def find_matching_words(queries, dictionary):
    result = []
    for query in queries:
        for dict_word in dictionary:
            if count_differences(query, dict_word) <= 2:
                result.append(query)
                break
    return result
```


",,
"```python
def minSeededValue(nums, space):
    count = {}
    for num in nums:
        count[num % space] = count.get(num % space, 0) + 1
    return max(count, key=lambda x: (count[x], -x))
```

",,
"```python
def find_second_greater(nums):
    n = len(nums)
    answer = [-1] * n
    for i in range(n):
        k = -1
        for j in range(i + 1, n):
            if nums[j] > nums[i]:
                if k == -1:
                    k = j
                else:
                    answer[i] = nums[j]
                    break
    return answer
```

",,
"```python
def average_even_divisible_by_three(nums):
    total = 0
    count = 0
    for num in nums:
        if num % 2 == 0 and num % 3 == 0:
            total += num
            count += 1
    return total // count if count > 0 else 0
```

",,
"```python
from collections import defaultdict

def highest_popularity(creators, ids, views):
    popularity = defaultdict(int)
    most_viewed = {}

    for i in range(len(creators)):
        popularity[creators[i]] += views[i]
        if creators[i] not in most_viewed or views[i] > most_viewed[creators[i]][1] or (views[i] == most_viewed[creators[i]][1] and ids[i] < most_viewed[creators[i]][0]):
            most_viewed[creators[i]] = (ids[i], views[i])

    max_popularity = max(popularity.values())

    return [[creator, most_viewed[creator][0]] for creator, pop in popularity.items() if pop == max_popularity]
```

",,
"```python
def digit_sum(n):
    return sum(int(digit) for digit in str(n))

def minimum_beautiful(n, target):
    x = 0
    while digit_sum(n + x) > target:
        x += 1
    return x
```

",,
"```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x: int):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def removeSubtrees(self, root: TreeNode, queries: List[int]) -> List[int]:
        def removeSubtree(node: TreeNode, val: int):
            if not node: return

            if node.left and node.left.val == val:
                node.left = None
            else:
                removeSubtree(node.left, val)

            if node.right and node.right.val == val:
                node.right = None
            else:
                removeSubtree(node.right, val)

        def findHeight(node: TreeNode) -> int:
            if not node: return -1

            return 1 + max(findHeight(node.left), findHeight(node.right))

        answer = []
        for query in queries:
            removeSubtree(root, query)
            answer.append(findHeight(root))

        return answer
```

",,
"```python
def min_operations(nums):
    n = len(nums)
    idx0 = -1

    for i in range(n):
        if nums[i] == 0:
            idx0 = i
            break

    cnt1 = 0
    cnt2 = 0

    for i in range(1, n):
        if abs(nums[i] - nums[i - 1]) != 1:
            cnt1 += abs(nums[i] - nums[i - 1]) - 1

    for i in range(idx0 + 1, n):
        if nums[i] < nums[i - 1]:
            cnt2 += 1

    return min(cnt1, cnt2)
```

",,
"```python
def performOps(nums):
    n = len(nums)
    for i in range(n - 1):
        if nums[i] == nums[i + 1]:
            nums[i] *= 2
            nums[i + 1] = 0
    nonZeroIndex = 0
    for i in range(n):
        if nums[i] != 0:
            nums[nonZeroIndex] = nums[i]
            nonZeroIndex += 1
    while(nonZeroIndex < n):
        nums[nonZeroIndex] = 0
        nonZeroIndex += 1
    return nums
```

",,
"```python
def maxSubarraySumWithDistinctElements(nums: List[int], k: int) -> int:
    max_sum = 0
    window_sum = 0
    freq_map = collections.defaultdict(int)
    
    for i, num in enumerate(nums):
        freq_map[num] += 1
        window_sum += num
        if i >= k:
            freq_map[nums[i - k]] -= 1
            window_sum -= nums[i - k]
        if i >= k - 1:
            is_distinct = all(value <= 1 for value in freq_map.values())
            if is_distinct:
                max_sum = max(max_sum, window_sum)
    
    return max_sum
```

",,
"```python
def hireWorkers(costs, k, candidates):
    n = len(costs)
    workers = sorted([(cost, i) for i, cost in enumerate(costs)])

    cost = 0
    for i in range(k):
        if min(workers[i][1], n - workers[i][1] - 1) < candidates:
            cost += workers[i][0]

    return cost
```

",,
"```python
def min_total_distance(robot: List[int], factory: List[List[int]]) -> int:
    robot.sort()
    factory.sort()

    res = 0
    idx = 0
    for f_pos, f_limit in factory:
        while f_limit > 0 and idx < len(robot):
            res += abs(f_pos - robot[idx])
            idx += 1
            f_limit -= 1
    
    return res
```

",,
"```python
from math import gcd

def min_valid_subarrays(nums):
    count = 0
    while nums:
        for i in range(len(nums)):
            if gcd(nums[i], nums[-1]) > 1:
                break
        else:
            count += 1
            nums.pop()
    return count if count > 0 else -1
```

",,
"```python
def distinctAverages(nums):
    averages = set()
    nums.sort()
    n = len(nums)
    for i in range(n // 2):
        averages.add((nums[i] + nums[n - 1 - i]) / 2.0)
    return len(averages)
```

",,
"```python
def modPow(x, n, mod):
    res = 1
    while n > 0:
        if n % 2 == 1:
            res = (res * x) % mod
        x = (x * x) % mod
        n //= 2
    return res

def goodStrings(low, high, zero, one):
    mod = 1000000007
    good_strs = ((modPow(2, high, mod) - modPow(2, low - 1, mod) + 1) * (zero + 1)) % mod
    return (good_strs * (one + 1)) % mod
```


",,
"```python
from collections import defaultdict

def dfs(node, parent, bob, time, alice_income, res, amount, tree):
    if time < bob or amount[node] >= 0:
        alice_income += amount[node]
    else:
        alice_income += amount[node] // 2
    amount[node] = 0
    is_leaf = True
    for child in tree[node]:
        if child != parent:
            is_leaf = False
            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)
    if is_leaf:
        res[0] = max(res[0], alice_income)

def maxNetIncome(edges, bob, amount):
    tree = defaultdict(list)
    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])
    res = [-100000]
    dfs(0, -1, bob, 0, 0, res, amount, tree)
    return res[0]
```


",,
"```python
def split_message(message: str, limit: int) -> list[str]:
    n = len(message)
    a = (limit - 3) * (n // (limit - 3)) - n
    b = n // (limit - 3)
    if (n + b + a) % (limit - 2) != 0:
        return []
    num_parts = (n + b + a) // (limit - 2)
    result = []
    i = k = cnt = 0
    while i < n or k < num_parts:
        temp = []
        while cnt < limit - 3:
            cnt += 1
            temp.append(message[i])
            i += 1
            if i == n: break
        cnt = 0
        temp.append(str(k+1) + ""/"" + str(num_parts) + "" "")
        k += 1
        result.append("""".join(temp))
    return result
```

",,
"```python
def convert_temperature(celsius):
    kelvin = celsius + 273.15
    fahrenheit = celsius * 1.8 + 32
    return [kelvin, fahrenheit]
```

",,
"```python
def count_lcm_subarrays(nums: List[int], k: int) -> int:
    def lcm(a, b):
        temp = a
        while temp % b != 0:
            temp += a
        return temp

    count = 0
    for i in range(len(nums)):
        curr_lcm = nums[i]
        for j in range(i, len(nums)):
            curr_lcm = lcm(curr_lcm, nums[j])
            if curr_lcm == k:
                count += 1

    return count
```

",,
"```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def minSwaps(root: TreeNode) -> int:
    count = 0
    que = deque([(root, 0)])

    level_vals = []
    prev_depth = -1

    while que:
        node, depth = que.popleft()

        if prev_depth != depth:
            level_vals.sort()
            for i in range(1, len(level_vals)):
                count += abs(level_vals[i] - level_vals[i-1]) - 1
            prev_depth = depth
            level_vals.clear()
        level_vals.append(node.val)

        if node.left:
            que.append((node.left, depth + 1))
        if node.right:
            que.append((node.right, depth + 1))

    level_vals.sort()
    for i in range(1, len(level_vals)):
        count += abs(level_vals[i] - level_vals[i-1]) - 1

    return count
```

",,
"```python
def maxPalindromesSubstrings(s, k):
    n = len(s)
    if n < k:
        return 0
    count = 0
    dp = [[False] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        for j in range(i, n):
            if i == j:
                dp[i][j] = True
            elif s[i] == s[j]:
                dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]
            else:
                dp[i][j] = False
            if j - i + 1 >= k and dp[i][j]:
                count += 1
                i = j
                break
    return count
```

",,
"```python
from heapq import heappush, heappop

def minTotalCost(n, roads, appleCost, k):
    graph = [[] for _ in range(n+1)]
    for u, v, cost in roads:
        graph[u].append((v, cost))
        graph[v].append((u, cost))

    answer = [0] * n
    for start in range(1, n+1):
        pq = [(0, start)]
        dist = [float('inf')] * (n + 1)
        dist[start] = 0

        while pq:
            d, u = heappop(pq)

            if d > dist[u]:
                continue

            for v, cost in graph[u]:
                c = d + cost + (0 if u == start else cost * k) + appleCost[v - 1]
                if c < dist[v]:
                    dist[v] = c
                    heappush(pq, (c, v))

        answer[start-1] = dist[start]
    return answer
```


",,
"```python
def countTriplets(nums):
    count = 0
    n = len(nums)
    
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:
                    count += 1
    
    return count
```

",,
"```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findMinMax(root, queries):
    if not root:
        return []

    ans = [[-1, -1] for _ in range(len(queries))]
    for i in range(len(queries)):
        node = root
        query = queries[i]
        while node:
            if node.val < query:
                ans[i][0] = node.val
                node = node.right
            else:
                ans[i][1] = node.val
                if node.val == query:
                    ans[i][0] = query
                    break
                node = node.left
    return ans
```

",,
"```python
from collections import defaultdict, deque


def min_fuel(roads, seats):
    n = len(roads) + 1
    graph = defaultdict(list)
    for road in roads:
        graph[road[0]].append(road[1])
        graph[road[1]].append(road[0])

    distance = [-1] * n
    q = deque([0])
    distance[0] = 0

    while q:
        city = q.popleft()
        for neighbor in graph[city]:
            if distance[neighbor] == -1:
                distance[neighbor] = distance[city] + 1
                q.append(neighbor)

    total_fuel = 0
    for city in range(1, n):
        total_fuel += (distance[city] - 1) // (seats - 1) + 1
    return total_fuel
```

",,
"```python
def numBeautifulPartitions(s: str, k: int, minLength: int) -> int:
    MOD = 10**9 + 7
    primes = {'2', '3', '5', '7'}
    n = len(s)
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
        for j in range(1, k + 1):
            for l in range(minLength, i + 1):
                if i - l >= j - 1 and s[i - l] in primes and s[i - 1] not in primes:
                    dp[i][j] += dp[i - l][j - 1]
                    if dp[i][j] >= MOD:
                        dp[i][j] -= MOD
                        
    return dp[n][k]
```


",,
"```python
from collections import defaultdict

def maxXorSubtree(n, edges, values):
    tree = defaultdict(list)

    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])

    first_max = [0]
    root_sum = dfs(0, -1, tree, values, first_max)

    return root_sum ^ first_max[0]

def dfs(node, parent, tree, values, first_max):
    current_sum = values[node]

    for child in tree[node]:
        if child != parent:
            current_sum ^= dfs(child, node, tree, values, first_max)

    first_max[0] = max(first_max[0], current_sum)

    return current_sum
```

",,
"```python
def min_cuts(n):
    if n % 2 == 0:
        return n // 2
    else:
        return n
```


",,
"```python
def create_difference_matrix(grid):
    m, n = len(grid), len(grid[0])
    ones_row, ones_col = [0] * m, [0] * n
    diff = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            ones_row[i] += grid[i][j]
            ones_col[j] += grid[i][j]

    for i in range(m):
        for j in range(n):
            diff[i][j] = ones_row[i] + ones_col[j] - (n - ones_row[i]) - (m - ones_col[j])

    return diff
```

",,
"```python
def min_penalty(customers: str) -> int:
    n = len(customers)
    open_penalty, closed_penalty = 0, 0

    for c in customers:
        if c == 'N':
            open_penalty += 1
        else:
            closed_penalty += 1

    result = closed_penalty
    penalty = closed_penalty

    for c in customers:
        if c == 'N':
            penalty -= 1
        else:
            penalty += 1

        result = min(result, penalty)

    return result
```


",,
"```python
def palindrome_subsequence(s):
    n = len(s)
    mod = 1000000007
    dp = [[0] * n for _ in range(10)]
    for i in range(n): dp[int(s[i])][i] = 1
    for len_ in range(1, 5):
        for d in range(10):
            for i, j in zip(range(n - len_), range(len_, n)):
                dp[d][j] = (dp[d][j - 1] + (1 if s[j] == str(d) else 0)) % mod
    ans = 0
    for d1 in range(10):
        for d2 in range(10):
            ans += dp[d1][n - 5] * dp[d2][n - 1] % mod
    return ans % mod
```

",,
"```python
def find_pivot(n: int) -> int:
    total = n * (n + 1) // 2
    left_sum = 0
    for x in range(1, n + 1):
        left_sum += x
        if 2 * left_sum == total:
            return x
    return -1
```

",,
"```python
def min_addition(s: str, t: str) -> int:
    s_len = len(s)
    t_len = len(t)
    i, j = 0, 0
    while i < s_len and j < t_len:
        if s[i] == t[j]:
            j += 1
        i += 1
    return t_len - j
```

",,
"```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNodes(head):
    if not head: return None
    maxNode = head
    currentNode = head
    prevNode = None

    while currentNode and currentNode.next:
        if currentNode.next.val > maxNode.val:
            if prevNode: prevNode.next = currentNode.next
            else: head = currentNode.next
            maxNode = currentNode.next
        else:
            prevNode = currentNode
        currentNode = currentNode.next
    maxNode.next = removeNodes(maxNode.next)
    return head
```

",,
"```python
def count_subarrays_with_median(nums, k):
    ans = 0
    for left in range(len(nums)):
        count = 0
        subarray = []
        for right in range(left, len(nums)):
            count += nums[right] == k
            subarray.insert((nums[right], nums[right]), nums[right:index + 1])
            if len(subarray) % 2 and subarray[len(subarray) // 2] == k:
                ans += count
    return ans
```

",,
"```python
def ratio_substring_count(s: str, num1: int, num2: int) -> int:
    count0, count1 = 0, 0
    frequency = {0: 1}
    result = 0

    for c in s:
        if c == '0':
            count0 += 1
        else:
            count1 += 1

        curr_diff = count0 * num2 - count1 * num1
        result += frequency.get(curr_diff, 0)
        frequency[curr_diff] = frequency.get(curr_diff, 0) + 1

    return result
```


",,
"```python
def is_circular(sentence: str) -> bool:
    words = sentence.split()
    for i in range(1, len(words)):
        if words[i - 1][-1] != words[i][0]:
            return False
    return words[-1][-1] == words[0][0]
```

",,
"```python
def maximumChemistry(skill):
    total_sum = sum(skill)
    target_sum = total_sum // 2
    if total_sum % 2 == 1:
        return -1

    dp = {0: 1}
    max_chemistry = 0

    for s in skill:
        for i in range(target_sum - s, -1, -1):
            if i in dp:
                dp[i + s] = dp.get(i + s, 0) + dp[i]
                if i + s == target_sum:
                    max_chemistry += dp[i] * s

    return max_chemistry if max_chemistry > 0 else -1
```


",,
"```python
from heapq import heappush, heappop
from collections import defaultdict

def minimumScore(n, roads):
    adj = defaultdict(list)
    for road in roads:
        adj[road[0]].append((road[1], road[2]))
        adj[road[1]].append((road[0], road[2]))

    INF = int(1e9)
    pq = [(0, 1)]

    minDist = [INF] * (n + 1)
    while pq:
        curDist, curCity = heappop(pq)

        if curCity == n:
            return curDist

        if curDist < minDist[curCity]:
            minDist[curCity] = curDist
            for nextCity, nextDist in adj[curCity]:
                candidate_dist = max(curDist, nextDist)
                if candidate_dist < minDist[nextCity]:
                    heappush(pq, (candidate_dist, nextCity))

    return -1
```


",,
"```python
from collections import defaultdict, deque

def maxGroups(n, edges):
    graph = defaultdict(list)
    color = [0] * (n + 1)

    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])

    max_group = 0
    for i in range(1, n + 1):
        if color[i] == 0:
            q = deque([i])
            color[i] = 1
            while q:
                node = q.popleft()
                max_group = max(max_group, color[node])
                for neighbor in graph[node]:
                    if color[neighbor] == 0:
                        color[neighbor] = color[node] + 1
                        q.append(neighbor)
                    elif color[neighbor] == color[node]:
                        return -1
                        
    return max_group
```


",,
"```python
def numberOfEvenSubarrays(nums):
    n = len(nums)
    evenCount, oddCount, result = 0, 0, 0

    for num in nums:
        if num % 2 == 0:
            evenCount += 1
            result += evenCount
        else:
            evenCount, oddCount = oddCount, evenCount
            oddCount += 1
            result += oddCount

    return result
```

",,
"```python
def maxValue(strs) -> int:
    max_value = 0
    for str in strs:
        if str.isdigit():
            value = int(str)
        else:
            value = len(str)
        max_value = max(max_value, value)
    return max_value
```

",,
"```python
def max_star_sum(vals, edges, k):
    adj = [[] for _ in range(len(vals))]

    for edge in edges:
        adj[edge[0]].append(vals[edge[1]])
        adj[edge[1]].append(vals[edge[0]])

    ans = float(""-inf"")
    for i in range(len(vals)):
        adj[i].sort(reverse=True)
        ans = max(ans, vals[i] + sum(adj[i][:k]))

    return ans
```

",,
"```python
def minimum_path_cost(stones):
    n = len(stones)
    max_cost = stones[n-1]
    for i in range(1, n-1):
        max_cost = min(max_cost, max(stones[i], stones[n-1]-stones[i]))
    return max_cost
```

",,
"```python
def min_cost(nums1: List[int], nums2: List[int]) -> int:
    value_to_indices = {}
    for i, val in enumerate(nums1):
        value_to_indices.setdefault(val, []).append(i)

    result = 0
    for val in nums2:
        if not value_to_indices[val]:
            return -1
        result += value_to_indices[val].pop()

    return result
```


",,
"```python
def maxValueAfterOperations(grid):
    ans = 0
    while grid:
        maxVal = 0
        maxRow = -1

        for i, row in enumerate(grid):
            rowMax = max(row)
            if rowMax > maxVal:
                maxVal = rowMax
                maxRow = i
            grid[i] = [e for e in row if e != rowMax]

        ans += maxVal
        if not grid[maxRow]:
            grid.pop(maxRow)

    return ans
```


",,
"```python
def longest_square_streak(nums):
    num_set = set(nums)
    longest_streak = -1

    for num in num_set:
        streak = 1

        while int(num ** 0.5) in num_set:
            streak += 1
            num = int(num ** 0.5)
        
        longest_streak = max(longest_streak, streak)

    return longest_streak if longest_streak >= 2 else -1
```

",,
"```python
class Allocator:
    def __init__(self, n: int):
        self.mem = [0] * n

    def allocate(self, size: int, mID: int) -> int:
        start, count = -1, 0
        for i in range(len(self.mem) + 1):
            if i < len(self.mem) and self.mem[i] == 0:
                if start == -1:
                    start = i
                count += 1
            else:
                if count >= size:
                    for j in range(start, start + size):
                        self.mem[j] = mID
                    return start
                start, count = -1, 0
        return -1

    def free(self, mID: int) -> int:
        count = 0
        for i in range(len(self.mem)):
            if self.mem[i] == mID:
                count += 1
                self.mem[i] = 0
        return count
```


",,
"```python
from typing import List

def maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:
    m, n = len(grid), len(grid[0])
    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]

    def dfs(x: int, y: int, q: int, visited: set) -> int:
        if 0 <= x < m and 0 <= y < n and grid[x][y] < q and (x, y) not in visited:
            visited.add((x, y))
            points = 1
            for i in range(4):
                nx, ny = x + dx[i], y + dy[i]
                points += dfs(nx, ny, q, visited)
            return points
        return 0

    return [dfs(0, 0, query, set()) for query in queries]
```


",,
"```python
def subsequence_or_sum(nums):
    result = 0
    for num in nums:
        result |= num
    return result
```

",,
"```python
def count_similar_pairs(words):
    count = 0
    for i in range(len(words)):
        for j in range(i + 1, len(words)):
            set1 = set(words[i])
            set2 = set(words[j])
            if set1 == set2:
                count += 1
    return count
```


",,
"```python
def smallestFactorization(n):
    if n <= 3:
        return n
    result, factor = 0, 1
    for i in range(2, 6):
        while n % i == 0:
            result += factor * i
            factor *= 10
            n //= i
    return result if n == 1 else n
```

",,
"```python
from collections import defaultdict

def possible_degree_even(n, edges):
    degrees = defaultdict(int)
    for a, b in edges:
        degrees[a] += 1
        degrees[b] += 1

    odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0)
    return odd_degrees == 0 or odd_degrees == 2
```

",,
"```python
def length_of_cycle(n, queries):
    result = []
    for A, B in queries:
        depth_A, depth_B = 0, 0
        while A != B:
            if A < B:
                A, B = B, A
            A >>= 1
            depth_A += 1
        result.append(depth_A + depth_B)
    return result
```

",,
"```python
def isValidPath(grid, row, col, zeros, ones):
    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):
        return False
    if grid[row][col] == 1:
        ones += 1
    else:
        zeros += 1
    if row == len(grid) - 1 and col == len(grid[0]) - 1:
        return zeros == ones
    return (isValidPath(grid, row + 1, col, zeros, ones)
            or isValidPath(grid, row, col + 1, zeros, ones))

def equalPath(grid):
    return isValidPath(grid, 0, 0, 0, 0)
```


",,
"```python
def max_captured_forts(forts):
    n = len(forts)
    max_capture = 0
    for i in range(n):
        if forts[i] == 1:
            for j in range(i+1, n):
                if forts[j] != -1:
                    capture = sum(1 for k in range(i+1, j) if forts[k] == 0)
                    if forts[j] == 1:
                        max_capture = max(max_capture, capture)
    return max_capture
```


",,
"```python
def top_k_students(positive_feedback, negative_feedback, report, student_id, k):
    points = {}
    for i in range(len(report)):
        pos_count, neg_count = 0, 0
        for pos in positive_feedback:
            pos_index = report[i].find(pos)
            while pos_index != -1:
                pos_count += 1
                pos_index = report[i].find(pos, pos_index + len(pos))
        for neg in negative_feedback:
            neg_index = report[i].find(neg)
            while neg_index != -1:
                neg_count += 1
                neg_index = report[i].find(neg, neg_index + len(neg))
        
        points[student_id[i]] = points.get(student_id[i], 0) + 3 * pos_count - neg_count

    students = sorted(student_id, key=lambda x: (-points[x], x))
    return students[:k]
```


",,
"```python
def minimum_possible_max(divisor1, divisor2, unique_cnt1, unique_cnt2):
    return (divisor1 - 1) * unique_cnt1 + (divisor2 - 1) * unique_cnt2 + 1
```

",,
"```python
def shortest_distance(words, target, startIndex):
    n = len(words)
    left, right, i = 0, 0, startIndex
    while True:
        if words[i] == target:
            return min(left, right)
        left += 1
        right += 1
        i = (i + 1) % n
        if left == n:
            break
    return -1
```

",,
"```python
def min_minutes(s: str, k: int) -> int:
    n = len(s)
    left_counts = [0] * 3
    right_counts = [0] * 3
    for c in s:
        right_counts[ord(c) - ord('a')] += 1

    ans, total = n, 0
    l, r = 0, n - 1
    while l < r:
        while l < r and left_counts[ord(s[l]) - ord('a')] < k and right_counts[ord(s[r]) - ord('a')] < k:
            need_left = max(0, k - left_counts[ord(s[l]) - ord('a')])
            need_right = max(0, k - right_counts[ord(s[r]) - ord('a')])
            if need_left <= need_right:
                total += need_left
                l += 1
                left_counts[ord(s[l]) - ord('a')] += 1
                right_counts[ord(s[l]) - ord('a')] -= 1
            else:
                total += need_right
                r -= 1
                right_counts[ord(s[r]) - ord('a')] -= 1
                left_counts[ord(s[r]) - ord('a')] += 1
        ans = min(ans, total)
        if l + 1 < n:
            total -= left_counts[ord(s[l]) - ord('a')]
            left_counts[ord(s[l]) - ord('a')] -= 1
            right_counts[ord(s[l + 1]) - ord('a')] += 1
            l += 1
        else:
            break
    if all(cnt >= k for cnt in left_counts): 
        return ans
    return -1
```

",,
"```python
def max_tastiness(price, k):
    price.sort()
    max_tastiness = 0
    for i in range(len(price) - k + 1):
        min_diff = float('inf')
        for j in range(i, i + k - 1):
            min_diff = min(min_diff, price[j + 1] - price[j])
        max_tastiness = max(max_tastiness, min_diff)

    return max_tastiness
```

",,
"```python
def countPartitions(nums, k):
    total_sum = sum(nums)
    n = len(nums)
    mod = 1000000007

    if total_sum < k * 2:
        return 0

    dp = [1] * (n + 1)

    for i in range(1, k):
        for j in range(n - 1, 0, -1):
            dp[j] = (dp[j] * j + dp[j - 1]) % mod

    result = 0

    for i in range(n - 1):
        total_sum -= nums[i]
        if total_sum >= k:
            result = (result + dp[i + 1]) % mod

    return result
```

",,
"```python
def kBigIndices(nums, k):
    n = len(nums)
    left, right = [0] * n, [0] * n

    for i in range(1, n):
        if nums[i] > nums[i - 1]:
            left[i] = left[i - 1] + 1

        j = n - i - 1
        if nums[j] < nums[j + 1]:
            right[j] = right[j + 1] + 1

    return sum(1 for i in range(n) if left[i] >= k and right[i] >= k)
```

",,
"```python
def digits_dividing_num(num):
    count = 0
    temp = num
    while temp > 0:
        digit = temp % 10
        if num % digit == 0:
            count += 1
        temp //= 10
    return count
```


",,
"```python
def count_distinct_prime_factors(nums):
    prime_factors = set()
    for n in nums:
        for divisor in range(2, int(n**0.5) + 1):
            if n % divisor == 0:
                prime_factors.add(divisor)
                prime_factors.add(n // divisor)
    return len(prime_factors)
```

",,
"```python
def min_partitions(s: str, k: int) -> int:
    n = len(s)
    count = 0
    idx = 0

    while idx < n:
        currentValue = 0
        while idx < n and currentValue * 10 + int(s[idx]) <= k:
            currentValue = currentValue * 10 + int(s[idx])
            idx += 1

        if currentValue == 0:
            return -1
        count += 1

    return count
```

",,
"```python
def is_prime(n):
    if n <= 1:
        return False
    i = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += 1
    return True

def closest_prime_pair(left, right):
    min_dist = right - left + 1
    ans = [-1, -1]
    for i in range(left, right + 1):
        if is_prime(i):
            for j in range(i + 1, right + 1):
                if is_prime(j) and j - i < min_dist:
                    min_dist = j - i
                    ans = [i, j]
    return ans
```

",,
"```python
def maxFrequencyScore(nums, k):
    n = len(nums)
    right = 0
    count = 0
    max_score = 0
    score = 0
    freq_map = {}

    for left in range(n):
        while right < n and count < k:
            score = (score + nums[right] * freq_map.get(nums[right], 0)) % 1000000007
            freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1
            count += 1
            right += 1

        max_score = max(max_score, score)

        if count == k:
            score -= nums[left] * (freq_map[nums[left]] - 1)
            freq_map[nums[left]] -= 1
            count -= 1

    return max_score
```

",,
"```python
def boxCategory(length: int, width: int, height: int, mass: int) -> str:
    bulky = length >= 10000 or width >= 10000 or height >= 10000 or int(length) * width * height >= 1000000000
    heavy = mass >= 100
    
    if bulky and heavy:
        return ""Both ""
    if bulky:
        return ""Bulky ""
    if heavy:
        return ""Heavy ""
    return ""Neither ""
```

",,
"```python
from collections import deque

class DataStream:
    def __init__(self, value: int, k: int):
        self.value = value
        self.k = k
        self.stream = deque()

    def consec(self, num: int) -> bool:
        self.stream.append(num)
        if len(self.stream) > self.k:
            self.stream.popleft()

        return len(self.stream) == self.k and self.stream.count(self.value) == self.k
```


",,
"```python
def xor_beauty(nums):
    n = len(nums)
    maxXOR = 1024
    counter = [0] * maxXOR
    
    for num in nums:
        counter[num % maxXOR] += 1
        
    xor_beauty = 0
    for i in range(maxXOR):
        for j in range(i, maxXOR):
            k = (i | j) & (~(i ^ j))
            if k < maxXOR and k >= j:
                count = counter[i] * counter[j] * (1 if i == j else 2)
                if k != i and k != j:
                    count *= counter[k]
                xor_beauty ^= count
                
    return xor_beauty
```

",,
"```python
def max_min_power(stations, r, k):
    n = len(stations)
    total_power = [0] * n
    for i in range(n):
        for j in range(max(0, i - r), min(n, i + r + 1)):
            total_power[j] += stations[i]

    sumk = 0
    min_power = float('inf')
    for i in range(r, n - r):
        sumk += stations[i]
        min_power = min(min_power, total_power[i])

    for j in range(2 * r):
        i = n - 2 * r - 1 - j
        sumk -= stations[i + r + 1]
        min_power -= stations[j]
        min_power += sumk
        min_power += k
        min_power = min(min_power, total_power[j])

    return min_power
```

",,
"```python
def max_positive_negative_count(nums):
    pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums))
    neg = len(nums) - pos
    return max(pos, neg)
```

",,
"```python
import heapq

def max_score(nums, k):
    pq = [-x for x in nums]
    heapq.heapify(pq)
    score = 0

    for _ in range(k):
        cur = -heapq.heappop(pq)
        score += cur
        heapq.heappush(pq, -cur // 3)

    return score
```


",,
"```python
def compare(w1,w2):
    counts_w1 = [0]*26
    counts_w2 = [0]*26
    for c in w1: counts_w1[ord(c)-ord('a')] += 1
    for c in w2: counts_w2[ord(c)-ord('a')] += 1
    for i in range(26):
        if counts_w1[i] and counts_w2[i]: return True
    return False

def swap_equal_distinct(word1, word2):
    exch = compare(word1, word2)
    return exch and len(word1) == len(word2)
```

",,
"```python
from heapq import heappush, heappop

def getLastMoment(n, k, time):
    left = [(time[j][0] + time[j][2], j) for j in range(k)]
    right = []

    while n:
        while right and right[0][0] <= left[0][0]:
            right_top = heappop(right)
            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))
        left_top = heappop(left)
        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]
        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))
        n -= 1

    lastMoment = -1
    while right:
        right_top = heappop(right)
        lastMoment = max(lastMoment, time[right_top[1]][2])
    return lastMoment
```

",,
"```python
def countGoodStrings(minLength, maxLength, oneGroup, zeroGroup):
    mod = 1000000007
    maxCount = maxLength // oneGroup + maxLength // zeroGroup

    dp = [0] * (maxCount + 1)
    dp[0] = 1

    for i in range(1, maxCount + 1):
        dp[i] = dp[i - 1] * (1 if i % oneGroup == 0 or i % zeroGroup == 0 else 0) % mod

    ans = 0
    for i in range(maxCount + 1):
        ans = (ans + dp[minLength // oneGroup + minLength // zeroGroup - i]
               - (0 if minLength - 1 // oneGroup + minLength - 1 // zeroGroup - i < 0 else
                  dp[(minLength - 1) // oneGroup + (minLength - 1) // zeroGroup - i])) % mod

    return ans
```

",,
"```python
def time_crossing_the_door(arrival, state):
    n = len(arrival)
    answer = [0] * n
    door_seen_time = [-1, -1]
    i, t = 0, 0
    while i < n:
        while t < arrival[i]:
            t += 1
        direction = 1 if door_seen_time[1] != t - 1 else 0
        if state[i] == direction:
            door_seen_time[state[i]] = t
        else:
            while i + 1 < n and arrival[i + 1] == t and state[i + 1] != direction:
                i += 1
            if i + 1 < n and arrival[i + 1] == t and state[i + 1] == direction:
                door_seen_time[state[i + 1]] = t
                i += 1
            else:
                t -= 1
                i -= 1
        answer[i] = door_seen_time[state[i]]
        i += 1
        t += 1
    return answer
```

",,
"```python
def difference_between_element_and_digit_sum(nums):
    element_sum = sum(nums)
    digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums)
    return abs(element_sum - digit_sum)
```

",,
"```python
def apply_queries(n, queries):
    mat = [[0] * n for _ in range(n)]

    for query in queries:
        for i in range(query[0], query[2] + 1):
            for j in range(query[1], query[3] + 1):
                mat[i][j] += 1

    return mat
```

",,
"```python
def goodSubarrays(nums, k):
    count = {0: 1}
    result = 0
    prefix_sum = 0

    for num in nums:
        prefix_sum += num - 1
        if prefix_sum - k in count:
            result += count[prefix_sum - k]
        count[prefix_sum] = count.get(prefix_sum, 0) + 1

    return result
```

",,
"```python
from typing import List

def dfs(u, p, adj, price, dp):
    dp[u] = [[price[u], 0], [price[u], 0]]

    for v in adj[u]:
        if v == p:
            continue
        dfs(v, u, adj, price, dp)
        tmpF = sorted([dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]])
        tmpS = sorted([dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]])

        dp[u][0] = tmpF
        dp[u][1] = tmpS

def getMaxCost(n: int, edges: List[List[int]], price: List[int]) -> int:
    adj = [[] for _ in range(n)]
    dp = [None] * n

    for e in edges:
        adj[e[0]].append(e[1])
        adj[e[1]].append(e[0])

    dfs(0, -1, adj, price, dp)

    ans = 0
    for i in range(n):
        ans = max(ans, dp[i][0][1] - dp[i][1][1])

    return ans
```


",,
"```python
def numberOfGoodSubsequences(s: str) -> int:
    count = [0] * 26
    ans = 0
    MOD = 1000000007
    
    for c in s:
        count[ord(c) - ord('a')] += 1
        
    for val in count:
        ans = (ans + (1 << val) - 1) % MOD
        
    return ans
```


",,
"```python
def min_common_number(nums1, nums2):
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            return nums1[i]
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1
    return -1
```

",,
"```python
def min_changes(nums1, nums2, k):
    n = len(nums1)
    operations = 0
    for i in range(n):
        diff = abs(nums1[i] - nums2[i])
        if diff % k != 0:
            return -1
        operations += diff // k
    return operations
```

",,
"```python
def maxScore(nums1, nums2, k):
    n = len(nums1)
    res = 0
    sum_n1 = 0
    min_n2 = nums2[0]
    i, j = 0, 0
    while j < n:
        sum_n1 += nums1[j]
        min_n2 = min(min_n2, nums2[j])
        if j - i + 1 > k:
            sum_n1 -= nums1[i]
            i += 1
        if j + 1 >= k:
            res = max(res, sum_n1 * min_n2)
        j += 1
    return res
```


",,
"```python
def canReach(targetX, targetY):
    while targetX > 1 and targetY > 1:
        if targetX < targetY:
            targetX, targetY = targetY, targetX
        targetX -= targetY
    return targetX == 1 or targetY == 1
```

",,
"```python
def sum_of_digits(n: int) -> int:
    total = 0
    positive = True

    while n > 0:
        digit = n % 10
        n //= 10

        if positive:
            total += digit
        else:
            total -= digit

        positive = not positive

    return total
```

",,
"```python
def sort_students(score, k):
    score.sort(key=lambda x: x[k], reverse=True)
    return score
```


",,
"```python
def can_make_equal(s: str, target: str) -> bool:
    s_count_ones = s.count('1')
    target_count_ones = target.count('1')
    return s_count_ones >= target_count_ones
```

",,
"```python
def minCost(nums: List[int], k: int) -> int:
    n = len(nums)
    count = [0] * 1001
    dp = [0] * (n + 1)

    i = 0
    for j in range(n):
        count[nums[j]] += 1
        
        if count[nums[j]] == 2:
            dp[j + 1] = dp[i] + k + (j - i + 1)
        elif count[nums[j]] > 2:
            dp[j + 1] = min(dp[j], dp[j - 1] + 1)
        else:
            dp[j + 1] = dp[j] + 1

        while i <= j and count[nums[i]] >= 2:
            count[nums[i]] -= 1
            i += 1

    return dp[n] + n * k
```

",,
"```python
def maxValue(items, capacity):
    items.sort(key=lambda x: x[0] / x[1], reverse=True)

    maxTotalPrice = 0
    for item in items:
        if capacity >= item[1]:
            capacity -= item[1]
            maxTotalPrice += item[0]
        else:
            maxTotalPrice += item[0] * capacity / item[1]
            break

    return maxTotalPrice
```


",,
"```python
def distinct_numbers(n):
    return n - 1
```


",,
"```python
def ways_to_collide(n):
    MOD = 10**9 + 7
    return (pow(2, n, MOD) - n - 1 + MOD) % MOD
```

",,
"```python
def maximize_score(weights, k):
    n = len(weights)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + weights[i]

    dp = [[-1000000000] * (k + 1) for _ in range(n)]

    for i in range(n):
        dp[i][1] = prefix_sum[i + 1]
        if i > 0:
            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]
        for j in range(2, min(i + 1, k) + 1):
            for q in range(1, i - j + 3):
                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])

    return dp[n - 1][k] - dp[n - 1][1]
```

",,
"
```javascript
function increasingQuadruplets(nums) {
    const n = nums.length;
    let count = 0;
    for(let i = 0; i < n - 3; i++) {
        for(let j = i + 1; j < n - 2; j++) {
            for(let k = j + 1; k < n - 1; k++) {
                if(nums[i] < nums[k] && nums[k] < nums[j]) {
                    for(let l = k + 1; l < n; l++) {
                        if(nums[j] < nums[l]) {
                            count++;
                        }
                    }
                }
            }
        }
    } 
    return count;
}
```


",,
"```python
def separate_digits(nums):
    answer = []
    for num in nums:
        digits = [int(d) for d in str(num)]
        answer.extend(digits)
    return answer
```


",,
"```python
def max_chosen_integers(banned, n, max_sum):
    banned_set = set(banned)
    count = 0
    total_sum = 0
    for i in range(n, 0, -1):
        if i not in banned_set and max_sum - total_sum >= i:
            total_sum += i
            count += 1
    return count
```

",,
"```python
from bisect import bisect_left, bisect_right

def max_prizes(prize_positions, k):
    n = len(prize_positions)
    ans = 0
    for i in range(n):
        left_segment_end = prize_positions[i] + k
        right_segment_start = bisect_right(prize_positions, left_segment_end)
        right_segment_end = prize_positions[right_segment_start] + k
        ans = max(ans, bisect_right(prize_positions, right_segment_end) - bisect_left(prize_positions, prize_positions[i]))
    return ans
```

",,
"```python
def canReach(grid, row, col):
    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 0:
        return False

    if row == len(grid) - 1 and col == len(grid[0]) - 1:
        return True

    grid[row][col] = 0

    return canReach(grid, row + 1, col) or canReach(grid, row, col + 1)

def canDisconnect(grid):
    reachableCount = 0

    for row in range(1, len(grid)):
        for col in range(1, len(grid[0])):
            if grid[row][col] == 1 and (canReach(grid, row - 1, col) or canReach(grid, row, col - 1)):
                reachableCount += 1
                if reachableCount > 1:
                    return True

    return reachableCount <= 1
```

",,
"```python
def max_chosen_integers(banned, n, max_sum):
    banned_set = set(banned)
    chosen_integers = 0
    chosen_sum = 0

    for i in range(n, 0, -1):
        if i not in banned_set and chosen_sum < max_sum:
            if chosen_sum + i <= max_sum:
                chosen_sum += i
                chosen_integers += 1
            else:
                break

    return chosen_integers
```

",,
"```python
import math

def giftsRemaining(gifts, k):
    for i in range(k):
        gifts.sort()
        max_index = len(gifts) - 1
        gifts[max_index] -= int(math.sqrt(gifts[max_index]))
    return sum(gifts)
```

",,
"```python
def is_vowel(c: str) -> bool:
    return c in ""aeiou""

def count_vowel_strings(words: List[str], queries: List[List[int]]) -> List[int]:
    ans = []
    for query in queries:
        count = 0
        for i in range(query[0], query[1] + 1):
            if is_vowel(words[i][0]) and is_vowel(words[i][-1]):
                count += 1
        ans.append(count)
    return ans
```

",,
"```python
def minimumCapability(nums, k):
    n, l, r = len(nums), 1, 10**9
    while l < r:
        mid = l + (r - l) // 2
        i, cnt = 0, 0
        for j in range(n):
            if nums[j] <= mid:
                cnt += 1
                i = j + 2
                while i + 1 < n and (i == j + 1 or nums[i] > mid):
                    i += 1
        if cnt < k:
            l = mid + 1
        else:
            r = mid
    return l
```

",,
"```python
def min_cost_to_equal_baskets(basket1, basket2):
    diff_count = {}
    for i in range(len(basket1)):
        diff = basket1[i] - basket2[i]
        diff_count[diff] = diff_count.get(diff, 0) + 1

    min_cost = float('inf')
    for diff, count in diff_count.items():
        if count == diff_count.get(-diff, 0):
            cost = sum(min(basket1[i], basket2[i]) for i in range(len(basket1)) if basket1[i] - basket2[i] == diff)
            min_cost = min(min_cost, cost)

    return -1 if min_cost == float('inf') else min_cost // 2
```

",,
"```python
def concatenationValue(nums):
    value = 0
    while nums:
        n = len(nums)
        if n == 1:
            value += nums[0]
            nums.pop()
        else:
            value += int(str(nums[0]) + str(nums[-1]))
            nums.pop(0)
            nums.pop()
    return value
```

",,
"```python
def count_fair_pairs(nums, lower, upper):
    n = len(nums)
    fair_pairs = 0
    for i in range(n):
        for j in range(i+1, n):
            if lower <= nums[i] + nums[j] <= upper:
                fair_pairs += 1
    return fair_pairs
```

",,
"```python
from math import log2
def shortestSubstringQueries(s, queries):
    n = len(s)
    dp = {}
    val = 0
    mask = 0

    for i in range(n):
        mask |= 1 << int(s[i])
        val = (val << 1) | int(s[i])

        for j in range(10):
            if i + 1 - (1 << j) >= 0:
                newVal = val & ((1 << (j + 1)) - 1)
                if newVal not in dp:
                    dp[newVal] = i + 1 - (1 << j)

    ans = []
    for query in queries:
        target = query[0] ^ query[1]
        if target in dp:
            ans.append([dp[target], dp[target] + int(log2(target))])
        else:
            ans.append([-1, -1])

    return ans
```

",,
"```python
def minScore(s, t):
    m, n = len(s), len(t)
    dp = [[1e6]*(n+1) for _ in range(m+1)]
    dp[0][0] = 0
    for i in range(m):
        for j in range(n):
            if s[i] == t[j]:
                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j])
            else:
                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + 1)
    ans = 1e6
    for i in range(m):
        ans = min(ans, dp[i+1][n])
    return int(ans)
```

",,
"```python
def diffMaxMin(num):
    max_remap = 1
    min_remap = 9
    num_str = str(num)
    
    for c in num_str:
        digit = int(c)
        max_remap = max(max_remap, 9 - digit)
        if digit != 0:
            min_remap = min(min_remap, digit)

    max_value = num + max_remap * (len(num_str) - num_str.count(str(9 - max_remap)))
    min_value = num - min_remap * num_str.count(str(min_remap))
    return max_value - min_value
```

",,
"```python
def min_score_after_change(nums):
    n = len(nums)
    first_min, second_min, last_max, second_last_max = nums[0], nums[1], nums[-1], nums[-2]

    for i in range(1, n - 1):
        first_min = min(first_min, nums[i])
        second_min = min(second_min, nums[i + 1])
        last_max = max(last_max, nums[i])
        second_last_max = max(second_last_max, nums[i - 1])

    low = min(min(first_min, last_max), min(second_min, second_last_max))
    high = max(max(first_min, last_max), max(second_min, second_last_max))

    return high - low
```

",,
"```python
def min_non_expressible_integer(nums):
    result = 1
    nums.sort()
    for num in nums:
        if num > result:
            break
        result += num
    return result
```

",,
"```python
def solve(nums1, nums2, queries):
    res = []
    for q in queries:
        if q[0] == 1:
            for i in range(q[1], q[2] + 1):
                nums1[i] ^= 1
        elif q[0] == 2:
            for i in range(len(nums1)):
                nums2[i] += nums1[i] * q[1]
        elif q[0] == 3:
            res.append(sum(nums2))
    return res
```


",,
"```python
def merge_nums(nums1, nums2):
    merged_map = {}
    merged = []

    for id_val_pair in nums1:
        id_, val_ = id_val_pair
        if id_ not in merged_map:
            merged_map[id_] = val_
        else:
            merged_map[id_] += val_

    for id_val_pair in nums2:
        id_, val_ = id_val_pair
        if id_ not in merged_map:
            merged_map[id_] = val_
        else:
            merged_map[id_] += val_

    for id_, val_ in merged_map.items():
        merged.append([id_, val_])
    
    return merged
```

",,
"```python
def minOperations(n: int) -> int:
    operations = 0
    while n:
        operations += n % 2
        n //= 2
    return operations
```


",,
"```python
def countSquareFreeSubsets(nums):
    from collections import Counter
    counter = Counter(nums)
    MOD = 10**9 + 7

    dp = [[0] * 1001 for _ in range(61)]
    dp[0][0] = 1
    idx = 0
    for num, freq in counter.items():
        idx += 1
        for sq in range(61):
            for ns in range(1001 - freq):
                dp[idx][ns + freq] += dp[idx - 1][ns] * ((1 << freq) - 1) % MOD
                dp[idx][ns + freq] %= MOD
                dp[idx][ns] += dp[idx - 1][ns]
                dp[idx][ns] %= MOD

                if (sq // num) % 2 == 1:
                    dp[idx][ns + freq] -= dp[idx - 1][ns] * ((1 << (freq - 1)) - 1) % MOD
                    if dp[idx][ns + freq] < 0:
                        dp[idx][ns + freq] += MOD
    return dp[idx][0]
```


",,
"```python
def smallestWordForLCP(lcp):
    n = len(lcp)
    word = ['a'] * n
    for i in range(1, n):
        for j in range(1, n):
            if lcp[i][j] > min(lcp[i - 1][j], lcp[i][j - 1]):
                word[i + lcp[i][j] - 1] = max(word[i + lcp[i][j] - 1], chr(ord(word[i - 1]) + 1))
            elif lcp[i][j] < min(lcp[i - 1][j], lcp[i][j - 1]):
                return """"
    return """".join(word)
```

",,
"```python
def get_answer(nums):
    n = len(nums)
    left_sum, right_sum, answer = [0] * n, [0] * n, [0] * n

    for i in range(1, n):
        left_sum[i] = left_sum[i - 1] + nums[i - 1]

    for i in range(n - 2, -1, -1):
        right_sum[i] = right_sum[i + 1] + nums[i + 1]

    for i in range(n):
        answer[i] = abs(left_sum[i] - right_sum[i])

    return answer
```


",,
"```python
def divisibility_array(word: str, m: int) -> list[int]:
    div = []
    value = 0
    for c in word:
        value = (value * 10 + int(c)) % m
        div.append(1 if value == 0 else 0)
    return div
```

",,
"```python
from collections import deque

def minTime(grid: list[list[int]]) -> int:
    m, n = len(grid), len(grid[0])
    visited = [[1000000] * n for _ in range(m)]

    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]

    visited[0][0] = 0

    q = deque([(0, 0)])

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]

            if 0 <= nx < m and 0 <= ny < n:
                t = max(grid[nx][ny], visited[x][y] + 1)
                if visited[nx][ny] > t:
                    visited[nx][ny] = t
                    q.append((nx, ny))

    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1
```

",,
"```python
def min_sum_of_two_numbers(num: str) -> int:
    cnt = [0] * 10
    for c in num:
        cnt[int(c)] += 1

    num1, num2 = 0, 0
    for i in range(1, 10, 2):
        temp = cnt[i]
        while temp > 0:
            num1 = num1 * 10 + i
            temp -= 1
    for i in range(0, 10, 2):
        temp = cnt[i]
        while temp > 0:
            num2 = num2 * 10 + i
            temp -= 1
    return num1 + num2
```

",,
"```python
def number_of_colored_cells(n):
    return n * n + (n - 1) * (n - 1)
```

",,
"```python
def total_ways_to_split_ranges(ranges):
    MOD = 10**9 + 7
    ranges.sort(key=lambda x: x[1])
    overlapping, non_overlapping, prev_end = 0, 1, -1

    for start, end in ranges:
        if start <= prev_end:
            overlapping += 1
        else:
            non_overlapping += 1
        prev_end = max(prev_end, end)

    result = 1
    for i in range(1, overlapping + 1):
        result = (result * 2) % MOD

    return result
```

",,
"```python
def possibleRoots(edges, guesses, k):
    n = len(edges) + 1
    in_degree = [0] * n
    guess_parents = set()
    
    for guess in guesses:
        guess_parents.add(guess[0])
    
    for edge in edges:
        in_degree[edge[1]] += 1
    
    possible_roots = 0
    for i in range(n):
        if in_degree[i] == 0:
            if k == 0 or i in guess_parents:
                possible_roots += 1
        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:
            possible_roots += 1
    
    return possible_roots
```

",,
"```python
def pillowHolder(n, time):
    time %= (2 * n - 2)
    if time <= n - 1:
        return time + 1
    else:
        return 2 * n - time - 1
```

",,
"```python
from queue import Queue

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kthLargestLevelSum(root, k):
    level_sums = []
    q = Queue()
    q.put(root)

    while not q.empty():
        level_sum = 0
        level_size = q.qsize()
        for i in range(level_size):
            node = q.get()
            level_sum += node.val

            if node.left:
                q.put(node.left)
            if node.right:
                q.put(node.right)

        level_sums.append(level_sum)

    level_sums.sort(reverse=True)
    return level_sums[k-1] if k <= len(level_sums) else -1
```

",,
"```python
def find_valid_split(nums):
    n = len(nums)
    prefix = [0] * n
    suffix = [0] * n

    prefix[0] = nums[0]
    suffix[-1] = nums[-1]

    for i in range(1, n):
        prefix[i] = prefix[i - 1] * nums[i]

    for i in range(n - 2, -1, -1):
        suffix[i] = suffix[i + 1] * nums[i]

    for i in range(n - 1):
        if gcd(prefix[i], suffix[i + 1]) == 1:
            return i

    return -1

def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
```


",,
"```python
def numberOfWays(target, types):
    MOD = 10**9 + 7
    dp = [0] * (target + 1)
    dp[0] = 1
    for count, marks in types:
        dptmp = [0] * (target + 1)
        for i in range(target + 1):
            for j in range(count + 1):
                if j * marks + i <= target:
                    dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD
        dp = dptmp
    return dp[target]
```

",,
"```python
def is_vowel(c):
  return c in 'aeiou'

def count_vowel_strings(words, left, right):
  count = 0
  for i in range(left, right + 1):
    if is_vowel(words[i][0]) and is_vowel(words[i][-1]):
      count += 1
  return count
```

",,
"```python
def maxScore(nums: List[int]) -> int:
    nums.sort()
    result, prefixSum = 0, 0
    for i in range(len(nums)):
        if prefixSum + nums[i] > 0:
            result += 1
            prefixSum += nums[i]
    return result
```

",,
"```python
def beautifulSubarrays(nums):
    odd = [0] * 20
    even = [0] * 20
    even[0] = 1

    for num in nums:
        parity = bin(num).count('1') % 2
        for i in range(19, -1, -1):
            mask = 1 << i
            if num & mask:
                if parity:
                    odd[i], even[i] = even[i], odd[i]
                odd[i] += 1
            else:
                if not parity:
                    odd[i], even[i] = even[i], odd[i]
                even[i] += 1
            num -= num & mask

    ans = 0
    for i in range(20):
        ans += even[i] * (even[i] - 1) // 2
    return ans
```

",,
"```python
def min_time_on(tasks):
    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])

    dp = [0] * 2001
    for interval in intervals:
        for i in range(2000, interval[0] - 1, -1):
            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])

    return dp[-1]
```

",,
"```python
from typing import List

class Task:
    def __init__(self, id: int, description: str, due_date: int, tags: List[str]):
        self.id = id
        self.description = description
        self.due_date = due_date
        self.tags = tags
        self.completed = False

class TodoList:

    def __init__(self):
        self.task_id = 1
        self.tasks = {}

    def addTask(self, userId: int, taskDescription: str, dueDate: int, tags: List[str]) -> int:
        if userId not in self.tasks:
            self.tasks[userId] = []
        self.tasks[userId].append(Task(self.task_id, taskDescription, dueDate, tags))
        self.task_id += 1
        return self.task_id - 1

    def getAllTasks(self, userId: int) -> List[str]:
        if userId not in self.tasks:
            return []
        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)
        res = [task.description for task in user_tasks if not task.completed]
        return res

    def getTasksForTag(self, userId: int, tag: str) -> List[str]:
        if userId not in self.tasks:
            return []
        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)
        res = [task.description for task in user_tasks if not task.completed and tag in task.tags]
        return res

    def completeTask(self, userId: int, taskId: int) -> None:
        if userId not in self.tasks:
            return
        for task in self.tasks[userId]:
            if task.id == taskId:
                task.completed = True
                break
```

",,
"```python
def maximum_children_with_eight_dollars(money, children):
    if money < children * 1 or money > children * 8:
        return -1
    max_eights = (money - children) // 7
    return children if max_eights >= children else max_eights
```

",,
"```python
def max_greatness(nums):
    nums.sort()
    greatness = 0
    for i in range(1, len(nums)):
        if nums[i - 1] < nums[i]:
            nums[i - 1], nums[i] = nums[i], nums[i - 1]
            greatness += 1
    return greatness
```

",,
"```python
def calculate_score(nums):
    n = len(nums)
    dp = [0] * (n + 2)

    for i in range(n):
        dp[i + 2] = max(dp[i + 1], dp[i] + nums[i])

    return dp[n + 1]
```

",,
"```python
def min_time_to_repair(ranks, cars):
    ranks.sort()
    low, high = 0, 100 * cars * cars
    
    while low < high:
        mid = low + (high - low) // 2
        total_cars_repaired = 0
        for rank in ranks:
            cars_repaired = min(cars, mid // (rank * rank))
            total_cars_repaired += cars_repaired
            if total_cars_repaired >= cars:
                break
        if total_cars_repaired >= cars:
            high = mid
        else:
            low = mid + 1
            
    return low
```


",,
"```python
def even_odd_indices(n: int) -> List[int]:
    answer = [0, 0]
    index = 0
    while n > 0:
        if n % 2:
            answer[index % 2] += 1
        n //= 2
        index += 1
    return answer
```

",,
"```python
def isValidMove(i, j, k, n):
    return (i + 1 < n and j + 2 < n and k == n * (i + 1) + (j + 2)) or \
           (i + 1 < n and j - 2 >= 0 and k == n * (i + 1) + (j - 2)) or \
           (i + 2 < n and j + 1 < n and k == n * (i + 2) + (j + 1)) or \
           (i + 2 < n and j - 1 >= 0 and k == n * (i + 2) + (j - 1))

def validPath(grid):
    n = len(grid)
    for i in range(n):
        for j in range(n):
            k = grid[i][j]
            if k != n * n - 1 and not isValidMove(i, j, k + 1, n):
                return False
    return True
```

",,
"```python
def countBeautifulSubsets(nums, k):
    nums.sort()
    ans = 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        l = r = 0
        for j in range(i):
            while l < j and nums[j] - nums[l] >= k:
                l += 1
            while r + 1 < j and nums[r + 1] - nums[j] < k:
                r += 1
            dp[j] -= dp[l - 1] if l <= r else 0
            dp[j] += dp[j - 1] + 1
            ans += dp[j]
    return ans
```

",,
"```python
def maximum_mex(nums: List[int], value: int) -> int:
    st = set(nums)

    for i in range(100001):
        if i not in st:
            st.add(i + value)

    mex = 0
    while mex in st:
        mex += 1
    
    return mex
```

",,
"```python
def min_operations(nums):
    min_prefix = 0
    prefix = 0
    for num in nums:
        prefix += num
        min_prefix = min(min_prefix, prefix)
    return -min_prefix if min_prefix < 0 else 0
```

",,
"```python
def max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
    max_sum = 0
    for i in range(k + 1):
        ones = min(i, numOnes)
        neg_ones = min(k - i, numNegOnes)
        max_sum = max(max_sum, ones - neg_ones)
    return max_sum
```

",,
"```python
def strictlyIncreasingArray(nums):
    for i in range(len(nums) - 1):
        nums[i] -= i
        if nums[i] >= nums[i + 1]:
            return False
    return True
```

",,
"```python
from typing import List

def min_operations(nums: List[int], queries: List[int]) -> List[int]:
    answer = []
    for query in queries:
        operations = 0
        for num in nums:
            operations += abs(num - query)
        answer.append(operations)
    return answer
```

",,
"```python
from collections import defaultdict

def min_edges_to_collect_coins(coins, edges):
    adj = defaultdict(list)
    for a, b in edges:
        adj[a].append(b)
        adj[b].append(a)
    return dfs(adj, coins, 0, -1)[1] // 2

def dfs(adj, coins, node, parent):
    sum_coins = coins[node]
    distance = 0
    for neighbor in adj[node]:
        if neighbor != parent:
            result = dfs(adj, coins, neighbor, node)
            sum_coins += result[0]
            distance += 2 * result[0] + result[1]
    return (sum_coins, distance)
```


",,
"```python
def min_time_to_eat_grains(hens, grains):
    hens.sort()
    grains.sort()
    left, right = 0, 10**9

    while left < right:
        mid = left + (right - left) // 2
        can_eat = True
        i = 0

        for grain in grains:
            if i >= len(hens):
                can_eat = False
                break

            while i < len(hens) and hens[i] < grain - mid:
                i += 1

            if i >= len(hens) or hens[i] > grain + mid:
                can_eat = False
                break

            i += 1

        if can_eat:
            right = mid
        else:
            left = mid + 1

    return left
```

",,
"```python
def smallest_number_with_at_least_one_digit_from_each_array(nums1, nums2):
    min1 = min(nums1)
    min2 = min(nums2)
    for num1 in nums1:
        for num2 in nums2:
            if num1 == num2:
                return num1
    return min1 * 10 + min2
```

",,
"```python
def max_value_substring(s, chars, vals):
    values = {key: val for key, val in zip(chars, vals)}

    max_cost = 0
    cost = 0

    for c in s:
        value = values.get(c) if c in values else ord(c) - ord('a') + 1

        cost = max(0, cost + value)
        max_cost = max(max_cost, cost)

    return max_cost
```


",,
"```python
def minOperations(arr: List[int], k: int) -> int:
    n = len(arr)
    res = float('inf')
    prefix = [0] * (n + 1)

    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1] + arr[i - 1]

    for i in range(1, n - k + 2):
        target = (prefix[i - 1] + prefix[n] - prefix[i + k - 1] + n // k - 1) // (n // k)
        curr_cost = 0
        for j in range(i, i + k):
            curr_cost += abs(arr[j - 1] - target)
        res = min(res, curr_cost)

    return res
```

",,
"```python
from collections import deque

def shortest_cycle_length(n, edges):
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
        
    shortest_cycle = n + 1
    for start in range(n):
        dist = [n + 1] * n
        dist[start] = 0
        queue = deque([start])
        
        while queue:
            cur = queue.popleft()
            for neigh in graph[cur]:
                if dist[neigh] == n + 1:
                    dist[neigh] = dist[cur] + 1
                    queue.append(neigh)
                elif dist[neigh] >= dist[cur] - 1:
                    shortest_cycle = min(shortest_cycle, dist[cur] + dist[neigh] + 1)
                    
    return -1 if shortest_cycle == n + 1 else shortest_cycle
```

",,
"```python
def longestBalancedSubstring(s):
    max_len = 0
    zeros = ones = 0
    for c in s:
        if c == '0':
            zeros += 1
        else:
            ones += 1
        if zeros == ones:
            max_len = max(max_len, zeros * 2)
        elif zeros > ones:
            zeros = ones = 0
    zeros = ones = 0
    for c in reversed(s):
        if c == '0':
            zeros += 1
        else:
            ones += 1
        if zeros == ones:
            max_len = max(max_len, zeros * 2)
        elif zeros < ones:
            zeros = ones = 0
    return max_len
```

",,
"```python
def distinct_rows_from(nums):
    rows = []
    
    for num in nums:
        inserted = False
        for row in rows:
            if num not in row:
                row.add(num)
                inserted = True
                break
        
        if not inserted:
            rows.append({num})

    return [list(row) for row in rows]
```

",,
"```python
def maxPoints(reward1, reward2, k):
    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)
    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))
    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))
    return firstMousePoints + secondMousePoints
```

",,
"```python
def reach_position(n, p, banned, k):
    banned_positions = set(banned)
    ans = [0] * n

    for i in range(n):
        if i in banned_positions or i == p:
            ans[i] = -1
            continue

        an = abs(p - i) // k
        if abs(p - i) % k == 0 and (an & 1) == (((n - 1) & 1) ^ (k & 1)):
            steps = an
        else:
            steps = -1

        ans[i] = steps

    ans[p] = 0
    return ans
```

",,
